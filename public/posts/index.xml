<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 煎鱼</title>
		<link>https://eddycjy.com/posts/</link>
		<description>Recent content in Posts on 煎鱼</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-hans</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Fri, 28 Feb 2020 12:00:00 +0000</lastBuildDate>
		<atom:link href="https://eddycjy.com/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Go Modules 终极入门</title>
			<link>https://eddycjy.com/posts/go/go-moduels/2020-02-28-go-modules/</link>
			<pubDate>Fri, 28 Feb 2020 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/go-moduels/2020-02-28-go-modules/</guid>
			<description>Go modules 是 Go 语言中正式官宣的项目依赖解决方案，Go modules（前身为vgo）于 Go1.11 正式发布，在 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，Go官方也鼓励所有用户从其他依赖项管理工具迁移到 Go modules。
而 Go1.14，在近期也终于正式发布，Go 官方亲自 “喊” 你来用：
因此在今天这篇文章中，我将给大家带来 Go modules 的 “终极入门”，欢迎大家一起共同探讨。
Go modules 是 Go 语言中正式官宣的项目依赖管理工具，Go modules（前身为vgo）于 Go1.11 正式发布，在 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，鼓励所有用户从其他依赖项管理工具迁移到 Go modules。
什么是Go Modules Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 推荐在生产上使用。
Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：
 Go 语言长久以来的依赖管理问题。 “淘汰”现有的 GOPATH 的使用模式。 统一社区中的其它的依赖管理工具（提供迁移功能）。  GOPATH的那些点点滴滴 我们有提到 Go modules 的解决的问题之一就是“淘汰”掉 GOPATH，但是 GOPATH 又是什么呢，为什么在 Go1.</description>
			<content type="html"><![CDATA[<p>Go modules 是 Go 语言中正式官宣的项目依赖解决方案，Go modules（前身为vgo）于 Go1.11 正式发布，在 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，Go官方也鼓励所有用户从其他依赖项管理工具迁移到 Go modules。</p>
<p>而 Go1.14，在近期也终于正式发布，Go 官方亲自 “喊” 你来用：</p>
<p><img src="https://image.eddycjy.com/243fb2cca64972b2f36827f59b26d840.jpeg" alt="image"></p>
<p>因此在今天这篇文章中，我将给大家带来 Go modules 的 “终极入门”，欢迎大家一起共同探讨。</p>
<p>Go modules 是 Go 语言中正式官宣的项目依赖管理工具，Go modules（前身为vgo）于 Go1.11 正式发布，在 Go1.14 已经准备好，并且可以用在生产上（ready for production）了，鼓励所有用户从其他依赖项管理工具迁移到 Go modules。</p>
<h2 id="什么是go-modules">什么是Go Modules</h2>
<p>Go modules 是 Go 语言的依赖解决方案，发布于 Go1.11，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14 推荐在生产上使用。</p>
<p>Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles 了，而 Go modules 的出现也解决了在 Go1.11 前的几个常见争议问题：</p>
<ol>
<li>Go 语言长久以来的依赖管理问题。</li>
<li>“淘汰”现有的 GOPATH 的使用模式。</li>
<li>统一社区中的其它的依赖管理工具（提供迁移功能）。</li>
</ol>
<h2 id="gopath的那些点点滴滴">GOPATH的那些点点滴滴</h2>
<p>我们有提到 Go modules 的解决的问题之一就是“淘汰”掉 GOPATH，但是 GOPATH 又是什么呢，为什么在 Go1.11 前就使用 GOPATH，而 Go1.11 后就开始逐步建议使用 Go modules，不再推荐 GOPATH 的模式了呢？</p>
<h3 id="gopath是什么">GOPATH是什么</h3>
<p>我们先看看第一个问题，GOPATH 是什么，我们可以输入如下命令查看：</p>
<pre><code>$ go env
GOPATH=&quot;/Users/eddycjy/go&quot;
...
</code></pre><p>我们输入<code>go env</code>命令行后可以查看到 GOPATH 变量的结果，我们进入到该目录下进行查看，如下：</p>
<pre><code>go
├── bin
├── pkg
└── src
    ├── github.com
    ├── golang.org
    ├── google.golang.org
    ├── gopkg.in
    ....
</code></pre><p>GOPATH目录下一共包含了三个子目录，分别是：</p>
<ul>
<li>bin：存储所编译生成的二进制文件。</li>
<li>pkg：存储预编译的目标文件，以加快程序的后续编译速度。</li>
<li>src：存储所有<code>.go</code>文件或源代码。在编写 Go 应用程序，程序包和库时，一般会以<code>$GOPATH/src/github.com/foo/bar</code>的路径进行存放。</li>
</ul>
<p>因此在使用 GOPATH 模式下，我们需要将应用代码存放在固定的<code>$GOPATH/src</code>目录下，并且如果执行<code>go get</code>来拉取外部依赖会自动下载并安装到<code>$GOPATH</code>目录下。</p>
<h3 id="为什么弃用gopath模式">为什么弃用GOPATH模式</h3>
<p>在 GOPATH 的 <code>$GOPATH/src</code> 下进行 <code>.go</code> 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式，看起来好像没有什么问题，那么为什么我们要弃用呢，参见如下原因：</p>
<ul>
<li>GOPATH 模式下没有版本控制的概念，具有致命的缺陷，至少会造成以下问题：
<ul>
<li>在执行<code>go get</code>的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。</li>
<li>在运行Go应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。</li>
<li>你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是<code>github.com/foo/bar</code>。</li>
</ul>
</li>
<li>Go 语言官方从 Go1.11 起开始推进 Go modules（前身vgo），Go1.13 起不再推荐使用 GOPATH 的使用模式，Go modules 也渐趋稳定，因此新项目也没有必要继续使用GOPATH模式。</li>
</ul>
<h3 id="在gopath模式下的产物">在GOPATH模式下的产物</h3>
<p>Go1 在 2012 年 03 月 28 日发布，而 Go1.11 是在 2018 年 08 月 25 日才正式发布（数据来源：Github Tag），在这个空档的时间内，并没有 Go modules 这一个东西，最早期可能还好说，因为刚发布，用的人不多，所以没有明显暴露，但是后期 Go 语言使用的人越来越多了，那怎么办？</p>
<p>这时候社区中逐渐的涌现出了大量的依赖解决方案，百花齐放，让人难以挑选，其中包括我们所熟知的 vendor 目录的模式，以及曾经一度被认为是“官宣”的 dep 的这类依赖管理工具。</p>
<p>但为什么 dep 没有正在成为官宣呢，其实是因为随着 Russ Cox 与 Go 团队中的其他成员不断深入地讨论，发现dep 的一些细节似乎越来越不适合 Go，因此官方采取了另起 proposal 的方式来推进，其方案的结果一开始先是释出 vgo（Go modules的前身，知道即可，不需要深入了解），最终演变为我们现在所见到的 Go modules，也在 Go1.11 正式进入了 Go 的工具链。</p>
<p>因此与其说是 “在GOPATH模式下的产物”，不如说是历史为当前提供了重要的教训，因此出现了 Go modules。</p>
<h2 id="go-modules基本使用">Go Modules基本使用</h2>
<p>在初步了解了 Go modules 的前世今生后，我们正式进入到 Go modules 的使用，首先我们将从头开始创建一个 Go modules 的项目（原则上所创建的目录应该不要放在 GOPATH 之中）。</p>
<h3 id="所提供的命令">所提供的命令</h3>
<p>在 Go modules 中，我们能够使用如下命令进行操作：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>go mod init</td>
<td>生成 go.mod 文件</td>
</tr>
<tr>
<td>go mod download</td>
<td>下载 go.mod 文件中指明的所有依赖</td>
</tr>
<tr>
<td>go mod tidy</td>
<td>整理现有的依赖</td>
</tr>
<tr>
<td>go mod graph</td>
<td>查看现有的依赖结构</td>
</tr>
<tr>
<td>go mod edit</td>
<td>编辑 go.mod 文件</td>
</tr>
<tr>
<td>go mod vendor</td>
<td>导出项目所有的依赖到vendor目录</td>
</tr>
<tr>
<td>go mod verify</td>
<td>校验一个模块是否被篡改过</td>
</tr>
<tr>
<td>go mod why</td>
<td>查看为什么需要依赖某模块</td>
</tr>
</tbody>
</table>
<h3 id="所提供的环境变量">所提供的环境变量</h3>
<p>在 Go modules 中有如下常用环境变量，我们可以通过 <code>go env</code> 命令来进行查看，如下：</p>
<pre><code>$ go env
GO111MODULE=&quot;auto&quot;
GOPROXY=&quot;https://proxy.golang.org,direct&quot;
GONOPROXY=&quot;&quot;
GOSUMDB=&quot;sum.golang.org&quot;
GONOSUMDB=&quot;&quot;
GOPRIVATE=&quot;&quot;
...
</code></pre><h4 id="go111module">GO111MODULE</h4>
<p>Go语言提供了 GO111MODULE 这个环境变量来作为 Go modules 的开关，其允许设置以下参数：</p>
<ul>
<li>auto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。</li>
<li>on：启用 Go modules，推荐设置，将会是未来版本中的默认值。</li>
<li>off：禁用 Go modules，不推荐设置。</li>
</ul>
<h5 id="go111module的小历史">GO111MODULE的小历史</h5>
<p>你可能会留意到 GO111MODULE 这个名字比较“奇特”，实际上在 Go 语言中经常会有这类阶段性的变量， GO111MODULE 这个命名代表着Go语言在 1.11 版本添加的，针对 Module 的变量。</p>
<p>像是在 Go1.5 版本的时候，也发布了一个系统环境变量 GO15VENDOREXPERIMENT，作用是用于开启 vendor 目录的支持，当时其默认值也不是开启，仅仅作为 experimental。其随后在 Go1.6 版本时也将默认值改为了开启，并且最后作为了official，GO15VENDOREXPERIMENT 系统变量就退出了历史舞台。</p>
<p>而未来 GO111MODULE 这一个系统环境变量也会面临这个问题，也会先调整为默认值为 on（曾经在Go1.13想想改为 on，并且已经合并了 PR，但最后因为种种原因改回了 auto），然后再把 GO111MODULE 的支持给去掉，我们猜测应该会在 Go2 将 GO111MODULE 给去掉，因为如果直接去掉 GO111MODULE 的支持，会存在兼容性问题。</p>
<h4 id="goproxy">GOPROXY</h4>
<p>这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。</p>
<p>GOPROXY 的默认值是：<code>https://proxy.golang.org,direct</code>，这有一个很严重的问题，就是 <code>proxy.golang.org</code> 在国内是无法访问的，因此这会直接卡住你的第一步，所以你必须在开启 Go modules 的时，同时设置国内的 Go 模块代理，执行如下命令：</p>
<pre><code>$ go env -w GOPROXY=https://goproxy.cn,direct
</code></pre><p>GOPROXY的值是一个以英文逗号 “,” 分割的 Go 模块代理列表，允许设置多个模块代理，假设你不想使用，也可以将其设置为 “off” ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。</p>
<h5 id="direct是什么">direct是什么</h5>
<p>而在刚刚设置的值中，我们可以发现值列表中有 “direct” 标识，它又有什么作用呢？</p>
<p>实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision&hellip;” 的错误。</p>
<h4 id="gosumdb">GOSUMDB</h4>
<p>它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。</p>
<p>GOSUMDB的默认值为：<code>sum.golang.org</code>，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。</p>
<p>因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 <code>goproxy.cn</code> 就能支持代理 <code>sum.golang.org</code>，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。</p>
<p>另外若对 GOSUMDB 的值有自定义需求，其支持如下格式：</p>
<ul>
<li>格式 1：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt;</code>。</li>
<li>格式 2：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt; &lt;SUMDB_URL&gt;</code>。</li>
</ul>
<p>也可以将其设置为“off”，也就是禁止 Go 在后续操作中校验模块版本。</p>
<h4 id="gonoproxygonosumdbgoprivate">GONOPROXY/GONOSUMDB/GOPRIVATE</h4>
<p>这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。</p>
<p>更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。</p>
<p>而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。</p>
<p>并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：</p>
<pre><code>$ go env -w GOPRIVATE=&quot;git.example.com,github.com/eddycjy/mquote&quot;
</code></pre><p>设置后，前缀为 git.xxx.com 和 github.com/eddycjy/mquote 的模块都会被认为是私有模块。</p>
<p>如果不想每次都重新设置，我们也可以利用通配符，例如：</p>
<pre><code>$ go env -w GOPRIVATE=&quot;*.example.com&quot;
</code></pre><p>这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 example.com 本身。</p>
<h3 id="开启go-modules">开启Go Modules</h3>
<p>目前Go modules并不是默认开启，因此Go语言提供了GO111MODULE这个环境变量来作为Go modules的开关，其允许设置以下参数：</p>
<ul>
<li>auto：只要项目包含了go.mod文件的话启用 Go modules，目前在Go1.11至Go1.14中仍然是默认值。</li>
<li>on：启用 Go modules，推荐设置，将会是未来版本中的默认值。</li>
<li>off：禁用 Go modules，不推荐设置。</li>
</ul>
<p>如果你不确定你当前的值是什么，可以执行<code>go env</code>命令，查看结果：</p>
<pre><code>$ go env
GO111MODULE=&quot;off&quot;
...
</code></pre><p>如果需要对GO111MODULE的值进行变更，推荐通过<code>go env</code>命令进行设置：</p>
<pre><code> $ go env -w GO111MODULE=on
</code></pre><p>但是需要注意的是如果对应的系统环境变量有值了（进行过设置），会出现如下警告信息：<code>warning: go env -w GO111MODULE=... does not override conflicting OS environment variable</code>。</p>
<p>又或是可以通过直接设置系统环境变量（写入对应的.bash_profile文件亦可）来实现这个目的：</p>
<pre><code>$ export GO111MODULE=on
</code></pre><h3 id="初始化项目">初始化项目</h3>
<p>在完成 Go modules 的开启后，我们需要创建一个示例项目来进行演示，执行如下命令：</p>
<pre><code>$ mkdir -p $HOME/eddycjy/module-repo 
$ cd $HOME/eddycjy/module-repo
</code></pre><p>然后进行Go modules的初始化，如下：</p>
<pre><code>$ go mod init github.com/eddycjy/module-repo
go: creating new go.mod: module github.com/eddycjy/module-repo
</code></pre><p>在执行 <code>go mod init</code> 命令时，我们指定了模块导入路径为 <code>github.com/eddycjy/module-repo</code>。接下来我们在该项目根目录下创建 main.go 文件，如下：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;github.com/eddycjy/mquote&quot;
)

func main() {
	fmt.Println(mquote.GetHello())
}
</code></pre><p>然后在项目根目录执行 <code>go get github.com/eddycjy/mquote</code> 命令，如下：</p>
<pre><code>$ go get github.com/eddycjy/mquote 
go: finding github.com/eddycjy/mquote latest
go: downloading github.com/eddycjy/mquote v0.0.0-20200220041913-e066a990ce6f
go: extracting github.com/eddycjy/mquote v0.0.0-20200220041913-e066a990ce6f
</code></pre><h3 id="查看gomod-文件">查看go.mod 文件</h3>
<p>在初始化项目时，会生成一个 go.mod 文件，是启用了 Go modules 项目所必须的最重要的标识，同时也是GO111MODULE 值为 auto 时的识别标识，它描述了当前项目（也就是当前模块）的元信息，每一行都以一个动词开头。</p>
<p>在我们刚刚进行了初始化和简单拉取后，我们再次查看go.mod文件，基本内容如下：</p>
<pre><code>module github.com/eddycjy/module-repo

go 1.13

require (
	github.com/eddycjy/mquote v0.0.0-20200220041913-e066a990ce6f
)
</code></pre><p>为了更进一步的讲解，我们模拟引用如下：</p>
<pre><code>module github.com/eddycjy/module-repo

go 1.13

require (
    example.com/apple v0.1.2
    example.com/banana v1.2.3
    example.com/banana/v2 v2.3.4
    example.com/pear // indirect
    example.com/strawberry // incompatible
)

exclude example.com/banana v1.2.4
replace example.com/apple v0.1.2 =&gt; example.com/fried v0.1.0 
replace example.com/banana =&gt; example.com/fish
</code></pre><ul>
<li>module：用于定义当前项目的模块路径。</li>
<li>go：用于标识当前模块的 Go 语言版本，值为初始化模块时的版本，目前来看还只是个标识作用。</li>
<li>require：用于设置一个特定的模块版本。</li>
<li>exclude：用于从使用中排除一个特定的模块版本。</li>
<li>replace：用于将一个模块版本替换为另外一个模块版本。</li>
</ul>
<p>另外你会发现 <code>example.com/pear</code> 的后面会有一个 indirect 标识，indirect 标识表示该模块为间接依赖，也就是在当前应用程序中的 import 语句中，并没有发现这个模块的明确引用，有可能是你先手动 <code>go get</code> 拉取下来的，也有可能是你所依赖的模块所依赖的，情况有好几种。</p>
<h3 id="查看gosum文件">查看go.sum文件</h3>
<p>在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p>
<pre><code>github.com/eddycjy/mquote v0.0.1 h1:4QHXKo7J8a6J/k8UA6CiHhswJQs0sm2foAQQUq8GFHM=
github.com/eddycjy/mquote v0.0.1/go.mod h1:ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg=
github.com/eddycjy/mquote/module/tour v0.0.1 h1:cc+pgV0LnR8Fhou0zNHughT7IbSnLvfUZ+X3fvshrv8=
github.com/eddycjy/mquote/module/tour v0.0.1/go.mod h1:8uL1FOiQJZ4/1hzqQ5mv4Sm7nJcwYu41F3nZmkiWx5I=
...
</code></pre><p>我们可以看到一个模块路径可能有如下两种：</p>
<pre><code>github.com/eddycjy/mquote v0.0.1 h1:4QHXKo7J8a6J/k8UA6CiHhswJQs0sm2foAQQUq8GFHM=
github.com/eddycjy/mquote v0.0.1/go.mod h1:ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg=
</code></pre><p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。</p>
<p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。</p>
<h3 id="查看全局缓存">查看全局缓存</h3>
<p>我们刚刚成功的将 <code>github.com/eddycjy/mquote</code> 模块拉取了下来，其拉取的结果缓存在  <code>$GOPATH/pkg/mod</code>和 <code>$GOPATH/pkg/sumdb</code> 目录下，而在<code>mod</code>目录下会以 <code>github.com/foo/bar</code> 的格式进行存放，如下：</p>
<pre><code>mod
├── cache
├── github.com
├── golang.org
├── google.golang.org
├── gopkg.in
...
</code></pre><p>需要注意的是同一个模块版本的数据只缓存一份，所有其它模块共享使用。如果你希望清理所有已缓存的模块版本数据，可以执行 <code>go clean -modcache</code> 命令。</p>
<h2 id="go-modules下的go-get行为">Go Modules下的go get行为</h2>
<p>在拉取项目依赖时，你会发现拉取的过程总共分为了三大步，分别是 finding（发现）、downloading（下载）以及 extracting（提取）， 并且在拉取信息上一共分为了三段内容：</p>
<p><img src="https://image.eddycjy.com/a78b16231e7c0164e0acccb7abdd01be.jpg" alt="image"></p>
<p>需要注意的是，所拉取版本的 commit 时间是以UTC时区为准，而并非本地时区，同时我们会发现我们 <code>go get</code> 命令所拉取到的版本是 v0.0.0，这是因为我们是直接执行 <code>go get -u</code> 获取的，并没有指定任何的版本信息，由 Go modules 自行按照内部规则进行选择。</p>
<h3 id="go-get的拉取行为">go get的拉取行为</h3>
<p>刚刚我们用 <code>go get</code> 命令拉取了新的依赖，那么 <code>go get</code> 又提供了哪些功能呢，常用的拉取命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>go get</td>
<td>拉取依赖，会进行指定性拉取（更新），并不会更新所依赖的其它模块。</td>
</tr>
<tr>
<td>go get -u</td>
<td>更新现有的依赖，会强制更新它所依赖的其它全部模块，不包括自身。</td>
</tr>
<tr>
<td>go get -u -t ./&hellip;</td>
<td>更新所有直接依赖和间接依赖的模块版本，包括单元测试中用到的。</td>
</tr>
</tbody>
</table>
<p>那么我想选择具体版本应当如何执行呢，如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>go get golang.org/x/text@latest</td>
<td>拉取最新的版本，若存在tag，则优先使用。</td>
</tr>
<tr>
<td>go get golang.org/x/text@master</td>
<td>拉取 master 分支的最新 commit。</td>
</tr>
<tr>
<td>go get <a href="mailto:golang.org/x/text@v0.3.2">golang.org/x/text@v0.3.2</a></td>
<td>拉取 tag 为 v0.3.2 的 commit。</td>
</tr>
<tr>
<td>go get golang.org/x/text@342b2e</td>
<td>拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2。</td>
</tr>
</tbody>
</table>
<h3 id="go-get的版本选择">go get的版本选择</h3>
<p>我们回顾一下我们拉取的 <code>go get github.com/eddycjy/mquote</code>，其结果是 <code>v0.0.0-20200220041913-e066a990ce6f</code>，对照着上面所提到的 <code>go get</code> 行为来看，你可能还会有一些疑惑，那就是在 <code>go get</code> 没有指定任何版本的情况下，它的版本选择规则是怎么样的，也就是为什么 <code>go get</code> 拉取的是 <code>v0.0.0</code>，它什么时候会拉取正常带版本号的 tags 呢。实际上这需要区分两种情况，如下：</p>
<ol>
<li>所拉取的模块有发布 tags：
<ul>
<li>如果只有单个模块，那么就取主版本号最大的那个tag。</li>
<li>如果有多个模块，则推算相应的模块路径，取主版本号最大的那个tag（子模块的tag的模块路径会有前缀要求）</li>
</ul>
</li>
<li>所拉取的模块没有发布过 tags：
<ul>
<li>默认取主分支最新一次 commit 的 commithash。</li>
</ul>
</li>
</ol>
<h4 id="没有发布过-tags">没有发布过 tags</h4>
<p>那么为什么会拉取的是 <code>v0.0.0</code> 呢，是因为 <code>github.com/eddycjy/mquote</code> 没有发布任何的tag，如下：</p>
<p><img src="https://image.eddycjy.com/25989c9757d0dfba50789a1bb327edab.jpg" alt="image"></p>
<p>因此它默认取的是主分支最新一次 commit 的 commit 时间和 commithash，也就是 <code>20200220041913-e066a990ce6f</code>，属于第二种情况。</p>
<h4 id="有发布-tags">有发布 tags</h4>
<p>在项目有发布 tags 的情况下，还存在着多种模式，也就是只有单个模块和多个模块，我们统一以多个模块来进行展示，因为多个模块的情况下就已经包含了单个模块的使用了，如下图：</p>
<p><img src="https://image.eddycjy.com/5e9cd4d15161f478e797c800e29cf2fd.jpg" alt="image"></p>
<p>在这个项目中，我们一共打了两个tag，分别是：v0.0.1 和 module/tour/v0.0.1。这时候你可能会奇怪，为什么要打 <code>module/tour/v0.0.1</code> 这么“奇怪”的tag，这有什么用意吗？</p>
<p>其实是 Go modules 在同一个项目下多个模块的tag表现方式，其主要目录结构为：</p>
<pre><code>mquote
├── go.mod
├── module
│   └── tour
│       ├── go.mod
│       └── tour.go
└── quote.go
</code></pre><p>可以看到在 <code>mquote</code> 这个项目的根目录有一个 go.mod 文件，而在 <code>module/tour</code> 目录下也有一个 go.mod 文件，其模块导入和版本信息的对应关系如下：</p>
<table>
<thead>
<tr>
<th>tag</th>
<th>模块导入路径</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>v0.0.1</td>
<td>github.com/eddycjy/mquote</td>
<td>mquote 项目的v 0.0.1 版本</td>
</tr>
<tr>
<td>module/tour/v0.01</td>
<td>github.com/eddycjy/mquote/module/tour</td>
<td>mquote 项目下的子模块 module/tour 的 v0.0.1 版本</td>
</tr>
</tbody>
</table>
<h4 id="导入主模块和子模块">导入主模块和子模块</h4>
<p>结合上述内容，拉取主模块的话，还是照旧执行如下命令：</p>
<pre><code>$ go get github.com/eddycjy/mquote@v0.0.1
go: finding github.com/eddycjy/mquote v0.0.1
go: downloading github.com/eddycjy/mquote v0.0.1
go: extracting github.com/eddycjy/mquote v0.0.1
</code></pre><p>如果是想拉取子模块，执行如下命令：</p>
<pre><code>$ go get github.com/eddycjy/mquote/module/tour@v0.0.1
go: finding github.com/eddycjy/mquote/module v0.0.1
go: finding github.com/eddycjy/mquote/module/tour v0.0.1
go: downloading github.com/eddycjy/mquote/module/tour v0.0.1
go: extracting github.com/eddycjy/mquote/module/tour v0.0.1
</code></pre><p>我们将主模块和子模块的拉取进行对比，你会发现子模块的拉取会多出一步，它会先发现 <code>github.com/eddycjy/mquote/module</code>，再继续推算，最终拉取到 <code>module/tour</code>。</p>
<h2 id="go-modules的导入路径说明">Go Modules的导入路径说明</h2>
<h3 id="不同版本的导入路径">不同版本的导入路径</h3>
<p>在前面的模块拉取和引用中，你会发现我们的模块导入路径就是 <code>github.com/eddycjy/mquote</code> 和  <code>github.com/eddycjy/mquote/module/tour</code>，似乎并没有什么特殊的。</p>
<p>其实不然，实际上 Go modules 在主版本号为 v0 和 v1 的情况下省略了版本号，而在主版本号为v2及以上则需要明确指定出主版本号，否则会出现冲突，其tag与模块导入路径的大致对应关系如下：</p>
<table>
<thead>
<tr>
<th>tag</th>
<th>模块导入路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>v0.0.0</td>
<td>github.com/eddycjy/mquote</td>
</tr>
<tr>
<td>v1.0.0</td>
<td>github.com/eddycjy/mquote</td>
</tr>
<tr>
<td>v2.0.0</td>
<td>github.com/eddycjy/mquote/v2</td>
</tr>
<tr>
<td>v3.0.0</td>
<td>github.com/eddycjy/mquote/v3</td>
</tr>
</tbody>
</table>
<p>简单来讲，就是主版本号为 v0 和 v1 时，不需要在模块导入路径包含主版本的信息，而在 v1 版本以后，也就是 v2 起，必须要在模块的导入路径末尾加上主版本号，引用时就需要调整为如下格式：</p>
<pre><code>import (
    &quot;github.com/eddycjy/mquote/v2/example&quot;
)
</code></pre><p>另外忽略主版本号 v0 和 v1 是强制性的（不是可选项），因此每个软件包只有一个明确且规范的导入路径。</p>
<h3 id="为什么忽略v0和v1的主版本号">为什么忽略v0和v1的主版本号</h3>
<ol>
<li>
<p>导入路径中忽略 v1 版本的原因是：考虑到许多开发人员创建一旦到达 v1 版本便永不改变的软件包，这是官方所鼓励的，不认为所有这些开发人员在无意发布 v2 版时都应被迫拥有明确的 v1 版本尾缀，这将导致 v1 版本变成“噪音”且无意义。</p>
</li>
<li>
<p>导入路径中忽略了 v0 版本的原因是：根据语义化版本规范，v0的这些版本完全没有兼容性保证。需要一个显式的 v0 版本的标识对确保兼容性没有多大帮助。</p>
</li>
</ol>
<h2 id="go-modules的语义化版本控制">Go Modules的语义化版本控制</h2>
<p>我们不断地在 Go Modules 的使用中提到版本号，其实质上被称为“语义化版本”，假设我们的版本号是 v1.2.3，如下：</p>
<p><img src="https://image.eddycjy.com/6e556b628df36b1fd3800fb9d91a0d16.jpg" alt="image"></p>
<p>其版本格式为“主版本号.次版本号.修订号”，版本号的递增规则如下：</p>
<ol>
<li>主版本号：当你做了不兼容的 API 修改。</li>
<li>次版本号：当你做了向下兼容的功能性新增。</li>
<li>修订号：当你做了向下兼容的问题修正。</li>
</ol>
<p>假设你是先行版本号或特殊情况，可以将版本信息追加到“主版本号.次版本号.修订号”的后面，作为延伸，如下：</p>
<p><img src="https://image.eddycjy.com/b45438512cbb44015402da1a98190ac0.jpg" alt="image"></p>
<p>至此我们介绍了 Go modules 所支持的两类版本号方式，在我们发布新版本打 tag 的时候，需要注意遵循，否则不遵循语义化版本规则的版本号都是无法进行拉取的。</p>
<h2 id="go-modules的最小版本选择">Go Modules的最小版本选择</h2>
<p>现在我们已经有一个模块，也有发布的 tag，但是一个模块往往依赖着许多其它许许多多的模块，并且不同的模块在依赖时很有可能会出现依赖同一个模块的不同版本，如下图（来自Russ Cox）：</p>
<p><img src="https://image.eddycjy.com/7d509e8945fa31b7986369986c58e6f4.jpg" alt="image"></p>
<p>在上述依赖中，模块 A 依赖了模块 B 和模块 C，而模块 B 依赖了模块 D，模块 C 依赖了模块 D 和 F，模块 D 又依赖了模块 E，而且同模块的不同版本还依赖了对应模块的不同版本。那么这个时候 Go modules 怎么选择版本，选择的是哪一个版本呢？</p>
<p>我们根据 proposal 可得知，Go modules 会把每个模块的依赖版本清单都整理出来，最终得到一个构建清单，如下图（来自Russ Cox）：</p>
<p><img src="https://image.eddycjy.com/2bd0bed89d9300c0aac24c7bc72a6307.jpg" alt="image"></p>
<p>我们看到 rough list 和 final list，两者的区别在于重复引用的模块 D（v1.3、v1.4），其最终清单选用了模块 D 的 v1.4 版本，主要原因：</p>
<ol>
<li>
<p>语义化版本的控制：因为模块 D 的 v1.3 和 v1.4 版本变更，都属于次版本号的变更，而在语义化版本的约束下，v1.4 必须是要向下兼容 v1.3 版本，因此认为不存在破坏性变更，也就是兼容的。</p>
</li>
<li>
<p>模块导入路径的规范：主版本号不同，模块的导入路径不一样，因此若出现不兼容的情况，其主版本号会改变，模块的导入路径自然也就改变了，因此不会与第一点的基础相冲突。</p>
</li>
</ol>
<h2 id="gosum文件要不要提交">go.sum文件要不要提交</h2>
<p>理论上 go.mod 和 go.sum 文件都应该提交到你的 Git 仓库中去。</p>
<p>假设我们不上传 go.sum 文件，就会造成每个人执行 Go modules 相关命令，又会生成新的一份 go.sum，也就是会重新到上游拉取，再拉取时有可能就是被篡改过的了，会有很大的安全隐患，失去了与基准版本（第一个所提交的人，所期望的版本）的校验内容，因此 go.sum文件是需要提交。</p>
<h2 id="总结">总结</h2>
<p>至此我们介绍了 Go modules 的前世今生、基本使用和在 Go modules 模式下 <code>go get</code> 命令的行为转换，同时我们对常见的多版本导入路径、语义化版本控制以及多模块的最小版本选择规则进行了大致的介绍。</p>
<p>Go modules 的成长和发展经历了一定的过程，如果你是刚接触的读者，直接基于 Go modules 的项目开始即可，如果既有老项目，那么是时候考虑切换过来了，Go1.14起已经准备就绪，并推荐你使用。</p>
<h2 id="我的公众号">我的公众号</h2>
<p><img src="https://image.eddycjy.com/25549b3f68cac5e89e92e1943d0babc2.jpeg" alt="image"></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/golang/go/wiki/Modules">wiki/Modules</a></li>
<li><a href="https://github.com/golang/go/wiki/vgo">wiki/vgo</a></li>
<li><a href="https://github.com/golang/go/issues/24301">proposal</a></li>
<li><a href="https://book.eddycjy.com/golang/talk/goproxy-cn.html">干货满满的 Go Modules 和 goproxy.cn</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>干货满满的 Go Modules 和 goproxy.cn</title>
			<link>https://eddycjy.com/posts/go/go-moduels/2019-09-29-goproxy-cn/</link>
			<pubDate>Sun, 29 Sep 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/go-moduels/2019-09-29-goproxy-cn/</guid>
			<description>大家好，我是一只普通的煎鱼，周四晚上很有幸邀请到 goproxy.cn 的作者 @盛傲飞（@aofei） 到 Go 夜读给我们进行第 61 期 《Go Modules、Go Module Proxy 和 goproxy.cn》的技术分享。
本次 @盛傲飞 的夜读分享，是对 Go Modules 的一次很好的解读，比较贴近工程实践，我必然希望把这块的知识更多的分享给大家，因此有了今天本篇文章，同时大家也可以多关注 Go 夜读，每周会通过 zoom 在线直播的方式分享 Go 相关的技术话题，希望对大家有所帮助。
前言 Go 1.11 推出的模块（Modules）为 Go 语言开发者打开了一扇新的大门，理想化的依赖管理解决方案使得 Go 语言朝着计算机编程史上的第一个依赖乌托邦（Deptopia）迈进。随着模块一起推出的还有模块代理协议（Module proxy protocol），通过这个协议我们可以实现 Go 模块代理（Go module proxy），也就是依赖镜像。
Go 1.13 的发布为模块带来了大量的改进，所以模块的扶正就是这次 Go 1.13 发布中开发者能直接感觉到的最大变化。而问题在于，Go 1.13 中的 GOPROXY 环境变量拥有了一个在中国大陆无法访问到的默认值 proxy.golang.org，经过大家在 golang/go#31755 中激烈的讨论（有些人甚至将话提上升到了“自由世界”的层次），最终 Go 核心团队仍然无法为中国开发者提供一个可在中国大陆访问的官方模块代理。
为了今后中国的 Go 语言开发者能更好地进行开发，七牛云推出了非营利性项目 goproxy.cn，其目标是为中国和世界上其他地方的 Gopher 们提供一个免费的、可靠的、持续在线的且经过 CDN 加速的模块代理。可以预见未来是属于模块化的，所以 Go 语言开发者能越早切入模块就能越早进入未来。
如果说 Go 1.11 和 Go 1.</description>
			<content type="html"><![CDATA[<p>大家好，我是一只普通的煎鱼，周四晚上很有幸邀请到 goproxy.cn 的作者 @盛傲飞（@aofei） 到 Go 夜读给我们进行第 61 期 《Go Modules、Go Module Proxy 和 goproxy.cn》的技术分享。</p>
<p>本次 @盛傲飞 的夜读分享，是对 Go Modules 的一次很好的解读，比较贴近工程实践，我必然希望把这块的知识更多的分享给大家，因此有了今天本篇文章，同时大家也可以多关注 Go 夜读，每周会通过 zoom 在线直播的方式分享 Go 相关的技术话题，希望对大家有所帮助。</p>
<h2 id="前言">前言</h2>
<p>Go 1.11 推出的模块（Modules）为 Go 语言开发者打开了一扇新的大门，理想化的依赖管理解决方案使得 Go 语言朝着计算机编程史上的第一个依赖乌托邦（Deptopia）迈进。随着模块一起推出的还有模块代理协议（Module proxy protocol），通过这个协议我们可以实现 Go 模块代理（Go module proxy），也就是依赖镜像。</p>
<p>Go 1.13 的发布为模块带来了大量的改进，所以模块的扶正就是这次 Go 1.13 发布中开发者能直接感觉到的最大变化。而问题在于，Go 1.13 中的 GOPROXY 环境变量拥有了一个在中国大陆无法访问到的默认值 <code>proxy.golang.org</code>，经过大家在 golang/go#31755 中激烈的讨论（有些人甚至将话提上升到了“自由世界”的层次），最终 Go 核心团队仍然无法为中国开发者提供一个可在中国大陆访问的官方模块代理。</p>
<p>为了今后中国的 Go 语言开发者能更好地进行开发，七牛云推出了非营利性项目 <code>goproxy.cn</code>，其目标是为中国和世界上其他地方的 Gopher 们提供一个免费的、可靠的、持续在线的且经过 CDN 加速的模块代理。可以预见未来是属于模块化的，所以 Go 语言开发者能越早切入模块就能越早进入未来。</p>
<p>如果说 Go 1.11 和 Go 1.12 时由于模块的不完善你不愿意切入，那么 Go 1.13 你则可以大胆地开始放心使用。本次分享将讨论如何使用模块和模块代理，以及在它们的使用中会常遇见的坑，还会讲解如何快速搭建自己的私有模块代理，并简单地介绍一下七牛云推出的 <code>goproxy.cn</code> 以及它的出现对于中国 Go 语言开发者来说重要在何处。</p>
<h2 id="目录">目录</h2>
<ul>
<li>Go Modules 简介</li>
<li>快速迁移项目至 Go Modules</li>
<li>使用 Go Modules 时常遇见的坑
<ul>
<li>坑 1:判断项目是否启用了 Go Modules</li>
<li>坑 2:管理 Go 的环境变量</li>
<li>坑 3:从 dep、glide 等迁移至 Go Modules</li>
<li>坑 4:拉取私有模块</li>
<li>坑 5:更新现有的模块</li>
<li>坑 6:主版本号</li>
</ul>
</li>
<li>Go Module Proxy 简介</li>
<li>Goproxy 中国(goproxy.cn)</li>
</ul>
<h2 id="go-modules-简介">Go Modules 简介</h2>
<p><img src="https://image.eddycjy.com/765e3c7525bede127297a66e03cf3506.jpg" alt="image"></p>
<p>Go modules (前身 vgo) 是 Go team (Russ Cox) <strong>强推</strong>的一个<strong>理想化</strong>的<strong>类语言级</strong>依赖管理解决方案，它是和 Go1.11 一同发布的，在 Go1.13 做了大量的优化和调整，目前已经变得比较不错，如果你想用 Go modules，但还停留在 1.11/1.12 版本的话，强烈建议升级。</p>
<h3 id="三个关键字">三个关键字</h3>
<h4 id="强推">强推</h4>
<p>首先这并不是乱说的，因为 Go modules 确实是被强推出来的，如下：</p>
<ul>
<li>之前：大家都知道在 Go modules 之前还有一个叫 dep 的项目，它也是 Go 的一个官方的实验性项目，目的同样也是为了解决 Go 在依赖管理方面的短板。在 Russ Cox 还没有提出 Go modules 的时候，社区里面几乎所有的人都认为 dep 肯定就是未来 Go 官方的依赖管理解决方案了。</li>
<li>后来：谁都没想到半路杀出个程咬金，Russ Cox 义无反顾地推出了 Go modules，这瞬间导致一石激起千层浪，让社区炸了锅。大家一致认为 Go team 实在是太霸道、太独裁了，连个招呼都不打一声。我记得当时有很多人在网上跟 Russ Cox 口水战，各种依赖管理解决方案的专家都冒出来发表意见，讨论范围甚至一度超出了 Go 语言的圈子触及到了其他语言的领域。</li>
</ul>
<h4 id="理想化">理想化</h4>
<p>从他强制要求使用语义化版本控制这一点来说就很理想化了，如下：</p>
<ul>
<li>Go modules 狠到如果你的 Tag 没有遵循语义化版本控制那么它就会忽略你的 Tag，然后根据你的 Commit 时间和哈希值再为你生成一个假定的符合语义化版本控制的版本号。</li>
<li>Go modules 还默认认为，只要你的主版本号不变，那这个模块版本肯定就不包含 Breaking changes，因为语义化版本控制就是这么规定的啊。是不是很理想化。</li>
</ul>
<h4 id="类语言级">类语言级：</h4>
<p>这个关键词其实是我自己瞎编的，我只是单纯地个人认为 Go modules 在设计上就像个语言级特性一样，比如如果你的主版本号发生变更，那么你的代码里的 import path 也得跟着变，它认为主版本号不同的两个模块版本是完全不同的两个模块。此外，Go moduels 在设计上跟 go 整个命令都结合得相当紧密，无处不在，所以我才说它是一个有点儿像语言级的特性，虽然不是太严谨。</p>
<h3 id="推-go-modules-的人是谁">推 Go Modules 的人是谁</h3>
<p>那么在上文中提到的 Russ Cox 何许人也呢，很多人应该都知道他，他是 Go 这个项目目前代码提交量最多的人，甚至是第二名的两倍还要多。</p>
<p>Russ Cox 还是 Go 现在的掌舵人（大家应该知道之前 Go 的掌舵人是 Rob Pike，但是听说由于他本人不喜欢特朗普执政所以离开了美国，然后他岁数也挺大的了，所以也正在逐渐交权，不过现在还是在参与 Go 的发展）。</p>
<p>Russ Cox 的个人能力相当强，看问题的角度也很独特，这也就是为什么他刚一提出 Go modules 的概念就能引起那么大范围的响应。虽然是被强推的，但事实也证明当下的 Go modules 表现得确实很优秀，所以这表明一定程度上的 “独裁” 还是可以接受的，至少可以保证一个项目能更加专一地朝着一个方向发展。</p>
<p>总之，无论如何 Go modules 现在都成了 Go 语言的一个密不可分的组件。</p>
<h3 id="gopath">GOPATH</h3>
<p>Go modules 出现的目的之一就是为了解决 GOPATH 的问题，也就相当于是抛弃 GOPATH 了。</p>
<h3 id="opt-in">Opt-in</h3>
<p>Go modules 还处于 Opt-in 阶段，就是你想用就用，不用就不用，不强制你。但是未来很有可能 Go2 就强制使用了。</p>
<h3 id="module--package">&ldquo;module&rdquo; != &ldquo;package&rdquo;</h3>
<p>有一点需要纠正，就是“模块”和“包”，也就是 “module” 和 “package” 这两个术语并不是等价的，是 “集合” 跟 “元素” 的关系，“模块” 包含 “包”，“包” 属于 “模块”，一个 “模块” 是零个、一个或多个 “包” 的集合。</p>
<h2 id="go-modules-相关属性">Go Modules 相关属性</h2>
<p><img src="https://image.eddycjy.com/6d9f959fbdf96cc4c8a064b08287e7bc.jpg" alt="image"></p>
<h3 id="gomod">go.mod</h3>
<pre><code>module example.com/foobar

go 1.13

require (
    example.com/apple v0.1.2
    example.com/banana v1.2.3
    example.com/banana/v2 v2.3.4
    example.com/pineapple v0.0.0-20190924185754-1b0db40df49a
)

exclude example.com/banana v1.2.4
replace example.com/apple v0.1.2 =&gt; example.com/rda v0.1.0 
replace example.com/banana =&gt; example.com/hugebanana
</code></pre><p>go.mod 是启用了 Go moduels 的项目所必须的最重要的文件，它描述了当前项目（也就是当前模块）的元信息，每一行都以一个动词开头，目前有以下 5 个动词:</p>
<ul>
<li>module：用于定义当前项目的模块路径。</li>
<li>go：用于设置预期的 Go 版本。</li>
<li>require：用于设置一个特定的模块版本。</li>
<li>exclude：用于从使用中排除一个特定的模块版本。</li>
<li>replace：用于将一个模块版本替换为另外一个模块版本。</li>
</ul>
<p>这里的填写格式基本为包引用路径+版本号，另外比较特殊的是 <code>go $version</code>，目前从 Go1.13 的代码里来看，还只是个标识作用，暂时未知未来是否有更大的作用。</p>
<h3 id="gosum">go.sum</h3>
<p>go.sum 是类似于比如 dep 的 Gopkg.lock 的一类文件，它详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p>
<pre><code>example.com/apple v0.1.2 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ= 
example.com/apple v0.1.2/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU= example.com/banana v1.2.3 h1:qHgHjyoNFV7jgucU8QZUuU4gcdhfs8QW1kw68OD2Lag= 
example.com/banana v1.2.3/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU= example.com/banana/v2 v2.3.4 h1:zl/OfRA6nftbBK9qTohYBJ5xvw6C/oNKizR7cZGl3cI= example.com/banana/v2 v2.3.4/go.mod h1:eZbhyaAYD41SGSSsnmcpxVoRiQ/MPUTjUdIIOT9Um7Q= 
...
</code></pre><p>我们可以看到一个模块路径可能有如下两种：</p>
<pre><code>example.com/apple v0.1.2 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ= 
example.com/apple v0.1.2/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
</code></pre><p>前者为 Go modules 打包整个模块包文件 zip 后再进行 hash 值，而后者为针对 go.mod 的 hash 值。他们两者，要不就是同时存在，要不就是只存在 go.mod hash。</p>
<p>那什么情况下会不存在 zip hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 zip hash，就会出现不存在 zip hash，只存在 go.mod hash 的情况。</p>
<h3 id="go111module">GO111MODULE</h3>
<p>这个环境变量主要是 Go modules 的开关，主要有以下参数：</p>
<ul>
<li>
<p>auto：只在项目包含了 go.mod 文件时启用 Go modules，在 Go 1.13 中仍然是默认值，详见
：golang.org/issue/31857。</p>
</li>
<li>
<p>on：无脑启用 Go modules，推荐设置，未来版本中的默认值，让 GOPATH 从此成为历史。</p>
</li>
<li>
<p>off：禁用 Go modules。</p>
</li>
</ul>
<h3 id="goproxy">GOPROXY</h3>
<p>这个环境变量主要是用于设置 Go 模块代理，主要如下：</p>
<ul>
<li>
<p>它的值是一个以英文逗号 “,” 分割的 Go module proxy 列表（稍后讲解）</p>
<ul>
<li>
<p>作用：用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式从镜像站点快速拉取。它拥有一个默认：<code>https://proxy.golang.org,direct</code>，但很可惜 <code>proxy.golang.org</code> 在中国无法访问，故而建议使用 <code>goproxy.cn</code> 作为替代，可以执行语句：<code>go env -w GOPROXY=https://goproxy.cn,direct</code>。</p>
</li>
<li>
<p>设置为 “off” ：禁止 Go 在后续操作中使用任 何 Go module proxy。</p>
</li>
</ul>
</li>
</ul>
<p>刚刚在上面，我们可以发现值列表中有 “direct” ，它又有什么作用呢。其实值列表中的 “direct” 为特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取(比如 GitHub 等)，当值列表中上一个 Go module proxy 返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，遇见 EOF 时终止并抛出类似 “invalid version: unknown revision&hellip;” 的错误。</p>
<h3 id="gosumdb">GOSUMDB</h3>
<p>它的值是一个 Go checksum database，用于使 Go 在拉取模块版本时(无论是从源站拉取还是通过 Go module proxy 拉取)保证拉取到的模块版本数据未经篡改，也可以是“off”即禁止 Go 在后续操作中校验模块版本</p>
<ul>
<li>
<p>格式 1：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt;</code>。</p>
</li>
<li>
<p>格式 2：<code>&lt;SUMDB_NAME&gt;+&lt;PUBLIC_KEY&gt; &lt;SUMDB_URL&gt;</code>。</p>
</li>
<li>
<p>拥有默认值：<code>sum.golang.org</code> (之所以没有按照上面的格式是因为 Go 对默认值做了特殊处理)。</p>
</li>
<li>
<p>可被 Go module proxy 代理 (详见：Proxying a Checksum Database)。</p>
</li>
<li>
<p><code>sum.golang.org</code> 在中国无法访问，故而更加建议将 GOPROXY 设置为 <code>goproxy.cn</code>，因为 <code>goproxy.cn</code> 支持代理 <code>sum.golang.org</code>。</p>
</li>
</ul>
<h3 id="go-checksum-database">Go Checksum Database</h3>
<p>Go checksum database 主要用于保护 Go 不会从任何源头拉到被篡改过的非法 Go 模块版本，其作用（左）和工作机制（右）如下图：</p>
<p><img src="https://image.eddycjy.com/8a74a6aa59f5706c5c25836451538a12.jpg" alt="image"></p>
<p>如果有兴趣的小伙伴可以看看 <a href="https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#proxying-a-checksum-database">Proposal: Secure the Public Go Module Ecosystem</a>，有详细介绍其算法机制，如果想简单一点，查看 <code>go help module-auth</code> 也是一个不错的选择。</p>
<h3 id="gonoproxygonosumdbgoprivate">GONOPROXY/GONOSUMDB/GOPRIVATE</h3>
<p>这三个环境变量都是用在当前项目依赖了私有模块，也就是依赖了由 GOPROXY 指定的 Go module proxy 或由 GOSUMDB 指定 Go checksum database 无法访问到的模块时的场景</p>
<ul>
<li>它们三个的值都是一个以英文逗号 “,” 分割的模块路径前缀，匹配规则同 path.Match。</li>
<li>其中 GOPRIVATE 较为特殊，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是只是用 GOPRIVATE。</li>
</ul>
<p>在使用上来讲，比如 <code>GOPRIVATE=*.corp.example.com</code> 表示所有模块路径以 <code>corp.example.com</code> 的下一级域名 (如 <code>team1.corp.example.com</code>) 为前缀的模块版本都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 <code>corp.example.com</code> 本身。</p>
<h3 id="global-caching">Global Caching</h3>
<p>这个主要是针对 Go modules 的全局缓存数据说明，如下：</p>
<ul>
<li>同一个模块版本的数据只缓存一份，所有其他模块共享使用。</li>
<li>目前所有模块版本数据均缓存在 <code>$GOPATH/pkg/mod</code>和 ​<code>$GOPATH/pkg/sum</code> 下，未来或将移至 <code>$GOCACHE/mod </code>和<code>$GOCACHE/sum</code> 下( 可能会在当 <code>$GOPATH</code> 被淘汰后)。</li>
<li>可以使用 <code>go clean -modcache</code> 清理所有已缓存的模块版本数据。</li>
</ul>
<p>另外在 Go1.11 之后 GOCACHE 已经不允许设置为 off 了，我想着这也是为了模块数据缓存移动位置做准备，因此大家应该尽快做好适配。</p>
<h2 id="快速迁移项目至-go-modules">快速迁移项目至 Go Modules</h2>
<ul>
<li>第一步: 升级到 Go 1.13。</li>
<li>第二步: 让 GOPATH 从你的脑海中完全消失，早一步踏入未来。
<ul>
<li>修改 GOBIN 路径（可选）：<code>go env -w GOBIN=$HOME/bin</code>。</li>
<li>打开 Go modules：<code>go env -w GO111MODULE=on</code>。</li>
<li>设置 GOPROXY：<code>go env -w GOPROXY=https://goproxy.cn,direct</code> # 在中国是必须的，因为它的默认值被墙了。</li>
</ul>
</li>
<li>第三步(可选): 按照你喜欢的目录结构重新组织你的所有项目。</li>
<li>第四步: 在你项目的根目录下执行 <code>go mod init &lt;OPTIONAL_MODULE_PATH&gt;</code> 以生成 go.mod 文件。</li>
<li>第五步: 想办法说服你身边所有的人都去走一下前四步。</li>
</ul>
<h2 id="迁移后-go-get-行为的改变">迁移后 go get 行为的改变</h2>
<ul>
<li>用 <code>go help module-get</code> 和 <code>go help gopath-get</code>分别去了解 Go modules 启用和未启用两种状态下的 go get 的行为</li>
<li>用 <code>go get</code> 拉取新的依赖
<ul>
<li>拉取最新的版本(优先择取 tag)：<code>go get golang.org/x/text@latest</code></li>
<li>拉取 <code>master</code> 分支的最新 commit：<code>go get golang.org/x/text@master</code></li>
<li>拉取 tag 为 v0.3.2 的 commit：<code>go get golang.org/x/text@v0.3.2</code></li>
<li>拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2：<code>go get golang.org/x/text@342b2e</code></li>
<li>用 <code>go get -u</code> 更新现有的依赖</li>
<li>用 <code>go mod download</code> 下载 go.mod 文件中指明的所有依赖</li>
<li>用 <code>go mod tidy</code> 整理现有的依赖</li>
<li>用 <code>go mod graph</code> 查看现有的依赖结构</li>
<li>用 <code>go mod init</code> 生成 go.mod 文件 (Go 1.13 中唯一一个可以生成 go.mod 文件的子命令)</li>
</ul>
</li>
<li>用 <code>go mod edit</code> 编辑 go.mod 文件</li>
<li>用 <code>go mod vendor</code> 导出现有的所有依赖 (事实上 Go modules 正在淡化 Vendor 的概念)</li>
<li>用 <code>go mod verify</code> 校验一个模块是否被篡改过</li>
</ul>
<p>这里我们注意到有两点比较特别，分别是：</p>
<ul>
<li>第一点：为什么 “拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2” 呢。这是因为虽然我们设置了拉取 @342b2e commit，但是因为 Go modules 会与 tag 进行对比，若发现对应的 commit 与 tag 有关联，则进行转换。</li>
<li>第二点：为什么不建议使用 <code>go mod vendor</code>，因为 Go modules 正在淡化 Vendor 的概念，很有可能 Go2 就去掉了。</li>
</ul>
<h2 id="使用-go-modules-时常遇见的坑">使用 Go Modules 时常遇见的坑</h2>
<h3 id="坑-1-判断项目是否启用了-go-modules">坑 1: 判断项目是否启用了 Go Modules</h3>
<p><img src="https://image.eddycjy.com/0dda1c26b7aa3f9e8655c8e366f49116.jpg" alt="image"></p>
<h3 id="坑-2-管理-go-的环境变量">坑 2: 管理 Go 的环境变量</h3>
<p><img src="https://image.eddycjy.com/78a93176b5e24dfde88327aebe63fe9c.jpg" alt="image"></p>
<p>这里主要是提到 Go1.13 新增了 <code>go env -w</code> 用于写入环境变量，而写入的地方是 <code>os.UserConfigDir</code> 所返回的路径，需要注意的是 <code>go env -w</code> 不会覆写。</p>
<h3 id="坑-3-从-depglide-等迁移至-go-modules">坑 3: 从 dep、glide 等迁移至 Go Modules</h3>
<p><img src="https://image.eddycjy.com/67c83f5d4a3d936449a705921fcfe492.jpg" alt="image"></p>
<p>这里主要是指从旧有的依赖包管理工具（dep/glide 等）进行迁移时，因为 BUG 的原因会导致不经过 GOPROXY 的代理，解决方法有如下两个：</p>
<ul>
<li>手动创建一个 go.mod 文件，再执行 go mod tidy 进行补充。</li>
<li>上代理，相当于不使用 GOPROXY 了。</li>
</ul>
<h3 id="坑-4拉取私有模块">坑 4:拉取私有模块</h3>
<p><img src="https://image.eddycjy.com/075bdc3d3552c000981c9d4fdd8d0f3f.jpg" alt="image"></p>
<p>这里主要想涉及两块知识点，如下：</p>
<ul>
<li>GOPROXY 是无权访问到任何人的私有模块的，所以你放心，安全性没问题。</li>
<li>GOPROXY 除了设置模块代理的地址以外，还需要增加 “direct” 特殊标识才可以成功拉取私有库。</li>
</ul>
<h3 id="坑-5更新现有的模块">坑 5:更新现有的模块</h3>
<p><img src="https://image.eddycjy.com/d35e9f465d82a14c53fcca3ff5ebc557.jpg" alt="image"></p>
<h3 id="坑-6主版本号">坑 6:主版本号</h3>
<p><img src="https://image.eddycjy.com/75778deb206803598e48693f6fea60b8.jpg" alt="image"></p>
<h2 id="go-module-proxy-简介">Go Module Proxy 简介</h2>
<p><img src="https://image.eddycjy.com/20cb4e449ab50de36a880e3b22e1e8d8.jpg" alt="image"></p>
<p>在这里再次强调了 Go Module Proxy 的作用（图左），以及其对应的协议交互流程（图右），有兴趣的小伙伴可以认真看一下。</p>
<h2 id="goproxy-中国goproxycn">Goproxy 中国(goproxy.cn)</h2>
<p>在这块主要介绍了  Goproxy 的实践操作以及 goproxy.cn 的一些 Q&amp;A 和 近况，如下：</p>
<h3 id="qa">Q&amp;A</h3>
<p><strong>Q：如果中国 Go 语言社区没有咱们自己家的 Go Module Proxy 会怎么样？</strong></p>
<p>**A：**在 Go 1.13 中 GOPROXY 和 GOSUMDB 这两个环境变量都有了在中国无法 访问的默认值，尽管我在 golang.org/issue/31755 里努力尝 试过，但最终仍然无法为咱们中国的 Go 语言开发者谋得一个完美的解决方案。所以从今以后咱 们中国的所有 Go 语言开发者，只要是 使用了 Go modules 的，那么都必须先修改 GOPROXY 和 GOSUMDB 才能正常使用 Go 做开发，否则可能连一个最简单的程序都跑不起 来(只要它有依 赖第三方模 块)。</p>
<p><strong>Q： 我创建 Goproxy 中国(goproxy.cn)的主要原因？</strong></p>
<p>**A：**其实更早的时候，也就是今年年初我也曾 试图在 golang.org/issue/31020 中请求 Go team 能想办法避免那时的 GOPROXY 即将拥有的默认值可以在中国正常访问，但 Go team 似乎也无能为力，为此我才坚定了创建 goproxy.cn 的信念。既然别人没法儿帮忙，那咱们就 得自己动手，不为别的，就为了让大家以后能够更愉快地使用 Go 语言配合 Go modules 做开发。</p>
<p>最初我先是和七牛云的 许叔(七牛云的 创始人兼 CEO 许式伟)提出了我打算 创建 goproxy.cn 的想法，本是抱着 试试看的目的，但没想 到 许叔几乎是没有超过一分钟的考虑便认可了我的想法并表示愿意一起推 动。那一阵子刚好赶上我在写毕业论文，所以项目开发完后就 一直没和七牛云做交接，一直跑在我的个人服 务器上。直到有一次 goproxy.cn 被攻击了，一下午的功夫 烧了我一百多美元，然后我才 意识到这种项目真不能个人来做。个人来做不靠 谱，万一依赖这个项目的人多了，项目再出什么事儿，那就会给大家􏰁成不必要的损 失。所以我赶紧和七牛云做了交接，把 goproxy.cn 完全交给了七牛云，甚至连域名都过户了去。</p>
<h3 id="近况">近况</h3>
<p><img src="https://image.eddycjy.com/7bf56751651d56edb989f7cfd64c0006.png" alt="image"></p>
<ul>
<li>Goproxy 中国 (goproxy.cn) 是目前中国最可靠的 Go module proxy (真不是在自卖自夸)。</li>
<li>为中国 Go 语言开发者量身打􏰁，支持代理 GOSUMDB 的默认值，经过全球 CDN 加速，高可用，可 应用进公司复杂的开发环境中，亦可用作上游代理。</li>
<li>由中国倍受信赖的云服务提供商七牛云无偿提供基础设施支持的开源的非营利性项目。</li>
<li>目标是为中国乃至全世界的 Go 语言开发者提供一个免 费的、可靠的、持 续在线的且经过 CDN 加􏰀的 Go module proxy。</li>
<li>域名已由七牛云进行了备案 (沪ICP备11037377号-56)。</li>
</ul>
<h3 id="情况">情况</h3>
<p><img src="https://image.eddycjy.com/aa517d9e93aff49762de76f601702eb1.jpg" alt="image"></p>
<p>此处呈现的是存储大小，主要是针对模块包代码，而一般来讲代码并不会有多大，0-10MB，10-50MB 占最大头，也是能够理解，但是大于 100MB 的模块包代码就比较夸张了。</p>
<p><img src="https://image.eddycjy.com/94bbc93b83f87b43b254f5f15ff995e7.jpg" alt="image"></p>
<p>此时主要是展示了一下近期 goproxy.cn 的网络数据情况，我相信未来是会越来越高的，值得期待。</p>
<h2 id="qa-1">Q&amp;A</h2>
<p><strong>Q：如何解决 Go 1.13 在从 GitLab 拉取模块版本时遇到的，Go 错误地按照非期望值的路径寻找目标模块版本结果致使最终目标模块拉取失败的问题？</strong></p>
<p>**A：**GitLab 中配合 goget 而设置的 <code>&lt;meta&gt;</code> 存在些许问题，导致 Go 1.13 错误地识别了模块的具体路径，这是个 Bug，据说在 GitLab 的新版本中已经被修复了，详细内容可以看 <a href="https://github.com/golang/go/issues/34094">https://github.com/golang/go/issues/34094</a> 这个 Issue。然后目前的解决办法的话除了升级 GitLab 的版本外，还可以参考 <a href="https://github.com/developer-learning/night-reading-go/issues/468#issuecomment-535850154">https://github.com/developer-learning/night-reading-go/issues/468#issuecomment-535850154</a> 这条回复。</p>
<p><strong>Q：使用 Go modules 时可以同时依赖同一个模块的不同的两个或者多个小版本（修订版本号不同）吗？</strong></p>
<p>**A：**不可以的，Go modules 只可以同时依赖一个模块的不同的两个或者多个大版本（主版本号不同）。比如可以同时依赖 <a href="mailto:example.com/foobar@v1.2.3">example.com/foobar@v1.2.3</a> 和 <a href="mailto:example.com/foobar/v2@v2.3.4">example.com/foobar/v2@v2.3.4</a>，因为他们的模块路径（module path）不同，Go modules 规定主版本号不是 v0 或者 v1 时，那么主版本号必须显式地出现在模块路径的尾部。但是，同时依赖两个或者多个小版本是不支持的。比如如果模块 A 同时直接依赖了模块 B 和模块 C，且模块 A 直接依赖的是模块 C 的 v1.0.0 版本，然后模块 B 直接依赖的是模块 C 的 v1.0.1 版本，那么最终 Go modules 会为模块 A 选用模块 C 的 v1.0.1 版本而不是模块 A 的 go.mod 文件中指明的 v1.0.0 版本。</p>
<p>这是因为 Go modules 认为只要主版本号不变，那么剩下的都可以直接升级采用最新的。但是如果采用了最新的结果导致项目 Break 掉了，那么 Go modules 就会 Fallback 到上一个老的版本，比如在前面的例子中就会 Fallback 到 v1.0.0 版本。</p>
<p><strong>Q：在 go.sum 文件中的一个模块版本的 Hash 校验数据什么情况下会成对出现，什么情况下只会存在一行？</strong></p>
<p>**A：**通常情况下，在 go.sum 文件中的一个模块版本的 Hash 校验数据会有两行，前一行是该模块的 ZIP 文件的 Hash 校验数据，后一行是该模块的 go.mod 文件的 Hash 校验数据。但是也有些情况下只会出现一行该模块的 go.mod 文件的 Hash 校验数据，而不包含该模块的 ZIP 文件本身的 Hash 校验数据，这个情况发生在 Go modules 判定为你当前这个项目完全用不到该模块，根本也不会下载该模块的 ZIP 文件，所以就没必要对其作出 Hash 校验保证，只需要对该模块的 go.mod 文件作出 Hash 校验保证即可，因为 go.mod 文件是用得着的，在深入挖取项目依赖的时候要用。</p>
<p><strong>Q：能不能更详细地讲解一下 go.mod 文件中的 replace 动词的行为以及用法？</strong></p>
<p>**A：**这个 replace 动词的作用是把一个“模块版本”替换为另外一个“模块版本”，这是“模块版本”和“模块版本（module path）”之间的替换，“=&gt;”标识符前面的内容是待替换的“模块版本”的“模块路径”，后面的内容是要替换的目标“模块版本”的所在地，即路径，这个路径可以是一个本地磁盘的相对路径，也可以是一个本地磁盘的绝对路径，还可以是一个网络路径，但是这个目标路径并不会在今后你的项目代码中作为你“导入路径（import path）”出现，代码里的“导入路径”还是得以你替换成的这个目标“模块版本”的“模块路径”作为前缀。</p>
<p>另外需要注意，Go modules 是不支持在 “导入路径” 里写相对路径的。举个例子，如果项目 A 依赖了模块 B，比如模块 B 的“模块路径”是 example.com/b，然后它在的磁盘路径是 ~/b，在项目 A 里的 go.mod 文件中你有一行 replace example.com/b=&gt;~/b，然后在项目 A 里的代码中的“导入路基”就是 import&quot;example.com/b&rdquo;，而不是 import&quot;~/b&rdquo;，剩下的工作是 Go modules 帮你自动完成了的。</p>
<p>然后就是我在分享中也提到了， exclude 和 replace 这两个动词只作用于当前主模块，也就是当前项目，它所依赖的那些其他模块版本中如果出现了你待替换的那个模块版本的话，Go modules 还是会为你依赖的那个模块版本去拉取你的这个待替换的模块版本。</p>
<p>举个例子，比如项目 A 直接依赖了模块 B 和模块 C，然后模块 B 也直接依赖了模块 C，那么你在项目 A 中的 go.mod 文件里的 replace c=&gt;~/some/path/c 是只会影响项目 A 里写的代码中，而模块 B 所用到的还是你 replace 之前的那个 c，并不是你替换成的 ~/some/path/c 这个。</p>
<h2 id="总结">总结</h2>
<p>在 Go1.13 发布后，接触 Go modules 和 Go module proxy 的人越来越多，经常在各种群看到各种小伙伴在咨询，包括我自己也贡献了好几枚 “坑”，因此我觉得傲飞的这一次 《Go Modules、Go Module Proxy 和 goproxy.cn》的技术分享，非常的有实践意义。如果后续大家还有什么建议或问题，欢迎随时来讨论。</p>
<p>最后，感谢 goproxy.cn 背后的人们（@七牛云 和 @盛傲飞）对中国 Go 语言社区的无私贡献和奉献。</p>
<h2 id="进一步阅读">进一步阅读</h2>
<ul>
<li><a href="https://github.com/developer-learning/night-reading-go/issues/468">night-reading-go/issues/468</a></li>
<li><a href="https://www.bilibili.com/video/av69111199?from=search&amp;seid=14251207475086319821">B站：【Go 夜读】第 61 期 Go Modules、Go Module Proxy 和 goproxy.cn</a></li>
<li><a href="https://www.youtube.com/watch?v=H3LVVwZ9zNY">youtube：【Go 夜读】第 61 期 Go Modules、Go Module Proxy 和 goproxy.cn</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go 应用内存占用太多，让排查？（VSZ篇）</title>
			<link>https://eddycjy.com/posts/go/talk/2019-09-24-why-vsz-large/</link>
			<pubDate>Tue, 24 Sep 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2019-09-24-why-vsz-large/</guid>
			<description>前段时间，某同学说某服务的容器因为超出内存限制，不断地重启，问我们是不是有内存泄露，赶紧排查，然后解决掉，省的出问题。我们大为震惊，赶紧查看监控+报警系统和性能分析，发现应用指标压根就不高，不像有泄露的样子。
那么问题是出在哪里了呢，我们进入某个容器里查看了 top 的系统指标，结果如下：
PID VSZ RSS ... COMMAND 67459 2007m 136m ... ./eddycjy-server 从结果上来看，也没什么大开销的东西，主要就一个 Go 进程，一看，某同学就说 VSZ 那么高，而某云上的容器内存指标居然恰好和 VSZ 的值相接近，因此某同学就怀疑是不是 VSZ 所导致的，觉得存在一定的关联关系。
而从最终的结论上来讲，上述的表述是不全对的，那么在今天，本篇文章将主要围绕 Go 进程的 VSZ 来进行剖析，看看到底它为什么那么 &amp;ldquo;高&amp;rdquo;，而在正式开始分析前，第一节为前置的补充知识，大家可按顺序阅读。
基础知识 什么是 VSZ VSZ 是该进程所能使用的虚拟内存总大小，它包括进程可以访问的所有内存，其中包括了被换出的内存（Swap）、已分配但未使用的内存以及来自共享库的内存。
为什么要虚拟内存 在前面我们有了解到 VSZ 其实就是该进程的虚拟内存总大小，那如果我们想了解 VSZ 的话，那我们得先了解 “为什么要虚拟内存？”。
本质上来讲，在一个系统中的进程是与其他进程共享 CPU 和主存资源的，而在现代的操作系统中，多进程的使用非常的常见，那么如果太多的进程需要太多的内存，那么在没有虚拟内存的情况下，物理内存很可能会不够用，就会导致其中有些任务无法运行，更甚至会出现一些很奇怪的现象，例如 “某一个进程不小心写了另一个进程使用的内存”，就会造成内存破坏，因此虚拟内存是非常重要的一个媒介。
虚拟内存包含了什么 而虚拟内存，又分为内核虚拟内存和进程虚拟内存，每一个进程的虚拟内存都是独立的， 呈现如上图所示。
这里也补充说明一下，在内核虚拟内存中，是包含了内核中的代码和数据结构，而内核虚拟内存中的某些区域会被映射到所有进程共享的物理页面中去，因此你会看到 ”内核虚拟内存“ 中实际上是包含了 ”物理内存“ 的，它们两者存在映射关系。而在应用场景上来讲，每个进程也会去共享内核的代码和全局数据结构，因此就会被映射到所有进程的物理页面中去。
虚拟内存的重要能力 为了更有效地管理内存并且减少出错，现代系统提供了一种对主存的抽象概念，也就是今天的主角，叫做虚拟内存（VM），虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件交互的地方，它为每个进程提供了一个大的、一致的和私有的地址空间，虚拟内存提供了三个重要的能力：
 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 它为每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的地址空间不被其他进程破坏。  小结 上面发散的可能比较多，简单来讲，对于本文我们重点关注这些知识点，如下：
 虚拟内存它是有各式各样内存交互的地方，它包含的不仅仅是 &amp;ldquo;自己&amp;rdquo;，而在本文中，我们只需要关注 VSZ，也就是进程虚拟内存，它包含了你的代码、数据、堆、栈段和共享库。 虚拟内存作为内存保护的工具，能够保证进程之间的内存空间独立，不受其他进程的影响，因此每一个进程的 VSZ 大小都不一样，互不影响。 虚拟内存的存在，系统给各进程分配的内存之和是可以大于实际可用的物理内存的，因此你也会发现你进程的物理内存总是比虚拟内存低的多的多。  排查问题 在了解了基础知识后，我们正式开始排查问题，第一步我们先编写一个测试程序，看看没有什么业务逻辑的 Go 程序，它初始的 VSZ 是怎么样的。</description>
			<content type="html"><![CDATA[<p>前段时间，某同学说某服务的容器因为超出内存限制，不断地重启，问我们是不是有内存泄露，赶紧排查，然后解决掉，省的出问题。我们大为震惊，赶紧查看监控+报警系统和性能分析，发现应用指标压根就不高，不像有泄露的样子。</p>
<p>那么问题是出在哪里了呢，我们进入某个容器里查看了 <code>top</code> 的系统指标，结果如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">PID       VSZ    RSS   ... COMMAND
<span class="m">67459</span>     2007m  136m  ... ./eddycjy-server
</code></pre></div><p>从结果上来看，也没什么大开销的东西，主要就一个 Go 进程，一看，某同学就说 VSZ 那么高，而某云上的容器内存指标居然恰好和 VSZ 的值相接近，因此某同学就怀疑是不是 VSZ 所导致的，觉得存在一定的关联关系。</p>
<p>而从最终的结论上来讲，上述的表述是不全对的，那么在今天，本篇文章将<strong>主要围绕 Go 进程的 VSZ 来进行剖析</strong>，看看到底它为什么那么 &ldquo;高&rdquo;，而在正式开始分析前，第一节为前置的补充知识，大家可按顺序阅读。</p>
<h2 id="基础知识">基础知识</h2>
<h3 id="什么是-vsz">什么是 VSZ</h3>
<p>VSZ 是该进程所能使用的虚拟内存总大小，它包括进程可以访问的所有内存，其中包括了被换出的内存（Swap）、已分配但未使用的内存以及来自共享库的内存。</p>
<h3 id="为什么要虚拟内存">为什么要虚拟内存</h3>
<p>在前面我们有了解到 VSZ 其实就是该进程的虚拟内存总大小，那<strong>如果我们想了解 VSZ 的话，那我们得先了解 “为什么要虚拟内存？”</strong>。</p>
<p>本质上来讲，在一个系统中的进程是与其他进程共享 CPU 和主存资源的，而在现代的操作系统中，多进程的使用非常的常见，那么如果太多的进程需要太多的内存，那么在没有虚拟内存的情况下，物理内存很可能会不够用，就会导致其中有些任务无法运行，更甚至会出现一些很奇怪的现象，例如 “某一个进程不小心写了另一个进程使用的内存”，就会造成内存破坏，因此虚拟内存是非常重要的一个媒介。</p>
<h3 id="虚拟内存包含了什么">虚拟内存包含了什么</h3>
<p><img src="https://image.eddycjy.com/3062dec8cd187490adadbdbcf50c17d4.jpg" alt="image"></p>
<p>而虚拟内存，又分为内核虚拟内存和进程虚拟内存，每一个进程的虚拟内存都是独立的， 呈现如上图所示。</p>
<p>这里也补充说明一下，在内核虚拟内存中，是包含了内核中的代码和数据结构，而内核虚拟内存中的某些区域会被映射到所有进程共享的物理页面中去，因此你会看到 ”内核虚拟内存“ 中实际上是包含了 ”物理内存“ 的，它们两者存在映射关系。而在应用场景上来讲，每个进程也会去共享内核的代码和全局数据结构，因此就会被映射到所有进程的物理页面中去。</p>
<p><img src="https://image.eddycjy.com/3ba1352075ace855104f4bd57752a2ad.jpg" alt="image"></p>
<h3 id="虚拟内存的重要能力">虚拟内存的重要能力</h3>
<p>为了更有效地管理内存并且减少出错，现代系统提供了一种对主存的抽象概念，也就是今天的主角，叫做虚拟内存（VM），虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件交互的地方，它为每个进程提供了一个大的、一致的和私有的地址空间，虚拟内存提供了三个重要的能力：</p>
<ol>
<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。</li>
<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li>
<li>它保护了每个进程的地址空间不被其他进程破坏。</li>
</ol>
<h3 id="小结">小结</h3>
<p>上面发散的可能比较多，简单来讲，对于本文我们重点关注这些知识点，如下：</p>
<ul>
<li>虚拟内存它是有各式各样内存交互的地方，它包含的不仅仅是 &ldquo;自己&rdquo;，<strong>而在本文中，我们只需要关注 VSZ，也就是进程虚拟内存，它包含了你的代码、数据、堆、栈段和共享库</strong>。</li>
<li>虚拟内存作为内存保护的工具，能够保证进程之间的内存空间独立，不受其他进程的影响，因此每一个进程的 VSZ 大小都不一样，互不影响。</li>
<li>虚拟内存的存在，系统给各进程分配的内存之和是可以大于实际可用的物理内存的，因此你也会发现你进程的物理内存总是比虚拟内存低的多的多。</li>
</ul>
<h2 id="排查问题">排查问题</h2>
<p>在了解了基础知识后，我们正式开始排查问题，第一步我们先编写一个测试程序，看看没有什么业务逻辑的 Go 程序，它初始的 VSZ 是怎么样的。</p>
<h3 id="测试">测试</h3>
<p>应用代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/ping&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
			<span class="s">&#34;message&#34;</span><span class="p">:</span> <span class="s">&#34;pong&#34;</span><span class="p">,</span>
		<span class="p">})</span>
	<span class="p">})</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8001&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>查看进程情况：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ ps aux <span class="m">67459</span>
USER      PID  %CPU %MEM      VSZ    RSS   ...
eddycjy <span class="m">67459</span>   0.0  0.0  <span class="m">4297048</span>    <span class="m">960</span>   ...
</code></pre></div><p>从结果上来看，VSZ 为 4297048K，也就是 4G 左右，咋一眼看过去还是挺吓人的，明明没有什么业务逻辑，但是为什么那么高呢，真是令人感到好奇。</p>
<h3 id="确认有没有泄露">确认有没有泄露</h3>
<p>在未知的情况下，我们可以首先看下 <code>runtime.MemStats</code> 和 <code>pprof</code>，确定应用到底有没有泄露。不过我们这块是演示程序，什么业务逻辑都没有，因此可以确定和应用没有直接关系。</p>
<pre><code># runtime.MemStats
# Alloc = 1298568
# TotalAlloc = 1298568
# Sys = 71893240
# Lookups = 0
# Mallocs = 10013
# Frees = 834
# HeapAlloc = 1298568
# HeapSys = 66551808
# HeapIdle = 64012288
# HeapInuse = 2539520
# HeapReleased = 64012288
# HeapObjects = 9179
...
</code></pre><h3 id="go-faq">Go FAQ</h3>
<p>接着我第一反应是去翻了 Go FAQ（因为看到过，有印象），其问题为 &ldquo;Why does my Go process use so much virtual memory?&quot;，回答如下：</p>
<blockquote>
<p>The Go memory allocator reserves a large region of virtual memory as an arena for allocations. This virtual memory is local to the specific Go process; the reservation does not deprive other processes of memory.</p>
<p>To find the amount of actual memory allocated to a Go process, use the Unix top command and consult the RES (Linux) or RSIZE (macOS) columns.</p>
</blockquote>
<p>这个 FAQ 是在 2012 年 10 月 <a href="https://github.com/golang/go/commit/2100947d4a25dcf875be1941d0e3a409ea85051e">提交</a> 的，这么多年了也没有更进一步的说明，再翻了 issues 和 forum，一些关闭掉的 issue 都指向了 FAQ，这显然无法满足我的求知欲，因此我继续往下探索，看看里面到底都摆了些什么。</p>
<h3 id="查看内存映射">查看内存映射</h3>
<p>在上图中，我们有提到进程虚拟内存，主要包含了你的代码、数据、堆、栈段和共享库，那初步怀疑是不是进程做了什么内存映射，导致了大量的内存空间被保留呢，为了确定这一点，我们通过如下命令去排查：</p>
<div class="highlight"><pre class="chroma"><code class="language-powershell" data-lang="powershell"><span class="p">$</span> <span class="n">vmmap</span> <span class="p">-</span><span class="n">-wide</span> <span class="n">67459</span>
<span class="p">...</span>
<span class="p">====</span> <span class="n">Non-writable</span> <span class="n">regions</span> <span class="k">for</span> <span class="k">process</span> <span class="n">67459</span>
<span class="n">REGION</span> <span class="nb">TYPE </span>                     <span class="nb">START </span><span class="p">-</span> <span class="k">END</span>             <span class="p">[</span> <span class="n">VSIZE</span>  <span class="n">RSDNT</span>  <span class="n">DIRTY</span>   <span class="n">SWAP</span><span class="p">]</span> <span class="n">PRT</span><span class="p">/</span><span class="n">MAX</span> <span class="n">SHRMOD</span> <span class="n">PURGE</span>    <span class="n">REGION</span> <span class="n">DETAIL</span>
<span class="n">__TEXT</span>                 <span class="n">00000001065ff000</span><span class="p">-</span><span class="n">000000010667b000</span> <span class="p">[</span>  <span class="n">496K</span>   <span class="n">492K</span>     <span class="n">0K</span>     <span class="n">0K</span><span class="p">]</span> <span class="n">r-x</span><span class="p">/</span><span class="n">rwx</span> <span class="n">SM</span><span class="p">=</span><span class="n">COW</span>          <span class="p">/</span><span class="n">bin</span><span class="p">/</span><span class="n">zsh</span>
<span class="n">__LINKEDIT</span>             <span class="n">0000000106687000</span><span class="p">-</span><span class="n">0000000106699000</span> <span class="p">[</span>   <span class="n">72K</span>    <span class="n">44K</span>     <span class="n">0K</span>     <span class="n">0K</span><span class="p">]</span> <span class="n">r</span><span class="p">--/</span><span class="n">rwx</span> <span class="n">SM</span><span class="p">=</span><span class="n">COW</span>          <span class="p">/</span><span class="n">bin</span><span class="p">/</span><span class="n">zsh</span>
<span class="n">MALLOC</span> <span class="n">metadata</span>        <span class="n">000000010669b000</span><span class="p">-</span><span class="n">000000010669c000</span> <span class="p">[</span>    <span class="n">4K</span>     <span class="n">4K</span>     <span class="n">4K</span>     <span class="n">0K</span><span class="p">]</span> <span class="n">r</span><span class="p">--/</span><span class="n">rwx</span> <span class="n">SM</span><span class="p">=</span><span class="n">COW</span>          <span class="n">DefaultMallocZone_0x10669b000</span> <span class="n">zone</span> <span class="n">structure</span>
<span class="p">...</span>
<span class="n">__TEXT</span>                 <span class="n">00007fff76c31000</span><span class="p">-</span><span class="n">00007fff76c5f000</span> <span class="p">[</span>  <span class="n">184K</span>   <span class="n">168K</span>     <span class="n">0K</span>     <span class="n">0K</span><span class="p">]</span> <span class="n">r-x</span><span class="p">/</span><span class="n">r-x</span> <span class="n">SM</span><span class="p">=</span><span class="n">COW</span>          <span class="p">/</span><span class="n">usr</span><span class="p">/</span><span class="n">lib</span><span class="p">/</span><span class="n">system</span><span class="p">/</span><span class="n">libxpc</span><span class="p">.</span><span class="n">dylib</span>
<span class="n">__LINKEDIT</span>             <span class="n">00007fffe7232000</span><span class="p">-</span><span class="n">00007ffff32cb000</span> <span class="p">[</span><span class="n">192</span><span class="p">.</span><span class="n">6M</span>  <span class="n">17</span><span class="p">.</span><span class="n">4M</span>     <span class="n">0K</span>     <span class="n">0K</span><span class="p">]</span> <span class="n">r</span><span class="p">--/</span><span class="n">r</span><span class="p">--</span> <span class="n">SM</span><span class="p">=</span><span class="n">COW</span>          <span class="n">dyld</span> <span class="n">shared</span> <span class="n">cache</span> <span class="n">combined</span> <span class="n">__LINKEDIT</span>
<span class="p">...</span>        

<span class="p">====</span> <span class="n">Writable</span> <span class="n">regions</span> <span class="k">for</span> <span class="k">process</span> <span class="n">67459</span>
<span class="n">REGION</span> <span class="nb">TYPE </span>                     <span class="nb">START </span><span class="p">-</span> <span class="k">END</span>             <span class="p">[</span> <span class="n">VSIZE</span>  <span class="n">RSDNT</span>  <span class="n">DIRTY</span>   <span class="n">SWAP</span><span class="p">]</span> <span class="n">PRT</span><span class="p">/</span><span class="n">MAX</span> <span class="n">SHRMOD</span> <span class="n">PURGE</span>    <span class="n">REGION</span> <span class="n">DETAIL</span>
<span class="n">__DATA</span>                 <span class="n">000000010667b000</span><span class="p">-</span><span class="n">0000000106682000</span> <span class="p">[</span>   <span class="n">28K</span>    <span class="n">28K</span>    <span class="n">28K</span>     <span class="n">0K</span><span class="p">]</span> <span class="n">rw</span><span class="p">-/</span><span class="n">rwx</span> <span class="n">SM</span><span class="p">=</span><span class="n">COW</span>          <span class="p">/</span><span class="n">bin</span><span class="p">/</span><span class="n">zsh</span>
<span class="p">...</span>   
<span class="n">__DATA</span>                 <span class="n">0000000106716000</span><span class="p">-</span><span class="n">000000010671e000</span> <span class="p">[</span>   <span class="n">32K</span>    <span class="n">28K</span>    <span class="n">28K</span>     <span class="n">4K</span><span class="p">]</span> <span class="n">rw</span><span class="p">-/</span><span class="n">rwx</span> <span class="n">SM</span><span class="p">=</span><span class="n">COW</span>          <span class="p">/</span><span class="n">usr</span><span class="p">/</span><span class="n">lib</span><span class="p">/</span><span class="n">zsh</span><span class="p">/</span><span class="n">5</span><span class="p">.</span><span class="n">3</span><span class="p">/</span><span class="n">zsh</span><span class="p">/</span><span class="n">zle</span><span class="p">.</span><span class="n">so</span>
<span class="n">__DATA</span>                 <span class="n">000000010671e000</span><span class="p">-</span><span class="n">000000010671f000</span> <span class="p">[</span>    <span class="n">4K</span>     <span class="n">4K</span>     <span class="n">4K</span>     <span class="n">0K</span><span class="p">]</span> <span class="n">rw</span><span class="p">-/</span><span class="n">rwx</span> <span class="n">SM</span><span class="p">=</span><span class="n">COW</span>          <span class="p">/</span><span class="n">usr</span><span class="p">/</span><span class="n">lib</span><span class="p">/</span><span class="n">zsh</span><span class="p">/</span><span class="n">5</span><span class="p">.</span><span class="n">3</span><span class="p">/</span><span class="n">zsh</span><span class="p">/</span><span class="n">zle</span><span class="p">.</span><span class="n">so</span>
<span class="n">__DATA</span>                 <span class="n">0000000106745000</span><span class="p">-</span><span class="n">0000000106747000</span> <span class="p">[</span>    <span class="n">8K</span>     <span class="n">8K</span>     <span class="n">8K</span>     <span class="n">0K</span><span class="p">]</span> <span class="n">rw</span><span class="p">-/</span><span class="n">rwx</span> <span class="n">SM</span><span class="p">=</span><span class="n">COW</span>          <span class="p">/</span><span class="n">usr</span><span class="p">/</span><span class="n">lib</span><span class="p">/</span><span class="n">zsh</span><span class="p">/</span><span class="n">5</span><span class="p">.</span><span class="n">3</span><span class="p">/</span><span class="n">zsh</span><span class="p">/</span><span class="n">complete</span><span class="p">.</span><span class="n">so</span>
<span class="n">__DATA</span>                 <span class="n">000000010675a000</span><span class="p">-</span><span class="n">000000010675b000</span> <span class="p">[</span>    <span class="n">4K</span>     <span class="n">4K</span>     <span class="n">4K</span>     <span class="n">0K</span><span class="p">]</span> <span class="n">rw</span><span class="p">-</span>
<span class="p">...</span>
</code></pre></div><p>这块主要是利用 macOS 的 <code>vmmap</code> 命令去查看内存映射情况，这样就可以知道这个进程的内存映射情况，从输出分析来看，<strong>这些关联共享库占用的空间并不大，导致 VSZ 过高的根本原因不在共享库和二进制文件上，但是并没有发现大量保留内存空间的行为，这是一个问题点</strong>。</p>
<p>注：若是 Linux 系统，可使用 <code>cat /proc/PID/maps</code> 或 <code>cat /proc/PID/smaps</code> 查看。</p>
<h3 id="查看系统调用">查看系统调用</h3>
<p>既然在内存映射中，我们没有明确的看到保留内存空间的行为，那我们接下来看看该进程的系统调用，确定一下它是否存在内存操作的行为，如下：</p>
<pre><code>$ sudo dtruss -a ./awesomeProject
...
 4374/0x206a2:     15620       6      3 mprotect(0x1BC4000, 0x1000, 0x0)		 = 0 0
...
 4374/0x206a2:     15781       9      4 sysctl([CTL_HW, 3, 0, 0, 0, 0] (2), 0x7FFEEFBFFA64, 0x7FFEEFBFFA68, 0x0, 0x0)		 = 0 0
 4374/0x206a2:     15783       3      1 sysctl([CTL_HW, 7, 0, 0, 0, 0] (2), 0x7FFEEFBFFA64, 0x7FFEEFBFFA68, 0x0, 0x0)		 = 0 0
 4374/0x206a2:     15899       7      2 mmap(0x0, 0x40000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)		 = 0x4000000 0
 4374/0x206a2:     15930       3      1 mmap(0xC000000000, 0x4000000, 0x0, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)		 = 0xC000000000 0
 4374/0x206a2:     15934       4      2 mmap(0xC000000000, 0x4000000, 0x3, 0x1012, 0xFFFFFFFFFFFFFFFF, 0x0)		 = 0xC000000000 0
 4374/0x206a2:     15936       2      0 mmap(0x0, 0x2000000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)		 = 0x59B7000 0
 4374/0x206a2:     15942       2      0 mmap(0x0, 0x210800, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)		 = 0x4040000 0
 4374/0x206a2:     15947       2      0 mmap(0x0, 0x10000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)		 = 0x1BD0000 0
 4374/0x206a2:     15993       3      0 madvise(0xC000000000, 0x2000, 0x8)		 = 0 0
 4374/0x206a2:     16004       2      0 mmap(0x0, 0x10000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)		 = 0x1BE0000 0
...
</code></pre><p>在这小节中，我们通过 macOS 的 <code>dtruss</code> 命令监听并查看了运行这个程序所进行的所有系统调用，发现了与内存管理有一定关系的方法如下：</p>
<ul>
<li>mmap：创建一个新的虚拟内存区域，但这里需要注意，<strong>就是当系统调用 mmap 时，它只是从虚拟内存中申请了一段空间出来，并不会去分配和映射真实的物理内存，而当你访问这段空间的时候，才会在当前时间真正的去分配物理内存</strong>。那么对应到我们实际应用的进程中，那就是 VSZ 的增长后，而该内存空间又未正式使用的话，物理内存是不会有增长的。</li>
<li>madvise：提供有关使用内存的建议，例如：MADV_NORMAL、MADV_RANDOM、MADV_SEQUENTIAL、MADV_WILLNEED、MADV_DONTNEED 等等。</li>
<li>mprotect：设置内存区域的保护情况，例如：PROT_NONE、PROT_READ、PROT_WRITE、PROT_EXEC、PROT_SEM、PROT_SAO、PROT_GROWSUP、PROT_GROWSDOWN 等等。</li>
<li>sysctl：在内核运行时动态地修改内核的运行参数。</li>
</ul>
<p>在此比较可疑的是 <code>mmap</code> 方法，它在 <code>dtruss</code> 的最终统计中一共调用了 10 余次，我们可以相信它在 Go Runtime 的时候进行了大量的虚拟内存申请，我们再接着往下看，看看到底是在什么阶段进行了虚拟内存空间的申请。</p>
<p>注：若是 Linux 系统，可使用 <code>strace</code> 命令。</p>
<h3 id="查看-go-runtime">查看 Go Runtime</h3>
<h4 id="启动流程">启动流程</h4>
<p>通过上述的分析，我们可以知道在 Go 程序启动的时候 VSZ 就已经不低了，并且确定不是共享库等的原因，且程序在启动时系统调用确实存在 <code>mmap</code> 等方法的调用，那么我们可以充分怀疑 Go 在初始化阶段就保留了该内存空间。那我们第一步要做的就是查看一下 Go 的引导启动流程，看看是在哪里申请的，引导过程如下：</p>
<pre><code>graph TD
A(rt0_darwin_amd64.s:8&lt;br/&gt;_rt0_amd64_darwin) --&gt;|JMP| B(asm_amd64.s:15&lt;br/&gt;_rt0_amd64)
B --&gt; |JMP|C(asm_amd64.s:87&lt;br/&gt;runtime-rt0_go)
C --&gt; D(runtime1.go:60&lt;br/&gt;runtime-args)
D --&gt; E(os_darwin.go:50&lt;br/&gt;runtime-osinit)
E --&gt; F(proc.go:472&lt;br/&gt;runtime-schedinit)
F --&gt; G(proc.go:3236&lt;br/&gt;runtime-newproc)
G --&gt; H(proc.go:1170&lt;br/&gt;runtime-mstart)
H --&gt; I(在新创建的 p 和 m 上运行 runtime-main)
</code></pre><ul>
<li>runtime-osinit：获取 CPU 核心数。</li>
<li>runtime-schedinit：初始化程序运行环境（包括栈、内存分配器、垃圾回收、P等）。</li>
<li>runtime-newproc：创建一个新的 G 和 绑定 runtime.main。</li>
<li>runtime-mstart：启动线程 M。</li>
</ul>
<p>注：来自@曹大的 《Go 程序的启动流程》和@全成的 《Go 程序是怎样跑起来的》，推荐大家阅读。</p>
<h4 id="初始化运行环境">初始化运行环境</h4>
<p>显然，我们要研究的是 runtime 里的 <code>schedinit</code> 方法，如下：</p>
<pre><code>func schedinit() {
	...
	stackinit()
	mallocinit()
	mcommoninit(_g_.m)
	cpuinit()       // must run before alginit
	alginit()       // maps must not be used before this call
	modulesinit()   // provides activeModules
	typelinksinit() // uses maps, activeModules
	itabsinit()     // uses activeModules

	msigsave(_g_.m)
	initSigmask = _g_.m.sigmask

	goargs()
	goenvs()
	parsedebugvars()
	gcinit()
  ...
}
</code></pre><p>从用途来看，非常明显， <code>mallocinit</code> 方法会进行内存分配器的初始化，我们继续往下看。</p>
<h4 id="初始化内存分配器">初始化内存分配器</h4>
<h5 id="mallocinit">mallocinit</h5>
<p>接下来我们正式的分析一下 <code>mallocinit</code> 方法，在引导流程中， <code>mallocinit</code> 主要承担 Go 程序的内存分配器的初始化动作，而今天主要是针对虚拟内存地址这块进行拆解，如下：</p>
<pre><code>func mallocinit() {
	...
	if sys.PtrSize == 8 {
		for i := 0x7f; i &gt;= 0; i-- {
			var p uintptr
			switch {
			case GOARCH == &quot;arm64&quot; &amp;&amp; GOOS == &quot;darwin&quot;:
				p = uintptr(i)&lt;&lt;40 | uintptrMask&amp;(0x0013&lt;&lt;28)
			case GOARCH == &quot;arm64&quot;:
				p = uintptr(i)&lt;&lt;40 | uintptrMask&amp;(0x0040&lt;&lt;32)
			case GOOS == &quot;aix&quot;:
				if i == 0 {
					continue
				}
				p = uintptr(i)&lt;&lt;40 | uintptrMask&amp;(0xa0&lt;&lt;52)
			case raceenabled:
				...
			default:
				p = uintptr(i)&lt;&lt;40 | uintptrMask&amp;(0x00c0&lt;&lt;32)
			}
			hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())
			hint.addr = p
			hint.next, mheap_.arenaHints = mheap_.arenaHints, hint
		}
	} else {
      ...
	}
}
</code></pre><ul>
<li>判断当前是 64 位还是 32 位的系统。</li>
<li>从 0x7fc000000000~0x1c000000000 开始设置保留地址。</li>
<li>判断当前 <code>GOARCH</code>、<code>GOOS</code> 或是否开启了竞态检查，根据不同的情况申请不同大小的连续内存地址，而这里的 <code>p</code> 是即将要要申请的连续内存地址的开始地址。</li>
<li>保存刚刚计算的 arena 的信息到 <code>arenaHint</code> 中。</li>
</ul>
<p>可能会有小伙伴问，为什么要判断是 32 位还是 64 位的系统，这是因为不同位数的虚拟内存的寻址范围是不同的，因此要进行区分，否则会出现高位的虚拟内存映射问题。而在申请保留空间时，我们会经常提到 <code>arenaHint</code> 结构体，它是 <code>arenaHints </code>链表里的一个节点，结构如下：</p>
<pre><code>type arenaHint struct {
	addr uintptr
	down bool
	next *arenaHint
}
</code></pre><ul>
<li>addr：<code>arena</code> 的起始地址</li>
<li>down：是否最后一个 <code>arena</code></li>
<li>next：下一个 <code>arenaHint</code> 的指针地址</li>
</ul>
<p>那么这里疯狂提到的 <code>arena</code> 又是什么东西呢，这其实是 Go 的内存管理中的概念，Go Runtime 会把申请的虚拟内存分为三个大块，如下：</p>
<p><img src="https://image.eddycjy.com/c415cfea1db7a60b33d99084f9f32ad1.jpg" alt="image"></p>
<ul>
<li>spans：记录 arena 区域页号和 mspan 的映射关系。</li>
<li>bitmap：标识 arena 的使用情况，在功能上来讲，会用于标识 arena 的哪些空间地址已经保存了对象。</li>
<li>arean：arean 其实就是 Go 的堆区，是由 mheap 进行管理的，它的 MaxMem 是 512GB-1。而在功能上来讲，Go 会在初始化的时候申请一段连续的虚拟内存空间地址到 arean 保留下来，在真正需要申请堆上的空间时再从 arean 中取出来处理，这时候就会转变为物理内存了。</li>
</ul>
<p>在这里的话，你需要理解 arean 区域在 Go 内存里的作用就可以了。</p>
<h5 id="mmap">mmap</h5>
<p>我们刚刚通过上述的分析，已经知道 <code>mallocinit</code> 的用途了，但是你可能还是会有疑惑，就是我们之前所看到的 <code>mmap</code> 系统调用，和它又有什么关系呢，怎么就关联到一起了，接下来我们先一起来看看更下层的代码，如下：</p>
<pre><code>func sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer {
	p, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
	...
	mSysStatInc(sysStat, n)
	return p
}

func sysReserve(v unsafe.Pointer, n uintptr) unsafe.Pointer {
	p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
	...
}

func sysMap(v unsafe.Pointer, n uintptr, sysStat *uint64) {
	...
	munmap(v, n)
	p, err := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, -1, 0)
  ...
}
</code></pre><p>在 Go Runtime 中存在着一系列的系统级内存调用方法，本文涉及的主要如下：</p>
<ul>
<li>sysAlloc：从 OS 系统上申请清零后的内存空间，调用参数是 <code>_PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE</code>，得到的结果需进行内存对齐。</li>
<li>sysReserve：从 OS 系统中保留内存的地址空间，这时候还没有分配物理内存，调用参数是 <code>_PROT_NONE, _MAP_ANON|_MAP_PRIVATE</code>，得到的结果需进行内存对齐。</li>
<li>sysMap：通知 OS 系统我们要使用已经保留了的内存空间，调用参数是 <code>_PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE</code>。</li>
</ul>
<p>看上去好像很有道理的样子，但是 <code>mallocinit</code> 方法在初始化时，到底是在哪里涉及了 <code>mmap</code> 方法呢，表面看不出来，如下：</p>
<pre><code>for i := 0x7f; i &gt;= 0; i-- {
	...
	hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())
	hint.addr = p
	hint.next, mheap_.arenaHints = mheap_.arenaHints, hint
}
</code></pre><p>实际上在调用 <code>mheap_.arenaHintAlloc.alloc()</code> 时，调用的是 <code>mheap</code>  下的 <code>sysAlloc</code> 方法，而 <code>sysAlloc</code> 又会与 <code>mmap</code> 方法产生调用关系，并且这个方法与常规的 <code>sysAlloc</code> 还不大一样，如下：</p>
<pre><code>var mheap_ mheap
...
func (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr) {
	...
	for h.arenaHints != nil {
		hint := h.arenaHints
		p := hint.addr
		if hint.down {
			p -= n
		}
		if p+n &lt; p {
			v = nil
		} else if arenaIndex(p+n-1) &gt;= 1&lt;&lt;arenaBits {
			v = nil
		} else {
			v = sysReserve(unsafe.Pointer(p), n)
		}
		...
}
</code></pre><p>你可以惊喜的发现 <code>mheap.sysAlloc</code> 里其实有调用 <code>sysReserve</code> 方法，而 <code>sysReserve</code> 方法又正正是从 OS 系统中保留内存的地址空间的特定方法，是不是很惊喜，一切似乎都串起来了。</p>
<h4 id="小结-1">小结</h4>
<p>在本节中，我们先写了一个测试程序，然后根据非常规的排查思路进行了一步步的跟踪怀疑，整体流程如下：</p>
<ul>
<li>通过 <code>top</code> 或 <code>ps</code> 等命令，查看进程运行情况，分析基础指标。</li>
<li>通过 <code>pprof</code> 或 <code>runtime.MemStats </code> 等工具链查看应用运行情况，分析应用层面是否有泄露或者哪儿高。</li>
<li>通过 <code>vmmap</code> 命令，查看进程的内存映射情况，分析是不是进程虚拟空间内的某个区域比较高，例如：共享库等。</li>
<li>通过 <code>dtruss</code> 命令，查看程序的系统调用情况，分析可能出现的一些特殊行为，例如：在分析中我们发现  <code>mmap</code> 方法调用的比例是比较高的，那我们有充分的理由怀疑 Go 在启动时就进行了大量的内存空间保留。</li>
<li>通过上述的分析，确定可能是在哪个环节申请了那么多的内存空间后，再到 Go Runtime 中去做进一步的源码分析，因为源码面前，了无秘密，没必要靠猜。</li>
</ul>
<p>从结论上而言，VSZ（进程虚拟内存大小）与共享库等没有太大的关系，主要与 Go Runtime 存在直接关联，也就是在前图中表示的运行时堆（malloc）。转换到 Go Runtime 里，就是在 <code>mallocinit</code>  这个内存分配器的初始化阶段里进行了一定量的虚拟空间的保留。</p>
<p>而保留虚拟内存空间时，受什么影响，又是一个哲学问题。从源码上来看，主要如下：</p>
<ul>
<li>受不同的 OS 系统架构（GOARCH/GOOS）和位数（32/64 位）的影响。</li>
<li>受内存对齐的影响，计算回来的内存空间大小是需要经过对齐才会进行保留。</li>
</ul>
<h2 id="总结">总结</h2>
<p>我们通过一步步地分析，讲解了 Go 会在哪里，又会受什么因素，去调用了什么方法保留了那么多的虚拟内存空间，但是我们肯定会忧心进程虚拟内存（VSZ）高，会不会存在问题呢，我分析如下：</p>
<ul>
<li>VSZ 并不意味着你真正使用了那些物理内存，因此是不需要担心的。</li>
<li>VSZ 并不会给 GC 带来压力，GC 管理的是进程实际使用的物理内存，而 VSZ 在你实际使用它之前，它并没有过多的代价。</li>
<li>VSZ 基本都是不可访问的内存映射，也就是它并没有内存的访问权限（不允许读、写和执行）。</li>
</ul>
<p>看到这里舒一口气，因为 Go VSZ 的高，并不会对我们产生什么非常实质性的问题，但是又仔细一想，为什么 Go 要申请那么多的虚拟内存呢，到底有啥用呢，考虑如下：Go 的设计是考虑到 <code>arena</code> 和  <code>bitmap</code> 的后续使用，先提早保留了整个内存地址空间。 然后随着 Go Runtime 和应用的逐步使用，肯定也会开始实际的申请和使用内存，这时候 <code>arena</code> 和 <code>bitmap</code> 的内存分配器就只需要将事先申请好的内存地址空间保留更改为实际可用的物理内存就好了，这样子可以极大的提高效能。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://xargin.com/go-bootstrap/">曹大的 Go 程序的启动流程</a></li>
<li><a href="https://www.cnblogs.com/qcrao-2018/p/11124360.html">全成的 Go 程序是怎样跑起来的</a></li>
<li><a href="https://github.com/changkun/go-under-the-hood/blob/master/book/zh-cn/part2runtime/ch07alloc/readme.md">推荐阅读 欧神的 go-under-the-hood</a></li>
<li><a href="https://forum.golangbridge.org/t/high-virtual-memory-allocation-by-golang/6716">High virtual memory allocation by golang</a></li>
<li><a href="https://povilasv.me/go-memory-management/">GO MEMORY MANAGEMENT</a></li>
<li><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoBigVirtualSize">GoBigVirtualSize</a></li>
<li><a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoProgramMemoryUse">GoProgramMemoryUse</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go1.13 defer 的性能是如何提高的</title>
			<link>https://eddycjy.com/posts/go/talk/2019-09-07-go1.13-defer/</link>
			<pubDate>Sat, 07 Sep 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2019-09-07-go1.13-defer/</guid>
			<description>最近 Go1.13 终于发布了，其中一个值得关注的特性就是 defer 在大部分的场景下性能提升了30%，但是官方并没有具体写是怎么提升的，这让大家非常的疑惑。而我因为之前写过《深入理解 Go defer》 和 《Go defer 会有性能损耗，尽量不要用？》 这类文章，因此我挺感兴趣它是做了什么改变才能得到这样子的结果，所以今天和大家一起探索其中奥妙。
一、测试 Go1.12 $ go test -bench=. -benchmem -run=none goos: darwin goarch: amd64 pkg: github.com/EDDYCJY/awesomeDefer BenchmarkDoDefer-4 20000000	91.4 ns/op	48 B/op	1 allocs/op BenchmarkDoNotDefer-4 30000000	41.6 ns/op	48 B/op	1 allocs/op PASS ok github.com/EDDYCJY/awesomeDefer	3.234s Go1.13 $ go test -bench=. -benchmem -run=none goos: darwin goarch: amd64 pkg: github.com/EDDYCJY/awesomeDefer BenchmarkDoDefer-4 15986062	74.7 ns/op	48 B/op	1 allocs/op BenchmarkDoNotDefer-4 29231842	40.3 ns/op	48 B/op	1 allocs/op PASS ok github.</description>
			<content type="html"><![CDATA[<p>最近 Go1.13 终于发布了，其中一个值得关注的特性就是 <strong>defer 在大部分的场景下性能提升了30%</strong>，但是官方并没有具体写是怎么提升的，这让大家非常的疑惑。而我因为之前写过<a href="https://book.eddycjy.com/golang/defer/defer.html">《深入理解 Go defer》</a> 和 <a href="https://book.eddycjy.com/golang/talk/defer-loss.html">《Go defer 会有性能损耗，尽量不要用？》</a> 这类文章，因此我挺感兴趣它是做了什么改变才能得到这样子的结果，所以今天和大家一起探索其中奥妙。</p>
<h2 id="一测试">一、测试</h2>
<h3 id="go112">Go1.12</h3>
<pre><code>$ go test -bench=. -benchmem -run=none
goos: darwin
goarch: amd64
pkg: github.com/EDDYCJY/awesomeDefer
BenchmarkDoDefer-4      	20000000	        91.4 ns/op	      48 B/op	       1 allocs/op
BenchmarkDoNotDefer-4   	30000000	        41.6 ns/op	      48 B/op	       1 allocs/op
PASS
ok  	github.com/EDDYCJY/awesomeDefer	3.234s
</code></pre><h3 id="go113">Go1.13</h3>
<pre><code>$ go test -bench=. -benchmem -run=none
goos: darwin
goarch: amd64
pkg: github.com/EDDYCJY/awesomeDefer
BenchmarkDoDefer-4      	15986062	        74.7 ns/op	      48 B/op	       1 allocs/op
BenchmarkDoNotDefer-4   	29231842	        40.3 ns/op	      48 B/op	       1 allocs/op
PASS
ok  	github.com/EDDYCJY/awesomeDefer	3.444s
</code></pre><p>在开场，我先以不标准的测试基准验证了先前的测试用例，确确实实在这两个版本中，<code>defer</code> 的性能得到了提高，但是看上去似乎不是百分百提高 30 %。</p>
<h2 id="二看一下">二、看一下</h2>
<h3 id="之前go112">之前（Go1.12）</h3>
<pre><code>    0x0070 00112 (main.go:6)    CALL    runtime.deferproc(SB)
    0x0075 00117 (main.go:6)    TESTL    AX, AX
    0x0077 00119 (main.go:6)    JNE    137
    0x0079 00121 (main.go:7)    XCHGL    AX, AX
    0x007a 00122 (main.go:7)    CALL    runtime.deferreturn(SB)
    0x007f 00127 (main.go:7)    MOVQ    56(SP), BP
</code></pre><h3 id="现在go113">现在（Go1.13）</h3>
<pre><code>	0x006e 00110 (main.go:4)	MOVQ	AX, (SP)
	0x0072 00114 (main.go:4)	CALL	runtime.deferprocStack(SB)
	0x0077 00119 (main.go:4)	TESTL	AX, AX
	0x0079 00121 (main.go:4)	JNE	139
	0x007b 00123 (main.go:7)	XCHGL	AX, AX
	0x007c 00124 (main.go:7)	CALL	runtime.deferreturn(SB)
	0x0081 00129 (main.go:7)	MOVQ	112(SP), BP
</code></pre><p>从汇编的角度来看，像是 <code>runtime.deferproc</code> 改成了 <code>runtime.deferprocStack</code> 调用，难道是做了什么优化，我们<strong>抱着疑问</strong>继续看下去。</p>
<h2 id="三观察源码">三、观察源码</h2>
<h3 id="_defer">_defer</h3>
<pre><code>type _defer struct {
	siz     int32
	siz     int32 // includes both arguments and results
	started bool
	heap    bool
	sp      uintptr // sp at time of defer
	pc      uintptr
	fn      *funcval
	...
</code></pre><p>相较于以前的版本，最小单元的 <code>_defer</code> 结构体主要是新增了 <code>heap</code> 字段，用于标识这个 <code>_defer</code> 是在堆上，还是在栈上进行分配，其余字段并没有明确变更，那我们可以把聚焦点放在 <code>defer</code> 的堆栈分配上了，看看是做了什么事。</p>
<h3 id="deferprocstack">deferprocStack</h3>
<pre><code>func deferprocStack(d *_defer) {
	gp := getg()
	if gp.m.curg != gp {
		throw(&quot;defer on system stack&quot;)
	}
	
	d.started = false
	d.heap = false
	d.sp = getcallersp()
	d.pc = getcallerpc()

	*(*uintptr)(unsafe.Pointer(&amp;d._panic)) = 0
	*(*uintptr)(unsafe.Pointer(&amp;d.link)) = uintptr(unsafe.Pointer(gp._defer))
	*(*uintptr)(unsafe.Pointer(&amp;gp._defer)) = uintptr(unsafe.Pointer(d))

	return0()
}
</code></pre><p>这一块代码挺常规的，主要是获取调用 <code>defer</code> 函数的函数栈指针、传入函数的参数具体地址以及PC（程序计数器），这块在前文 <a href="https://book.eddycjy.com/golang/defer/defer.html">《深入理解 Go defer》</a> 有详细介绍过，这里就不再赘述了。</p>
<p>那这个 <code>deferprocStack</code> 特殊在哪呢，我们可以看到它把 <code>d.heap</code> 设置为了 <code>false</code>，也就是代表 <code>deferprocStack</code> 方法是针对将 <code>_defer</code> 分配在栈上的应用场景的。</p>
<h3 id="deferproc">deferproc</h3>
<p>那么问题来了，它又在哪里处理分配到堆上的应用场景呢？</p>
<pre><code>func newdefer(siz int32) *_defer {
	...
	d.heap = true
	d.link = gp._defer
	gp._defer = d
	return d
}
</code></pre><p>那么 <code>newdefer</code> 是在哪里调用的呢，如下：</p>
<pre><code>func deferproc(siz int32, fn *funcval) { // arguments of fn follow fn
	...
	sp := getcallersp()
	argp := uintptr(unsafe.Pointer(&amp;fn)) + unsafe.Sizeof(fn)
	callerpc := getcallerpc()

	d := newdefer(siz)
	...
}
</code></pre><p>非常明确，先前的版本中调用的 <code>deferproc</code> 方法，现在被用于对应分配到堆上的场景了。</p>
<h3 id="小结">小结</h3>
<ul>
<li>第一点：可以确定的是 <code>deferproc</code> 并没有被去掉，而是流程被优化了。</li>
<li>第二点：编译器会根据应用场景去选择使用 <code>deferproc</code> 还是 <code>deferprocStack</code> 方法，他们分别是针对分配在堆上和栈上的使用场景。</li>
</ul>
<h2 id="四编译器如何选择">四、编译器如何选择</h2>
<h3 id="esc">esc</h3>
<pre><code>// src/cmd/compile/internal/gc/esc.go
case ODEFER:
	if e.loopdepth == 1 { // top level
		n.Esc = EscNever // force stack allocation of defer record (see ssa.go)
		break
	}
</code></pre><h3 id="ssa">ssa</h3>
<pre><code>// src/cmd/compile/internal/gc/ssa.go
case ODEFER:
	d := callDefer
	if n.Esc == EscNever {
		d = callDeferStack
	}
    s.call(n.Left, d)
</code></pre><h3 id="小结-1">小结</h3>
<p>这块结合来看，核心就是当 <code>e.loopdepth == 1</code> 时，会将逃逸分析结果 <code>n.Esc</code> 设置为 <code>EscNever</code>，也就是将 <code>_defer</code> 分配到栈上，那这个 <code>e.loopdepth</code> 到底又是何方神圣呢，我们再详细看看代码，如下：</p>
<pre><code>// src/cmd/compile/internal/gc/esc.go
type NodeEscState struct {
	Curfn             *Node
	Flowsrc           []EscStep 
	Retval            Nodes    
	Loopdepth         int32  
	Level             Level
	Walkgen           uint32
	Maxextraloopdepth int32
}
</code></pre><p>这里重点查看 <code>Loopdepth</code> 字段，目前它共有三个值标识，分别是:</p>
<ul>
<li>-1：全局。</li>
<li>0：返回变量。</li>
<li>1：顶级函数，又或是内部函数的不断增长值。</li>
</ul>
<p>这个读起来有点绕，结合我们上述 <code>e.loopdepth == 1</code> 的表述来看，也就是当 <code>defer func</code> 是顶级函数时，将会分配到栈上。但是若在  <code>defer func</code> 外层出现显式的迭代循环，又或是出现隐式迭代，将会分配到堆上。其实深层表示的还是迭代深度的意思，我们可以来证实一下刚刚说的方向，显式迭代的代码如下：</p>
<pre><code>func main() {
	for p := 0; p &lt; 10; p++ {
		defer func() {
			for i := 0; i &lt; 20; i++ {
				log.Println(&quot;EDDYCJY&quot;)
			}
		}()
	}
}
</code></pre><p>查看汇编情况：</p>
<pre><code>$ go tool compile -S main.go
&quot;&quot;.main STEXT size=122 args=0x0 locals=0x20
	0x0000 00000 (main.go:15)	TEXT	&quot;&quot;.main(SB), ABIInternal, $32-0
	...
	0x0048 00072 (main.go:17)	CALL	runtime.deferproc(SB)
	0x004d 00077 (main.go:17)	TESTL	AX, AX
	0x004f 00079 (main.go:17)	JNE	83
	0x0051 00081 (main.go:17)	JMP	33
	0x0053 00083 (main.go:17)	XCHGL	AX, AX
	0x0054 00084 (main.go:17)	CALL	runtime.deferreturn(SB)
	...
</code></pre><p>显然，最终 <code>defer</code> 调用的是 <code>runtime.deferproc</code> 方法，也就是分配到堆上了，没毛病。而隐式迭代的话，你可以借助 <code>goto</code> 语句去实现这个功能，再自己验证一遍，这里就不再赘述了。</p>
<h2 id="总结">总结</h2>
<p>从分析的结果上来看，官方说明的 Go1.13 defer 性能提高 30%，主要来源于其延迟对象的堆栈分配规则的改变，措施是由编译器通过对 <code>defer</code> 的 <code>for-loop</code> 迭代深度进行分析，如果 <code>loopdepth</code> 为 1，则设置逃逸分析的结果，将分配到栈上，否则分配到堆上。</p>
<p>的确，我个人觉得对大部分的使用场景来讲，是优化了不少，也解决了一些人吐槽 <code>defer</code> 性能 “差” 的问题。另外，我想从 Go1.13 起，你也需要稍微了解一下它这块的机制，别随随便便就来个狂野版嵌套迭代 <code>defer</code>，可能没法效能最大化。</p>
<p>如果你还想了解更多细节，可以看看 <code>defer</code> 这块的的<a href="https://github.com/golang/go/commit/fff4f599fe1c21e411a99de5c9b3777d06ce0ce6">提交内容</a>，官方的测试用例也包含在里面。</p>
]]></content>
		</item>
		
		<item>
			<title>用 GODEBUG 看 GC</title>
			<link>https://eddycjy.com/posts/go/tools/2019-09-02-godebug-gc/</link>
			<pubDate>Mon, 02 Sep 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/tools/2019-09-02-godebug-gc/</guid>
			<description>什么是 GC 在计算机科学中，垃圾回收（GC）是一种自动管理内存的机制，垃圾回收器会去尝试回收程序不再使用的对象及其占用的内存。而最早 John McCarthy 在 1959 年左右发明了垃圾回收，以简化 Lisp 中的手动内存管理的机制（来自 wikipedia）。
为什么要 GC 手动管理内存挺麻烦，管错或者管漏内存也很糟糕，将会直接导致程序不稳定（持续泄露）甚至直接崩溃。
GC 带来的问题 硬要说会带来什么问题的话，也就数大家最关注的 Stop The World（STW），STW 代指在执行某个垃圾回收算法的某个阶段时，需要将整个应用程序暂停去处理 GC 相关的工作事项。例如：
   行为 会不会 STW 为什么     标记开始 会 在开始标记时，准备根对象的扫描，会打开写屏障（Write Barrier） 和 辅助GC（mutator assist），而回收器和应用程序是并发运行的，因此会暂停当前正在运行的所有 Goroutine。   并发标记中 不会 标记阶段，主要目的是标记堆内存中仍在使用的值。   标记结束 会 在完成标记任务后，将重新扫描部分根对象，这时候会禁用写屏障（Write Barrier）和辅助GC（mutator assist），而标记阶段和应用程序是并发运行的，所以在标记阶段可能会有新的对象产生，因此在重新扫描时需要进行 STW。    如何调整 GC 频率 可以通过 GOGC 变量设置初始垃圾收集器的目标百分比值，对比的规则为当新分配的数值与上一次收集后剩余的实时数值的比例达到设置的目标百分比时，就会触发 GC，默认值为 GOGC=100。如果将其设置为 GOGC=off 可以完全禁用垃圾回收器，要不试试？
简单来讲就是，GOGC 的值设置的越大，GC 的频率越低，但每次最终所触发到 GC 的堆内存也会更大。</description>
			<content type="html"><![CDATA[<p><img src="https://image.eddycjy.com/b07f55c7fd136392763729b9782f7776.png" alt="image"></p>
<h2 id="什么是-gc">什么是 GC</h2>
<p>在计算机科学中，垃圾回收（GC）是一种自动管理内存的机制，垃圾回收器会去尝试回收程序不再使用的对象及其占用的内存。而最早 John McCarthy 在 1959 年左右发明了垃圾回收，以简化 Lisp 中的手动内存管理的机制（来自 wikipedia）。</p>
<h2 id="为什么要-gc">为什么要 GC</h2>
<p>手动管理内存挺麻烦，管错或者管漏内存也很糟糕，将会直接导致程序不稳定（持续泄露）甚至直接崩溃。</p>
<h2 id="gc-带来的问题">GC 带来的问题</h2>
<p>硬要说会带来什么问题的话，也就数大家最关注的 Stop The World（STW），STW 代指在执行某个垃圾回收算法的某个阶段时，需要将整个应用程序暂停去处理 GC 相关的工作事项。例如：</p>
<table>
<thead>
<tr>
<th>行为</th>
<th>会不会 STW</th>
<th>为什么</th>
</tr>
</thead>
<tbody>
<tr>
<td>标记开始</td>
<td>会</td>
<td>在开始标记时，准备根对象的扫描，会打开写屏障（Write Barrier） 和 辅助GC（mutator assist），而回收器和应用程序是并发运行的，因此会暂停当前正在运行的所有 Goroutine。</td>
</tr>
<tr>
<td>并发标记中</td>
<td>不会</td>
<td>标记阶段，主要目的是标记堆内存中仍在使用的值。</td>
</tr>
<tr>
<td>标记结束</td>
<td>会</td>
<td>在完成标记任务后，将重新扫描部分根对象，这时候会禁用写屏障（Write Barrier）和辅助GC（mutator assist），而标记阶段和应用程序是并发运行的，所以在标记阶段可能会有新的对象产生，因此在重新扫描时需要进行 STW。</td>
</tr>
</tbody>
</table>
<h2 id="如何调整-gc-频率">如何调整 GC 频率</h2>
<p>可以通过 GOGC 变量设置初始垃圾收集器的目标百分比值，对比的规则为当新分配的数值与上一次收集后剩余的实时数值的比例达到设置的目标百分比时，就会触发 GC，默认值为 GOGC=100。如果将其设置为 GOGC=off 可以完全禁用垃圾回收器，要不试试？</p>
<p>简单来讲就是，GOGC 的值设置的越大，GC 的频率越低，但每次最终所触发到 GC 的堆内存也会更大。</p>
<h2 id="各版本-gc-情况">各版本 GC 情况</h2>
<table>
<thead>
<tr>
<th>版本</th>
<th>GC 算法</th>
<th>STW 时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>Go 1.0</td>
<td>STW（强依赖 tcmalloc）</td>
<td>百ms到秒级别</td>
</tr>
<tr>
<td>Go 1.3</td>
<td>Mark STW, Sweep 并行</td>
<td>百ms级别</td>
</tr>
<tr>
<td>Go 1.5</td>
<td>三色标记法, 并发标记清除。同时运行时从 C 和少量汇编，改为 Go 和少量汇编实现</td>
<td>10-50ms级别</td>
</tr>
<tr>
<td>Go 1.6</td>
<td>1.5 中一些与并发 GC 不协调的地方更改，集中式的 GC 协调协程，改为状态机实现</td>
<td>5ms级别</td>
</tr>
<tr>
<td>Go 1.7</td>
<td>GC 时由 mark 栈收缩改为并发，span 对象分配机制由 freelist 改为 bitmap 模式，SSA引入</td>
<td>ms级别</td>
</tr>
<tr>
<td>Go 1.8</td>
<td>混合写屏障（hybrid write barrier）, 消除 re-scanning stack</td>
<td>sub ms</td>
</tr>
<tr>
<td>Go 1.12</td>
<td>Mark Termination 流程优化</td>
<td>sub ms, 但几乎减少一半</td>
</tr>
</tbody>
</table>
<p>注：资料来源于 @boya 在深圳 Gopher Meetup 的分享。</p>
<h2 id="godebug">GODEBUG</h2>
<p>GODEBUG 变量可以控制运行时内的调试变量，参数以逗号分隔，格式为：<code>name=val</code>。本文着重点在 GC 的观察上，主要涉及 gctrace 参数，我们通过设置 <code>gctrace=1</code> 后就可以使得垃圾收集器向标准错误流发出 GC 运行信息。</p>
<h2 id="涉及术语">涉及术语</h2>
<ul>
<li>mark：标记阶段。</li>
<li>markTermination：标记结束阶段。</li>
<li>mutator assist：辅助 GC，是指在 GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作。</li>
<li>heap_live：在 Go 的内存管理中，span 是内存页的基本单元，每页大小为 8kb，同时 Go 会根据对象的大小不同而分配不同页数的 span，而 heap_live 就代表着所有 span 的总大小。</li>
<li>dedicated / fractional / idle：在标记阶段会分为三种不同的 mark worker 模式，分别是 dedicated、fractional 和 idle，它们代表着不同的专注程度，其中 dedicated 模式最专注，是完整的 GC 回收行为，fractional 只会干部分的 GC 行为，idle 最轻松。这里你只需要了解它是不同专注程度的 mark worker 就好了，详细介绍我们可以等后续的文章。</li>
</ul>
<h2 id="演示代码">演示代码</h2>
<pre><code>func main() {
    wg := sync.WaitGroup{}
    wg.Add(10)
    for i := 0; i &lt; 10; i++ {
        go func(wg *sync.WaitGroup) {
            var counter int
            for i := 0; i &lt; 1e10; i++ {
                counter++
            }
            wg.Done()
        }(&amp;wg)
    }

    wg.Wait()
}
</code></pre><h2 id="gctrace">gctrace</h2>
<pre><code>$ GODEBUG=gctrace=1 go run main.go    
gc 1 @0.032s 0%: 0.019+0.45+0.003 ms clock, 0.076+0.22/0.40/0.80+0.012 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 4 P
gc 2 @0.046s 0%: 0.004+0.40+0.008 ms clock, 0.017+0.32/0.25/0.81+0.034 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 4 P
gc 3 @0.063s 0%: 0.004+0.40+0.008 ms clock, 0.018+0.056/0.32/0.64+0.033 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 4 P
gc 4 @0.080s 0%: 0.004+0.45+0.016 ms clock, 0.018+0.15/0.34/0.77+0.065 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 5 @0.095s 0%: 0.015+0.87+0.005 ms clock, 0.061+0.27/0.74/1.8+0.023 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 6 @0.113s 0%: 0.014+0.69+0.002 ms clock, 0.056+0.23/0.48/1.4+0.011 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
gc 7 @0.140s 1%: 0.031+2.0+0.042 ms clock, 0.12+0.43/1.8/0.049+0.17 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
...
</code></pre><h3 id="格式">格式</h3>
<pre><code>gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&gt;#-&gt;# MB, # MB goal, # P
</code></pre><h3 id="含义">含义</h3>
<ul>
<li><code>gc#</code>：GC 执行次数的编号，每次叠加。</li>
<li><code>@#s</code>：自程序启动后到当前的具体秒数。</li>
<li><code>#%</code>：自程序启动以来在GC中花费的时间百分比。</li>
<li><code>#+...+#</code>：GC 的标记工作共使用的 CPU 时间占总 CPU 时间的百分比。</li>
<li><code>#-&gt;#-&gt;# MB</code>：分别表示 GC 启动时, GC 结束时, GC 活动时的堆大小.</li>
<li><code>#MB goal</code>：下一次触发 GC 的内存占用阈值。</li>
<li><code>#P</code>：当前使用的处理器 P 的数量。</li>
</ul>
<h3 id="案例">案例</h3>
<pre><code>gc 7 @0.140s 1%: 0.031+2.0+0.042 ms clock, 0.12+0.43/1.8/0.049+0.17 ms cpu, 4-&gt;4-&gt;1 MB, 5 MB goal, 4 P
</code></pre><ul>
<li>gc 7：第 7 次 GC。</li>
<li>@0.140s：当前是程序启动后的 0.140s。</li>
<li>1%：程序启动后到现在共花费 1% 的时间在 GC 上。</li>
<li>0.031+2.0+0.042 ms clock：
<ul>
<li>0.031：表示单个 P 在 mark 阶段的 STW 时间。</li>
<li>2.0：表示所有 P 的 mark concurrent（并发标记）所使用的时间。</li>
<li>0.042：表示单个 P 的 markTermination 阶段的 STW 时间。</li>
</ul>
</li>
<li>0.12+0.43/1.8/0.049+0.17 ms cpu：
<ul>
<li>0.12：表示整个进程在 mark 阶段 STW 停顿的时间。</li>
<li>0.43/1.8/0.049：0.43 表示 mutator assist 占用的时间，1.8 表示 dedicated + fractional 占用的时间，0.049 表示 idle 占用的时间。</li>
<li>0.17ms：0.17 表示整个进程在 markTermination 阶段 STW 时间。</li>
</ul>
</li>
<li>4-&gt;4-&gt;1 MB：
<ul>
<li>4：表示开始 mark 阶段前的 heap_live 大小。</li>
<li>4：表示开始 markTermination 阶段前的 heap_live 大小。</li>
<li>1：表示被标记对象的大小。</li>
</ul>
</li>
<li>5 MB goal：表示下一次触发 GC 回收的阈值是 5 MB。</li>
<li>4 P：本次 GC 一共涉及多少个 P。</li>
</ul>
<h2 id="总结">总结</h2>
<p>通过本章节我们掌握了使用 GODEBUG 查看应用程序 GC 运行情况的方法，只要用这种方法我们就可以观测不同情况下 GC 的情况了，甚至可以做出非常直观的对比图，大家不妨尝试一下。</p>
<h2 id="关联文章">关联文章</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/Brby6D7d1szUIBjcD_8kfg">用 GODEBUG 看调度跟踪</a></li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://gocn.vip/question/310">Go GC打印出来的这些信息都是什么含义？</a></li>
<li><a href="http://cbsheng.github.io/posts/godebug%E4%B9%8Bgctrace%E8%A7%A3%E6%9E%90/">GODEBUG之gctrace解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/77943973">关于Golang GC的一些误解&ndash;真的比Java GC更领先吗？</a></li>
<li>@boya 深入浅出Golang Runtime PPT</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>用 GODEBUG 看调度跟踪</title>
			<link>https://eddycjy.com/posts/go/tools/2019-08-19-godebug-sched/</link>
			<pubDate>Mon, 19 Aug 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/tools/2019-08-19-godebug-sched/</guid>
			<description>让 Go 更强大的原因之一莫过于它的 GODEBUG 工具，GODEBUG 的设置可以让 Go 程序在运行时输出调试信息，可以根据你的要求很直观的看到你想要的调度器或垃圾回收等详细信息，并且还不需要加装其它的插件，非常方便，今天我们将先讲解 GODEBUG 的调度器相关内容，希望对你有所帮助。
不过在开始前，没接触过的小伙伴得先补补如下前置知识，便于更好的了解调试器输出的信息内容。
前置知识 Go scheduler 的主要功能是针对在处理器上运行的 OS 线程分发可运行的 Goroutine，而我们一提到调度器，就离不开三个经常被提到的缩写，分别是：
 G：Goroutine，实际上我们每次调用 go func 就是生成了一个 G。 P：处理器，一般为处理器的核数，可以通过 GOMAXPROCS 进行修改。 M：OS 线程  这三者交互实际来源于 Go 的 M: N 调度模型，也就是 M 必须与 P 进行绑定，然后不断地在 M 上循环寻找可运行的 G 来执行相应的任务，如果想具体了解可以详细阅读 《Go Runtime Scheduler》，我们抽其中的工作流程图进行简单分析，如下:
 当我们执行 go func() 时，实际上就是创建一个全新的 Goroutine，我们称它为 G。 新创建的 G 会被放入 P 的本地队列（Local Queue）或全局队列（Global Queue）中，准备下一步的动作。 唤醒或创建 M 以便执行 G。 不断地进行事件循环 寻找在可用状态下的 G 进行执行任务 清除后，重新进入事件循环  而在描述中有提到全局和本地这两类队列，其实在功能上来讲都是用于存放正在等待运行的 G，但是不同点在于，本地队列有数量限制，不允许超过 256 个。并且在新建 G 时，会优先选择 P 的本地队列，如果本地队列满了，则将 P 的本地队列的一半的 G 移动到全局队列，这其实可以理解为调度资源的共享和再平衡。</description>
			<content type="html"><![CDATA[<p><img src="https://image.eddycjy.com/b01c2ce25e34f80d499f0488d034b00b.png" alt="image"></p>
<p>让 Go 更强大的原因之一莫过于它的 GODEBUG 工具，GODEBUG 的设置可以让 Go 程序在运行时输出调试信息，可以根据你的要求很直观的看到你想要的调度器或垃圾回收等详细信息，并且还不需要加装其它的插件，非常方便，今天我们将先讲解 GODEBUG 的调度器相关内容，希望对你有所帮助。</p>
<p>不过在开始前，没接触过的小伙伴得先补补如下前置知识，便于更好的了解调试器输出的信息内容。</p>
<h2 id="前置知识">前置知识</h2>
<p>Go scheduler 的主要功能是针对在处理器上运行的 OS 线程分发可运行的 Goroutine，而我们一提到调度器，就离不开三个经常被提到的缩写，分别是：</p>
<ul>
<li>G：Goroutine，实际上我们每次调用 <code>go func</code> 就是生成了一个 G。</li>
<li>P：处理器，一般为处理器的核数，可以通过 <code>GOMAXPROCS</code> 进行修改。</li>
<li>M：OS 线程</li>
</ul>
<p>这三者交互实际来源于 Go 的 M: N 调度模型，也就是 M 必须与 P 进行绑定，然后不断地在 M 上循环寻找可运行的 G 来执行相应的任务，如果想具体了解可以详细阅读 <a href="https://speakerdeck.com/retervision/go-runtime-scheduler">《Go Runtime Scheduler》</a>，我们抽其中的工作流程图进行简单分析，如下:</p>
<p><img src="https://image.eddycjy.com/fb4c6c92c93af3bc2dfc4f13dc167cdf.png" alt="image"></p>
<ol>
<li>当我们执行 <code>go func()</code> 时，实际上就是创建一个全新的 Goroutine，我们称它为 G。</li>
<li>新创建的 G 会被放入 P 的本地队列（Local Queue）或全局队列（Global Queue）中，准备下一步的动作。</li>
<li>唤醒或创建 M 以便执行 G。</li>
<li>不断地进行事件循环</li>
<li>寻找在可用状态下的 G 进行执行任务</li>
<li>清除后，重新进入事件循环</li>
</ol>
<p>而在描述中有提到全局和本地这两类队列，其实在功能上来讲都是用于存放正在等待运行的 G，但是不同点在于，本地队列有数量限制，不允许超过 256 个。并且在新建 G 时，会优先选择 P 的本地队列，如果本地队列满了，则将 P 的本地队列的一半的 G 移动到全局队列，这其实可以理解为调度资源的共享和再平衡。</p>
<p>另外我们可以看到图上有 steal 行为，这是用来做什么的呢，我们都知道当你创建新的 G 或者 G 变成可运行状态时，它会被推送加入到当前 P 的本地队列中。但其实当 P 执行 G 完毕后，它也会 “干活”，它会将其从本地队列中弹出 G，同时会检查当前本地队列是否为空，如果为空会随机的从其他 P 的本地队列中尝试窃取一半可运行的 G 到自己的名下。例子如下：</p>
<p><img src="https://image.eddycjy.com/e7ca8f212466d8c15ec0f60b69a1ce4d.png" alt="image"></p>
<p>在这个例子中，P2 在本地队列中找不到可以运行的 G，它会执行 <code>work-stealing</code> 调度算法，随机选择其它的处理器 P1，并从 P1 的本地队列中窃取了三个 G 到它自己的本地队列中去。至此，P1、P2 都拥有了可运行的 G，P1 多余的 G 也不会被浪费，调度资源将会更加平均的在多个处理器中流转。</p>
<h2 id="godebug">GODEBUG</h2>
<p>GODEBUG 变量可以控制运行时内的调试变量，参数以逗号分隔，格式为：<code>name=val</code>。本文着重点在调度器观察上，将会使用如下两个参数：</p>
<ul>
<li>schedtrace：设置 <code>schedtrace=X</code> 参数可以使运行时在每 X 毫秒发出一行调度器的摘要信息到标准 err 输出中。</li>
<li>scheddetail：设置 <code>schedtrace=X</code> 和 <code>scheddetail=1</code> 可以使运行时在每 X 毫秒发出一次详细的多行信息，信息内容主要包括调度程序、处理器、OS 线程 和 Goroutine 的状态。</li>
</ul>
<h3 id="演示代码">演示代码</h3>
<pre><code>func main() {
	wg := sync.WaitGroup{}
	wg.Add(10)
	for i := 0; i &lt; 10; i++ {
		go func(wg *sync.WaitGroup) {
			var counter int
			for i := 0; i &lt; 1e10; i++ {
				counter++
			}
			wg.Done()
		}(&amp;wg)
	}

	wg.Wait()
}
</code></pre><h3 id="schedtrace">schedtrace</h3>
<pre><code>$ GODEBUG=schedtrace=1000 ./awesomeProject 
SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=5 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0]
SCHED 1000ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 2000ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 3001ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 4010ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 5011ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 6012ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 [1 2 2 1]
SCHED 7021ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 8023ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 9031ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 10033ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 11038ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 12044ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 13051ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=4 [0 1 1 0]
SCHED 14052ms: gomaxprocs=4 idleprocs=2 threads=5 
...
</code></pre><ul>
<li>sched：每一行都代表调度器的调试信息，后面提示的毫秒数表示启动到现在的运行时间，输出的时间间隔受 <code>schedtrace</code> 的值影响。</li>
<li>gomaxprocs：当前的 CPU 核心数（GOMAXPROCS 的当前值）。</li>
<li>idleprocs：空闲的处理器数量，后面的数字表示当前的空闲数量。</li>
<li>threads：OS 线程数量，后面的数字表示当前正在运行的线程数量。</li>
<li>spinningthreads：自旋状态的 OS 线程数量。</li>
<li>idlethreads：空闲的线程数量。</li>
<li>runqueue：全局队列中中的 Goroutine 数量，而后面的 [0 0 1 1] 则分别代表这 4 个 P 的本地队列正在运行的 Goroutine 数量。</li>
</ul>
<p>在上面我们有提到 “自旋线程” 这个概念，如果你之前没有了解过相关概念，一听 “自旋” 肯定会比较懵，我们引用 《Head First of Golang Scheduler》 的内容来说明：</p>
<blockquote>
<p>自旋线程的这个说法，是因为 Go Scheduler 的设计者在考虑了 “OS 的资源利用率” 以及 “频繁的线程抢占给 OS 带来的负载” 之后，提出了 “Spinning Thread” 的概念。也就是当 “自旋线程” 没有找到可供其调度执行的 Goroutine 时，并不会销毁该线程 ，而是采取 “自旋” 的操作保存了下来。虽然看起来这是浪费了一些资源，但是考虑一下 syscall 的情景就可以知道，比起 “自旋&rdquo;，线程间频繁的抢占以及频繁的创建和销毁操作可能带来的危害会更大。</p>
</blockquote>
<h3 id="scheddetail">scheddetail</h3>
<p>如果我们想要更详细的看到调度器的完整信息时，我们可以增加 <code>scheddetail</code> 参数，就能够更进一步的查看调度的细节逻辑，如下：</p>
<pre><code>$ GODEBUG=scheddetail=1,schedtrace=1000 ./awesomeProject
SCHED 1000ms: gomaxprocs=4 idleprocs=0 threads=5 spinningthreads=0 idlethreads=0 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0
  P0: status=1 schedtick=2 syscalltick=0 m=3 runqsize=3 gfreecnt=0
  P1: status=1 schedtick=2 syscalltick=0 m=4 runqsize=1 gfreecnt=0
  P2: status=1 schedtick=2 syscalltick=0 m=0 runqsize=1 gfreecnt=0
  P3: status=1 schedtick=1 syscalltick=0 m=2 runqsize=1 gfreecnt=0
  M4: p=1 curg=18 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=false lockedg=-1
  M3: p=0 curg=22 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=false lockedg=-1
  M2: p=3 curg=24 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=false lockedg=-1
  M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1
  M0: p=2 curg=26 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=false lockedg=-1
  G1: status=4(semacquire) m=-1 lockedm=-1
  G2: status=4(force gc (idle)) m=-1 lockedm=-1
  G3: status=4(GC sweep wait) m=-1 lockedm=-1
  G17: status=1() m=-1 lockedm=-1
  G18: status=2() m=4 lockedm=-1
  G19: status=1() m=-1 lockedm=-1
  G20: status=1() m=-1 lockedm=-1
  G21: status=1() m=-1 lockedm=-1
  G22: status=2() m=3 lockedm=-1
  G23: status=1() m=-1 lockedm=-1
  G24: status=2() m=2 lockedm=-1
  G25: status=1() m=-1 lockedm=-1
  G26: status=2() m=0 lockedm=-1
</code></pre><p>在这里我们抽取了 1000ms 时的调试信息来查看，信息量比较大，我们先从每一个字段开始了解。如下：</p>
<h4 id="g">G</h4>
<ul>
<li>status：G 的运行状态。</li>
<li>m：隶属哪一个 M。</li>
<li>lockedm：是否有锁定 M。</li>
</ul>
<p>在第一点中我们有提到 G 的运行状态，这对于分析内部流转非常的有用，共涉及如下 9 种状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>_Gidle</td>
<td>0</td>
<td>刚刚被分配，还没有进行初始化。</td>
</tr>
<tr>
<td>_Grunnable</td>
<td>1</td>
<td>已经在运行队列中，还没有执行用户代码。</td>
</tr>
<tr>
<td>_Grunning</td>
<td>2</td>
<td>不在运行队列里中，已经可以执行用户代码，此时已经分配了 M 和 P。</td>
</tr>
<tr>
<td>_Gsyscall</td>
<td>3</td>
<td>正在执行系统调用，此时分配了 M。</td>
</tr>
<tr>
<td>_Gwaiting</td>
<td>4</td>
<td>在运行时被阻止，没有执行用户代码，也不在运行队列中，此时它正在某处阻塞等待中。</td>
</tr>
<tr>
<td>_Gmoribund_unused</td>
<td>5</td>
<td>尚未使用，但是在 gdb 中进行了硬编码。</td>
</tr>
<tr>
<td>_Gdead</td>
<td>6</td>
<td>尚未使用，这个状态可能是刚退出或是刚被初始化，此时它并没有执行用户代码，有可能有也有可能没有分配堆栈。</td>
</tr>
<tr>
<td>_Genqueue_unused</td>
<td>7</td>
<td>尚未使用。</td>
</tr>
<tr>
<td>_Gcopystack</td>
<td>8</td>
<td>正在复制堆栈，并没有执行用户代码，也不在运行队列中。</td>
</tr>
</tbody>
</table>
<p>在理解了各类的状态的意思后，我们结合上述案例看看，如下：</p>
<pre><code>G1: status=4(semacquire) m=-1 lockedm=-1
G2: status=4(force gc (idle)) m=-1 lockedm=-1
G3: status=4(GC sweep wait) m=-1 lockedm=-1
G17: status=1() m=-1 lockedm=-1
G18: status=2() m=4 lockedm=-1
</code></pre><p>在这个片段中，G1 的运行状态为 <code>_Gwaiting</code>，并没有分配 M 和锁定。这时候你可能好奇在片段中括号里的是什么东西呢，其实是因为该 <code>status=4</code> 是表示 <code>Goroutine</code> 在<strong>运行时时被阻止</strong>，而阻止它的事件就是 <code>semacquire</code> 事件，是因为 <code>semacquire</code> 会检查信号量的情况，在合适的时机就调用 <code>goparkunlock</code> 函数，把当前 <code>Goroutine</code> 放进等待队列，并把它设为 <code>_Gwaiting</code> 状态。</p>
<p>那么在实际运行中还有什么原因会导致这种现象呢，我们一起看看，如下：</p>
<pre><code>	waitReasonZero                                    // &quot;&quot;
	waitReasonGCAssistMarking                         // &quot;GC assist marking&quot;
	waitReasonIOWait                                  // &quot;IO wait&quot;
	waitReasonChanReceiveNilChan                      // &quot;chan receive (nil chan)&quot;
	waitReasonChanSendNilChan                         // &quot;chan send (nil chan)&quot;
	waitReasonDumpingHeap                             // &quot;dumping heap&quot;
	waitReasonGarbageCollection                       // &quot;garbage collection&quot;
	waitReasonGarbageCollectionScan                   // &quot;garbage collection scan&quot;
	waitReasonPanicWait                               // &quot;panicwait&quot;
	waitReasonSelect                                  // &quot;select&quot;
	waitReasonSelectNoCases                           // &quot;select (no cases)&quot;
	waitReasonGCAssistWait                            // &quot;GC assist wait&quot;
	waitReasonGCSweepWait                             // &quot;GC sweep wait&quot;
	waitReasonChanReceive                             // &quot;chan receive&quot;
	waitReasonChanSend                                // &quot;chan send&quot;
	waitReasonFinalizerWait                           // &quot;finalizer wait&quot;
	waitReasonForceGGIdle                             // &quot;force gc (idle)&quot;
	waitReasonSemacquire                              // &quot;semacquire&quot;
	waitReasonSleep                                   // &quot;sleep&quot;
	waitReasonSyncCondWait                            // &quot;sync.Cond.Wait&quot;
	waitReasonTimerGoroutineIdle                      // &quot;timer goroutine (idle)&quot;
	waitReasonTraceReaderBlocked                      // &quot;trace reader (blocked)&quot;
	waitReasonWaitForGCCycle                          // &quot;wait for GC cycle&quot;
	waitReasonGCWorkerIdle                            // &quot;GC worker (idle)&quot;
</code></pre><p>我们通过以上 <code>waitReason</code> 可以了解到 <code>Goroutine</code> 会被暂停运行的原因要素，也就是会出现在括号中的事件。</p>
<h4 id="m">M</h4>
<ul>
<li>p：隶属哪一个 P。</li>
<li>curg：当前正在使用哪个 G。</li>
<li>runqsize：运行队列中的 G 数量。</li>
<li>gfreecnt：可用的G（状态为 Gdead）。</li>
<li>mallocing：是否正在分配内存。</li>
<li>throwing：是否抛出异常。</li>
<li>preemptoff：不等于空字符串的话，保持 curg 在这个 m 上运行。</li>
</ul>
<h4 id="p">P</h4>
<ul>
<li>status：P 的运行状态。</li>
<li>schedtick：P 的调度次数。</li>
<li>syscalltick：P 的系统调用次数。</li>
<li>m：隶属哪一个 M。</li>
<li>runqsize：运行队列中的 G 数量。</li>
<li>gfreecnt：可用的G（状态为 Gdead）。</li>
</ul>
<table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>_Pidle</td>
<td>0</td>
<td>刚刚被分配，还没有进行进行初始化。</td>
</tr>
<tr>
<td>_Prunning</td>
<td>1</td>
<td>当 M 与 P 绑定调用 acquirep 时，P 的状态会改变为 _Prunning。</td>
</tr>
<tr>
<td>_Psyscall</td>
<td>2</td>
<td>正在执行系统调用。</td>
</tr>
<tr>
<td>_Pgcstop</td>
<td>3</td>
<td>暂停运行，此时系统正在进行 GC，直至 GC 结束后才会转变到下一个状态阶段。</td>
</tr>
<tr>
<td>_Pdead</td>
<td>4</td>
<td>废弃，不再使用。</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<p>通过本文我们学习到了调度的一些基础知识，再通过神奇的 GODEBUG 掌握了观察调度器的方式方法，你想想，是不是可以和我上一篇文章的 <code>go tool trace</code> 来结合使用呢，在实际的使用中，类似的办法有很多，组合巧用是重点。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs">Debugging performance issues in Go programs</a></li>
<li><a href="https://dave.cheney.net/tag/godebug">A whirlwind tour of Go’s runtime environment variables</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&amp;mid=2247483907&amp;idx=2&amp;sn=c955372683bc0078e14227702ab0a35e&amp;chksm=ce85c607f9f24f116158043f63f7ca11dc88cd519393ba182261f0d7fc328c7b6a94fef4e416&amp;scene=38#wechat_redirect">Go调度器系列（2）宏观看调度器</a></li>
<li><a href="https://rakyll.org/scheduler/">Go&rsquo;s work-stealing scheduler</a></li>
<li><a href="https://www.ardanlabs.com/blog/2015/02/scheduler-tracing-in-go.html">Scheduler Tracing In Go</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/42057783">Head First of Golang Scheduler</a></li>
<li><a href="http://xargin.com/state-of-goroutine/">goroutine 的状态切换</a></li>
<li><a href="https://golang.org/pkg/runtime/#hdr-Environment_Variables">Environment_Variables</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go 大杀器之跟踪剖析 trace</title>
			<link>https://eddycjy.com/posts/go/tools/2019-07-12-go-tool-trace/</link>
			<pubDate>Fri, 12 Jul 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/tools/2019-07-12-go-tool-trace/</guid>
			<description>在 Go 中有许许多多的分析工具，在之前我有写过一篇 《Golang 大杀器之性能剖析 PProf》 来介绍 PProf，如果有小伙伴感兴趣可以去我博客看看。
但单单使用 PProf 有时候不一定足够完整，因为在真实的程序中还包含许多的隐藏动作，例如 Goroutine 在执行时会做哪些操作？执行/阻塞了多长时间？在什么时候阻止？在哪里被阻止的？谁又锁/解锁了它们？GC 是怎么影响到 Goroutine 的执行的？这些东西用 PProf 是很难分析出来的，但如果你又想知道上述的答案的话，你可以用本文的主角 go tool trace 来打开新世界的大门。目录如下：
初步了解 import ( &amp;#34;os&amp;#34; &amp;#34;runtime/trace&amp;#34; ) func main() { trace.Start(os.Stderr) defer trace.Stop() ch := make(chan string) go func() { ch &amp;lt;- &amp;#34;EDDYCJY&amp;#34; }() &amp;lt;-ch } 生成跟踪文件：
$ go run main.go 2&amp;gt; trace.out 启动可视化界面：
$ go tool trace trace.out 2019/06/22 16:14:52 Parsing trace... 2019/06/22 16:14:52 Splitting trace... 2019/06/22 16:14:52 Opening browser.</description>
			<content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/15/1x1phF.png" alt="image"></p>
<p>在 Go 中有许许多多的分析工具，在之前我有写过一篇 《Golang 大杀器之性能剖析 PProf》 来介绍 PProf，如果有小伙伴感兴趣可以去我博客看看。</p>
<p>但单单使用 PProf 有时候不一定足够完整，因为在真实的程序中还包含许多的隐藏动作，例如 Goroutine 在执行时会做哪些操作？执行/阻塞了多长时间？在什么时候阻止？在哪里被阻止的？谁又锁/解锁了它们？GC 是怎么影响到 Goroutine 的执行的？这些东西用 PProf 是很难分析出来的，但如果你又想知道上述的答案的话，你可以用本文的主角 <code>go tool trace</code> 来打开新世界的大门。目录如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1x1P1J.png" alt="image"></p>
<h2 id="初步了解">初步了解</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;runtime/trace&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">trace</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">trace</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;EDDYCJY&#34;</span>
	<span class="p">}()</span>

	<span class="o">&lt;-</span><span class="nx">ch</span>
<span class="p">}</span>
</code></pre></div><p>生成跟踪文件：</p>
<pre><code>$ go run main.go 2&gt; trace.out
</code></pre><p>启动可视化界面：</p>
<pre><code>$ go tool trace trace.out
2019/06/22 16:14:52 Parsing trace...
2019/06/22 16:14:52 Splitting trace...
2019/06/22 16:14:52 Opening browser. Trace viewer is listening on http://127.0.0.1:57321
</code></pre><p>查看可视化界面：</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1x1FXR.png" alt="image"></p>
<ul>
<li>View trace：查看跟踪</li>
<li>Goroutine analysis：Goroutine 分析</li>
<li>Network blocking profile：网络阻塞概况</li>
<li>Synchronization blocking profile：同步阻塞概况</li>
<li>Syscall blocking profile：系统调用阻塞概况</li>
<li>Scheduler latency profile：调度延迟概况</li>
<li>User defined tasks：用户自定义任务</li>
<li>User defined regions：用户自定义区域</li>
<li>Minimum mutator utilization：最低 Mutator 利用率</li>
</ul>
<h3 id="scheduler-latency-profile">Scheduler latency profile</h3>
<p>在刚开始查看问题时，除非是很明显的现象，否则不应该一开始就陷入细节，因此我们一般先查看 “Scheduler latency profile”，我们能通过 Graph 看到整体的调用开销情况，如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1x1K9e.png" alt="image"></p>
<p>演示程序比较简单，因此这里就两块，一个是 <code>trace</code> 本身，另外一个是 <code>channel</code> 的收发。</p>
<h3 id="goroutine-analysis">Goroutine analysis</h3>
<p>第二步看 “Goroutine analysis”，我们能通过这个功能看到整个运行过程中，每个函数块有多少个有 Goroutine 在跑，并且观察每个的 Goroutine 的运行开销都花费在哪个阶段。如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1x1ljA.png" alt="image"></p>
<p>通过上图我们可以看到共有 3 个 goroutine，分别是 <code>runtime.main</code>、<code>runtime/trace.Start.func1</code>、<code>main.main.func1</code>，那么它都做了些什么事呢，接下来我们可以通过点击具体细项去观察。如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1x18Bt.jpg" alt="image"></p>
<p>同时也可以看到当前 Goroutine 在整个调用耗时中的占比，以及 GC 清扫和 GC 暂停等待的一些开销。如果你觉得还不够，可以把图表下载下来分析，相当于把整个 Goroutine 运行时掰开来看了，这块能够很好的帮助我们<strong>对 Goroutine 运行阶段做一个的剖析，可以得知到底慢哪，然后再决定下一步的排查方向</strong>。如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td>Execution Time</td>
<td>执行时间</td>
<td>3140ns</td>
</tr>
<tr>
<td>Network Wait Time</td>
<td>网络等待时间</td>
<td>0ns</td>
</tr>
<tr>
<td>Sync Block Time</td>
<td>同步阻塞时间</td>
<td>0ns</td>
</tr>
<tr>
<td>Blocking Syscall Time</td>
<td>调用阻塞时间</td>
<td>0ns</td>
</tr>
<tr>
<td>Scheduler Wait Time</td>
<td>调度等待时间</td>
<td>14ns</td>
</tr>
<tr>
<td>GC Sweeping</td>
<td>GC 清扫</td>
<td>0ns</td>
</tr>
<tr>
<td>GC Pause</td>
<td>GC 暂停</td>
<td>0ns</td>
</tr>
</tbody>
</table>
<h3 id="view-trace">View trace</h3>
<p>在对当前程序的 Goroutine 运行分布有了初步了解后，我们再通过 “查看跟踪” 看看之间的关联性，如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1x1GHP.png" alt="image"></p>
<p>这个跟踪图粗略一看，相信有的小伙伴会比较懵逼，我们可以依据注解一块块查看，如下：</p>
<ol>
<li>时间线：显示执行的时间单元，根据时间维度的不同可以调整区间，具体可执行 <code>shift</code> + <code>?</code> 查看帮助手册。</li>
<li>堆：显示执行期间的内存分配和释放情况。</li>
<li>协程：显示在执行期间的每个 Goroutine 运行阶段有多少个协程在运行，其包含 GC 等待（GCWaiting）、可运行（Runnable）、运行中（Running）这三种状态。</li>
<li>OS 线程：显示在执行期间有多少个线程在运行，其包含正在调用 Syscall（InSyscall）、运行中（Running）这两种状态。</li>
<li>虚拟处理器：每个虚拟处理器显示一行，虚拟处理器的数量一般默认为系统内核数。</li>
<li>协程和事件：显示在每个虚拟处理器上有什么 Goroutine 正在运行，而连线行为代表事件关联。</li>
</ol>
<p><img src="https://s2.ax1x.com/2020/02/15/1x1YAf.jpg" alt="image"></p>
<p>点击具体的 Goroutine 行为后可以看到其相关联的详细信息，这块很简单，大家实际操作一下就懂了。文字解释如下：</p>
<ul>
<li>Start：开始时间</li>
<li>Wall Duration：持续时间</li>
<li>Self Time：执行时间</li>
<li>Start Stack Trace：开始时的堆栈信息</li>
<li>End Stack Trace：结束时的堆栈信息</li>
<li>Incoming flow：输入流</li>
<li>Outgoing flow：输出流</li>
<li>Preceding events：之前的事件</li>
<li>Following events：之后的事件</li>
<li>All connected：所有连接的事件</li>
</ul>
<h3 id="view-events">View Events</h3>
<p>我们可以通过点击 View Options-Flow events、Following events 等方式，查看我们应用运行中的事件流情况。如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1x1d3Q.png" alt="image"></p>
<p>通过分析图上的事件流，我们可得知这程序从 <code>G1 runtime.main</code> 开始运行，在运行时创建了 2 个 Goroutine，先是创建 <code>G18 runtime/trace.Start.func1</code>，然后再是 <code>G19 main.main.func1</code> 。而同时我们可以通过其 Goroutine Name 去了解它的调用类型，如：<code>runtime/trace.Start.func1</code> 就是程序中在 <code>main.main</code> 调用了 <code>runtime/trace.Start</code> 方法，然后该方法又利用协程创建了一个闭包 <code>func1</code> 去进行调用。</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1x1Dun.png" alt="image"></p>
<p>在这里我们结合开头的代码去看的话，很明显就是 <code>ch</code> 的输入输出的过程了。</p>
<h2 id="结合实战">结合实战</h2>
<p>今天生产环境突然出现了问题，机智的你早已埋好 <code>_ &quot;net/http/pprof&quot;</code> 这个神奇的工具，你麻利的执行了如下命令：</p>
<ul>
<li>curl http://127.0.0.1:6060/debug/pprof/trace?seconds=20 &gt; trace.out</li>
<li>go tool trace trace.out</li>
</ul>
<h3 id="view-trace-1">View trace</h3>
<p>你很快的看到了熟悉的 List 界面，然后不信邪点开了 View trace 界面，如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1x1cNT.jpg" alt="image"></p>
<p>完全看懵的你，稳住，对着合适的区域执行快捷键 <code>W</code> 不断地放大时间线，如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1x1ID1.jpg" alt="image"></p>
<p>经过初步排查，你发现上述绝大部分的 G 竟然都和 <code>google.golang.org/grpc.(*Server).Serve.func</code> 有关，关联的一大串也是 <code>Serve</code> 所触发的相关动作。</p>
<p><img src="https://s2.ax1x.com/2020/02/16/3pNw9I.jpg" alt="image"></p>
<p>这时候有经验的你心里已经有了初步结论，你可以继续追踪 View trace 深入进去，不过我建议先鸟瞰全貌，因此我们再往下看 “Network blocking profile” 和 “Syscall blocking profile” 所提供的信息，如下：</p>
<h3 id="network-blocking-profile">Network blocking profile</h3>
<p><img src="https://s2.ax1x.com/2020/02/16/3pNfCn.jpg" alt="image"></p>
<h3 id="syscall-blocking-profile">Syscall blocking profile</h3>
<p><img src="https://s2.ax1x.com/2020/02/16/3pN7bF.jpg" alt="image"></p>
<p>通过对以上三项的跟踪分析，加上这个泄露，这个阻塞的耗时，这个涉及的内部方法名，很明显就是哪位又忘记关闭客户端连接了，赶紧改改改。</p>
<h2 id="总结">总结</h2>
<p>通过本文我们习得了 <code>go tool trace</code> 的武林秘籍，它能够跟踪捕获各种执行中的事件，例如 Goroutine 的创建/阻塞/解除阻塞，Syscall 的进入/退出/阻止，GC 事件，Heap 的大小改变，Processor 启动/停止等等。</p>
<p>希望你能够用好 Go 的两大杀器 pprof + trace 组合，此乃排查好搭档，谁用谁清楚，即使他并不万能。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner">https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner</a></li>
<li><a href="https://www.itcodemonkey.com/article/5419.html">https://www.itcodemonkey.com/article/5419.html</a></li>
<li><a href="https://making.pusher.com/go-tool-trace/">https://making.pusher.com/go-tool-trace/</a></li>
<li><a href="https://golang.org/cmd/trace/">https://golang.org/cmd/trace/</a></li>
<li><a href="https://docs.google.com/document/d/1FP5apqzBgr7ahCCgFO-yoVhk4YZrNIDNf9RybngBc14/pub">https://docs.google.com/document/d/1FP5apqzBgr7ahCCgFO-yoVhk4YZrNIDNf9RybngBc14/pub</a></li>
<li><a href="https://godoc.org/runtime/trace">https://godoc.org/runtime/trace</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>从实践到原理，带你参透 gRPC</title>
			<link>https://eddycjy.com/posts/go/talk/2019-06-29-talking-grpc/</link>
			<pubDate>Sat, 29 Jun 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2019-06-29-talking-grpc/</guid>
			<description>gRPC 在 Go 语言中大放异彩，越来越多的小伙伴在使用，最近也在公司安利了一波，希望这一篇文章能带你一览 gRPC 的巧妙之处，本文篇幅比较长，请做好阅读准备。本文目录如下：
简述 gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持。
gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。
调用模型 1、客户端（gRPC Stub）调用 A 方法，发起 RPC 调用。
2、对请求信息使用 Protobuf 进行对象序列化压缩（IDL）。
3、服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理并返回。
4、对响应结果使用 Protobuf 进行对象序列化压缩（IDL）。
5、客户端接受到服务端响应，解码请求体。回调被调用的 A 方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果。
调用方式 一、Unary RPC：一元 RPC Server type SearchService struct{} func (s *SearchService) Search(ctx context.Context, r *pb.</description>
			<content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/27/3wKfNq.png" alt="image"></p>
<p>gRPC 在 Go 语言中大放异彩，越来越多的小伙伴在使用，最近也在公司安利了一波，希望这一篇文章能带你一览 gRPC 的巧妙之处，本文篇幅比较长，请做好阅读准备。本文目录如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wMMrQ.jpg" alt="image"></p>
<h2 id="简述">简述</h2>
<p>gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持。</p>
<p>gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</p>
<h2 id="调用模型">调用模型</h2>
<p><img src="http://www.grpc.io/img/grpc_concept_diagram_00.png" alt="image"></p>
<p>1、客户端（gRPC Stub）调用 A 方法，发起 RPC 调用。</p>
<p>2、对请求信息使用 Protobuf 进行对象序列化压缩（IDL）。</p>
<p>3、服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理并返回。</p>
<p>4、对响应结果使用 Protobuf 进行对象序列化压缩（IDL）。</p>
<p>5、客户端接受到服务端响应，解码请求体。回调被调用的 A 方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果。</p>
<h2 id="调用方式">调用方式</h2>
<h3 id="一unary-rpc一元-rpc">一、Unary RPC：一元 RPC</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3wMNxU.png" alt="image"></p>
<h4 id="server">Server</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SearchService</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SearchService</span><span class="p">)</span> <span class="nf">Search</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">SearchRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">SearchResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">SearchResponse</span><span class="p">{</span><span class="nx">Response</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nf">GetRequest</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; Server&#34;</span><span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">PORT</span> <span class="p">=</span> <span class="s">&#34;9001&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">server</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>
    <span class="nx">pb</span><span class="p">.</span><span class="nf">RegisterSearchServiceServer</span><span class="p">(</span><span class="nx">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">SearchService</span><span class="p">{})</span>

    <span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">)</span>
    <span class="o">...</span>

    <span class="nx">server</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>创建 gRPC Server 对象，你可以理解为它是 Server 端的抽象对象。</li>
<li>将 SearchService（其包含需要被调用的服务端接口）注册到 gRPC Server。 的内部注册中心。这样可以在接受到请求时，通过内部的 “服务发现”，发现该服务端接口并转接进行逻辑处理。</li>
<li>创建 Listen，监听 TCP 端口。</li>
<li>gRPC Server 开始 lis.Accept，直到 Stop 或 GracefulStop。</li>
</ul>
<h4 id="client">Client</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">())</span>
    <span class="o">...</span>
    <span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="nx">client</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nf">NewSearchServiceClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">SearchRequest</span><span class="p">{</span>
        <span class="nx">Request</span><span class="p">:</span> <span class="s">&#34;gRPC&#34;</span><span class="p">,</span>
    <span class="p">})</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>创建与给定目标（服务端）的连接句柄。</li>
<li>创建 SearchService 的客户端对象。</li>
<li>发送 RPC 请求，等待同步响应，得到回调后返回响应结果。</li>
</ul>
<h3 id="二server-side-streaming-rpc服务端流式-rpc">二、Server-side streaming RPC：服务端流式 RPC</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3wMdr4.png" alt="image"></p>
<h4 id="server-1">Server</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">List</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">,</span> <span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_ListServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamResponse</span><span class="p">{</span>
            <span class="nx">Pt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span>
                <span class="o">...</span>
            <span class="p">},</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="client-1">Client</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">printLists</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">List</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">r</span><span class="p">)</span>
    <span class="o">...</span>

    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="o">...</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h3 id="三client-side-streaming-rpc客户端流式-rpc">三、Client-side streaming RPC：客户端流式 RPC</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3wMBZ9.png" alt="image"></p>
<h4 id="server-2">Server</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">Record</span><span class="p">(</span><span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_RecordServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">SendAndClose</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamResponse</span><span class="p">{</span><span class="nx">Pt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span><span class="o">...</span><span class="p">}})</span>
        <span class="p">}</span>
        <span class="o">...</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="client-2">Client</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">printRecord</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Record</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
    <span class="o">...</span>

    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">CloseAndRecv</span><span class="p">()</span>
    <span class="o">...</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h3 id="四bidirectional-streaming-rpc双向流式-rpc">四、Bidirectional streaming RPC：双向流式 RPC</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3wMrI1.png" alt="image"></p>
<h4 id="server-3">Server</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">Route</span><span class="p">(</span><span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_RouteServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamResponse</span><span class="p">{</span><span class="o">...</span><span class="p">})</span>
        <span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="o">...</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="client-3">Client</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">printRoute</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Route</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
    <span class="o">...</span>

    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
        <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="o">...</span>
    <span class="p">}</span>

    <span class="nx">stream</span><span class="p">.</span><span class="nf">CloseSend</span><span class="p">()</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h2 id="客户端与服务端是如何交互的">客户端与服务端是如何交互的</h2>
<p>在开始分析之前，我们要先 gRPC 的调用有一个初始印象。那么最简单的就是对 Client 端调用 Server 端进行抓包去剖析，看看整个过程中它都做了些什么事。如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wMgxO.jpg" alt="image"></p>
<ul>
<li>Magic</li>
<li>SETTINGS</li>
<li>HEADERS</li>
<li>DATA</li>
<li>SETTINGS</li>
<li>WINDOW_UPDATE</li>
<li>PING</li>
<li>HEADERS</li>
<li>DATA</li>
<li>HEADERS</li>
<li>WINDOW_UPDATE</li>
<li>PING</li>
</ul>
<p>我们略加整理发现共有十二个行为，是比较重要的。在开始分析之前，建议你自己先想一下，它们的作用都是什么？大胆猜测一下，带着疑问去学习效果更佳。</p>
<h3 id="行为分析">行为分析</h3>
<h4 id="magic">Magic</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3wM7JP.jpg" alt="image"></p>
<p>Magic 帧的主要作用是建立 HTTP/2 请求的前言。在 HTTP/2 中，要求两端都要发送一个连接前言，作为对所使用协议的最终确认，并确定 HTTP/2 连接的初始设置，客户端和服务端各自发送不同的连接前言。</p>
<p>而上图中的 Magic 帧是客户端的前言之一，内容为 <code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code>，以确定启用 HTTP/2 连接。</p>
<h4 id="settings">SETTINGS</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3wQPzT.jpg" alt="image"></p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wQ779.jpg" alt="image"></p>
<p>SETTINGS 帧的主要作用是设置这一个连接的参数，作用域是整个连接而并非单一的流。</p>
<p>而上图的 SETTINGS 帧都是空 SETTINGS 帧，图一是客户端连接的前言（Magic 和 SETTINGS 帧分别组成连接前言）。图二是服务端的。另外我们从图中可以看到多个 SETTINGS 帧，这是为什么呢？是因为发送完连接前言后，客户端和服务端还需要有一步互动确认的动作。对应的就是带有 ACK 标识 SETTINGS 帧。</p>
<h4 id="headers">HEADERS</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3wN2tg.jpg" alt="image"></p>
<p>HEADERS 帧的主要作用是存储和传播 HTTP 的标头信息。我们关注到 HEADERS 里有一些眼熟的信息，分别如下：</p>
<ul>
<li>method：POST</li>
<li>scheme：http</li>
<li>path：/proto.SearchService/Search</li>
<li>authority：:10001</li>
<li>content-type：application/grpc</li>
<li>user-agent：grpc-go/1.20.0-dev</li>
</ul>
<p>你会发现这些东西非常眼熟，其实都是 gRPC 的基础属性，实际上远远不止这些，只是设置了多少展示多少。例如像平时常见的 <code>grpc-timeout</code>、<code>grpc-encoding</code> 也是在这里设置的。</p>
<h4 id="data">DATA</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3wNTBV.jpg" alt="image"></p>
<p>DATA 帧的主要作用是装填主体信息，是数据帧。而在上图中，可以很明显看到我们的请求参数 gRPC 存储在里面。只需要了解到这一点就可以了。</p>
<h4 id="headers-data-headers">HEADERS, DATA, HEADERS</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3wNj39.jpg" alt="image"></p>
<p>在上图中 HEADERS 帧比较简单，就是告诉我们 HTTP 响应状态和响应的内容格式。</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wUl4g.jpg" alt="imgae"></p>
<p>在上图中 DATA 帧主要承载了响应结果的数据集，图中的 gRPC Server 就是我们 RPC 方法的响应结果。</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wUUbV.jpg" alt="image"></p>
<p>在上图中 HEADERS 帧主要承载了 gRPC 状态 和 gRPC 状态消息，图中的 <code>grpc-status</code> 和 <code>grpc-message</code> 就是我们的 gRPC 调用状态的结果。</p>
<h3 id="其它步骤">其它步骤</h3>
<h4 id="window_update">WINDOW_UPDATE</h4>
<p>主要作用是管理和流的窗口控制。通常情况下打开一个连接后，服务器和客户端会立即交换 SETTINGS 帧来确定流控制窗口的大小。默认情况下，该大小设置为约 65 KB，但可通过发出一个 WINDOW_UPDATE 帧为流控制设置不同的大小。</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wUwUU.jpg" alt="image"></p>
<h4 id="pingpong">PING/PONG</h4>
<p>主要作用是判断当前连接是否仍然可用，也常用于计算往返时间。其实也就是 PING/PONG，大家对此应该很熟。</p>
<h3 id="小结">小结</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3wU05F.png" alt="image"></p>
<ul>
<li>在建立连接之前，客户端/服务端都会发送<strong>连接前言</strong>（Magic+SETTINGS），确立协议和配置项。</li>
<li>在传输数据时，是会涉及滑动窗口（WINDOW_UPDATE）等流控策略的。</li>
<li>传播 gRPC 附加信息时，是基于 HEADERS 帧进行传播和设置；而具体的请求/响应数据是存储的 DATA 帧中的。</li>
<li>请求/响应结果会分为 HTTP 和 gRPC 状态响应两种类型。</li>
<li>客户端发起 PING，服务端就会回应 PONG，反之亦可。</li>
</ul>
<p>这块 gRPC 的基础使用，你可以看看我另外的 <a href="https://github.com/EDDYCJY/blog#grpc%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95">《gRPC 入门系列》</a>，相信对你一定有帮助。</p>
<h2 id="浅谈理解">浅谈理解</h2>
<h3 id="服务端">服务端</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3wUDC4.png" alt="image"></p>
<p>为什么四行代码，就能够起一个 gRPC Server，内部做了什么逻辑。你有想过吗？接下来我们一步步剖析，看看里面到底是何方神圣。</p>
<h3 id="一初始化">一、初始化</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// grpc.NewServer()
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewServer</span><span class="p">(</span><span class="nx">opt</span> <span class="o">...</span><span class="nx">ServerOption</span><span class="p">)</span> <span class="o">*</span><span class="nx">Server</span> <span class="p">{</span>
	<span class="nx">opts</span> <span class="o">:=</span> <span class="nx">defaultServerOptions</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">o</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opt</span> <span class="p">{</span>
		<span class="nf">o</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">opts</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{</span>
		<span class="nx">lis</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">]</span><span class="kt">bool</span><span class="p">),</span>
		<span class="nx">opts</span><span class="p">:</span>   <span class="nx">opts</span><span class="p">,</span>
		<span class="nx">conns</span><span class="p">:</span>  <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">io</span><span class="p">.</span><span class="nx">Closer</span><span class="p">]</span><span class="kt">bool</span><span class="p">),</span>
		<span class="nx">m</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">service</span><span class="p">),</span>
		<span class="nx">quit</span><span class="p">:</span>   <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
		<span class="nx">done</span><span class="p">:</span>   <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
		<span class="nx">czData</span><span class="p">:</span> <span class="nb">new</span><span class="p">(</span><span class="nx">channelzData</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">cv</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">mu</span><span class="p">)</span>
	<span class="o">...</span>

	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><p>这块比较简单，主要是实例 grpc.Server 并进行初始化动作。涉及如下：</p>
<ul>
<li>lis：监听地址列表。</li>
<li>opts：服务选项，这块包含 Credentials、Interceptor 以及一些基础配置。</li>
<li>conns：客户端连接句柄列表。</li>
<li>m：服务信息映射。</li>
<li>quit：退出信号。</li>
<li>done：完成信号。</li>
<li>czData：用于存储 ClientConn，addrConn 和 Server 的 channelz 相关数据。</li>
<li>cv：当优雅退出时，会等待这个信号量，直到所有 RPC 请求都处理并断开才会继续处理。</li>
</ul>
<h3 id="二注册">二、注册</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">pb</span><span class="p">.</span><span class="nf">RegisterSearchServiceServer</span><span class="p">(</span><span class="nx">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">SearchService</span><span class="p">{})</span>
</code></pre></div><h4 id="步骤一service-api-interface">步骤一：Service API interface</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// search.pb.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SearchServiceServer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Search</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">*</span><span class="nx">SearchRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">SearchResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">RegisterSearchServiceServer</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">srv</span> <span class="nx">SearchServiceServer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">RegisterService</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_SearchService_serviceDesc</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>还记得我们平时编写的 Protobuf 吗？在生成出来的 <code>.pb.go</code> 文件中，会定义出 Service APIs interface 的具体实现约束。而我们在 gRPC Server 进行注册时，会传入应用 Service 的功能接口实现，此时生成的 <code>RegisterServer</code> 方法就会保证两者之间的一致性。</p>
<h4 id="步骤二service-api-idl">步骤二：Service API IDL</h4>
<p>你想乱传糊弄一下？不可能的，请乖乖定义与 Protobuf 一致的接口方法。但是那个 <code>&amp;_SearchService_serviceDesc</code> 又有什么作用呢？代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// search.pb.go
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_SearchService_serviceDesc</span> <span class="p">=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">ServiceDesc</span><span class="p">{</span>
	<span class="nx">ServiceName</span><span class="p">:</span> <span class="s">&#34;proto.SearchService&#34;</span><span class="p">,</span>
	<span class="nx">HandlerType</span><span class="p">:</span> <span class="p">(</span><span class="o">*</span><span class="nx">SearchServiceServer</span><span class="p">)(</span><span class="kc">nil</span><span class="p">),</span>
	<span class="nx">Methods</span><span class="p">:</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">MethodDesc</span><span class="p">{</span>
		<span class="p">{</span>
			<span class="nx">MethodName</span><span class="p">:</span> <span class="s">&#34;Search&#34;</span><span class="p">,</span>
			<span class="nx">Handler</span><span class="p">:</span>    <span class="nx">_SearchService_Search_Handler</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="nx">Streams</span><span class="p">:</span>  <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">StreamDesc</span><span class="p">{},</span>
	<span class="nx">Metadata</span><span class="p">:</span> <span class="s">&#34;search.proto&#34;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>这看上去像服务的描述代码，用来向内部表述 “我” 都有什么。涉及如下:</p>
<ul>
<li>ServiceName：服务名称</li>
<li>HandlerType：服务接口，用于检查用户提供的实现是否满足接口要求</li>
<li>Methods：一元方法集，注意结构内的 <code>Handler</code> 方法，其对应最终的 RPC 处理方法，在执行 RPC 方法的阶段会使用。</li>
<li>Streams：流式方法集</li>
<li>Metadata：元数据，是一个描述数据属性的东西。在这里主要是描述 <code>SearchServiceServer</code> 服务</li>
</ul>
<h4 id="步骤三register-service">步骤三：Register Service</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">register</span><span class="p">(</span><span class="nx">sd</span> <span class="o">*</span><span class="nx">ServiceDesc</span><span class="p">,</span> <span class="nx">ss</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="o">...</span>
	<span class="nx">srv</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">service</span><span class="p">{</span>
		<span class="nx">server</span><span class="p">:</span> <span class="nx">ss</span><span class="p">,</span>
		<span class="nx">md</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">MethodDesc</span><span class="p">),</span>
		<span class="nx">sd</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">StreamDesc</span><span class="p">),</span>
		<span class="nx">mdata</span><span class="p">:</span>  <span class="nx">sd</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">Methods</span> <span class="p">{</span>
		<span class="nx">d</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sd</span><span class="p">.</span><span class="nx">Methods</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">srv</span><span class="p">.</span><span class="nx">md</span><span class="p">[</span><span class="nx">d</span><span class="p">.</span><span class="nx">MethodName</span><span class="p">]</span> <span class="p">=</span> <span class="nx">d</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">Streams</span> <span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">sd</span><span class="p">.</span><span class="nx">ServiceName</span><span class="p">]</span> <span class="p">=</span> <span class="nx">srv</span>
<span class="p">}</span>
</code></pre></div><p>在最后一步中，我们会将先前的服务接口信息、服务描述信息给注册到内部 <code>service</code> 去，以便于后续实际调用的使用。涉及如下：</p>
<ul>
<li>server：服务的接口信息</li>
<li>md：一元服务的 RPC 方法集</li>
<li>sd：流式服务的 RPC 方法集</li>
<li>mdata：metadata，元数据</li>
</ul>
<h4 id="小结-1">小结</h4>
<p>在这一章节中，主要介绍的是 gRPC Server 在启动前的整理和注册行为，看上去很简单，但其实一切都是为了后续的实际运行的预先准备。因此我们整理一下思路，将其串联起来看看，如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wUgDx.png" alt="image"></p>
<h3 id="三监听">三、监听</h3>
<p>接下来到了整个流程中，最重要也是大家最关注的监听/处理阶段，核心代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="kd">var</span> <span class="nx">tempDelay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">rawConn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lis</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">ne</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="kd">interface</span> <span class="p">{</span>
				<span class="nf">Temporary</span><span class="p">()</span> <span class="kt">bool</span>
			<span class="p">});</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">ne</span><span class="p">.</span><span class="nf">Temporary</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">tempDelay</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="p">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="o">*=</span> <span class="mi">2</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">max</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">;</span> <span class="nx">tempDelay</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="p">=</span> <span class="nx">max</span>
				<span class="p">}</span>
				<span class="o">...</span>
				<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">tempDelay</span><span class="p">)</span>
				<span class="k">select</span> <span class="p">{</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
				<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">s</span><span class="p">.</span><span class="nx">quit</span><span class="p">:</span>
					<span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
					<span class="k">return</span> <span class="kc">nil</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="o">...</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="nx">tempDelay</span> <span class="p">=</span> <span class="mi">0</span>

		<span class="nx">s</span><span class="p">.</span><span class="nx">serveWG</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">handleRawConn</span><span class="p">(</span><span class="nx">rawConn</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">serveWG</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Serve 会根据外部传入的 Listener 不同而调用不同的监听模式，这也是 <code>net.Listener</code> 的魅力，灵活性和扩展性会比较高。而在 gRPC Server 中最常用的就是 <code>TCPConn</code>，基于 TCP Listener 去做。接下来我们一起看看具体的处理逻辑，如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wUI8H.png" alt="image"></p>
<ul>
<li>循环处理连接，通过 <code>lis.Accept</code> 取出连接，如果队列中没有需处理的连接时，会形成阻塞等待。</li>
<li>若 <code>lis.Accept</code> 失败，则触发休眠机制，若为第一次失败那么休眠 5ms，否则翻倍，再次失败则不断翻倍直至上限休眠时间 1s，而休眠完毕后就会尝试去取下一个 “它”。</li>
<li>若 <code>lis.Accept</code> 成功，则重置休眠的时间计数和启动一个新的 goroutine 调用 <code>handleRawConn</code> 方法去执行/处理新的请求，也就是大家很喜欢说的 “每一个请求都是不同的 goroutine 在处理”。</li>
<li>在循环过程中，包含了 “退出” 服务的场景，主要是硬关闭和优雅重启服务两种情况。</li>
</ul>
<h2 id="客户端">客户端</h2>
<p><img src="https://s2.ax1x.com/2020/02/27/3wUHKI.png" alt="image"></p>
<h3 id="一创建拨号连接">一、创建拨号连接</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// grpc.Dial(&#34;:&#34;+PORT, grpc.WithInsecure())
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">DialOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ClientConn</span><span class="p">{</span>
		<span class="nx">target</span><span class="p">:</span>            <span class="nx">target</span><span class="p">,</span>
		<span class="nx">csMgr</span><span class="p">:</span>             <span class="o">&amp;</span><span class="nx">connectivityStateManager</span><span class="p">{},</span>
		<span class="nx">conns</span><span class="p">:</span>             <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">addrConn</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}),</span>
		<span class="nx">dopts</span><span class="p">:</span>             <span class="nf">defaultDialOptions</span><span class="p">(),</span>
		<span class="nx">blockingpicker</span><span class="p">:</span>    <span class="nf">newPickerWrapper</span><span class="p">(),</span>
		<span class="nx">czData</span><span class="p">:</span>            <span class="nb">new</span><span class="p">(</span><span class="nx">channelzData</span><span class="p">),</span>
		<span class="nx">firstResolveEvent</span><span class="p">:</span> <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="nf">chainUnaryClientInterceptors</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>
	<span class="nf">chainStreamClientInterceptors</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>

	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p><code>grpc.Dial</code> 方法实际上是对于 <code>grpc.DialContext</code> 的封装，区别在于 <code>ctx</code> 是直接传入 <code>context.Background</code>。其主要功能是<strong>创建</strong>与给定目标的客户端连接，其承担了以下职责：</p>
<ul>
<li>初始化 ClientConn</li>
<li>初始化（基于进程 LB）负载均衡配置</li>
<li>初始化 channelz</li>
<li>初始化重试规则和客户端一元/流式拦截器</li>
<li>初始化协议栈上的基础信息</li>
<li>相关 context 的超时控制</li>
<li>初始化并解析地址信息</li>
<li>创建与服务端之间的连接</li>
</ul>
<h4 id="连没连">连没连</h4>
<p>之前听到有的人说调用 <code>grpc.Dial</code> 后客户端就已经与服务端建立起了连接，但这对不对呢？我们先鸟瞰全貌，看看正在跑的 goroutine。如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wUXa8.jpg" alt="image"></p>
<p>我们可以有几个核心方法一直在等待/处理信号，通过分析底层源码可得知。涉及如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">connect</span><span class="p">()</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">resetTransport</span><span class="p">()</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">createTransport</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">copts</span> <span class="nx">transport</span><span class="p">.</span><span class="nx">ConnectOptions</span><span class="p">,</span> <span class="nx">connectDeadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">getReadyTransport</span><span class="p">()</span>
</code></pre></div><p>在这里主要分析 goroutine 提示的 <code>resetTransport</code> 方法，看看都做了啥。核心代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">resetTransport</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="o">...</span>
		<span class="nx">connectDeadline</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">dialDuration</span><span class="p">)</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">Connecting</span><span class="p">)</span>
		<span class="nx">newTr</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">reconnect</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ac</span><span class="p">.</span><span class="nf">tryAllAddrs</span><span class="p">(</span><span class="nx">addrs</span><span class="p">,</span> <span class="nx">connectDeadline</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span><span class="p">)</span>
			<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">backoffFor</span><span class="p">)</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
				<span class="o">...</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
			<span class="nx">newTr</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="o">...</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">healthcheckManagingState</span> <span class="p">{</span>
			<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="o">...</span>

		<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在该方法中会不断地去尝试创建连接，若成功则结束。否则不断地根据 <code>Backoff</code> 算法的重试机制去尝试创建连接，直到成功为止。从结论上来讲，单纯调用 <code>DialContext</code> 是异步建立连接的，也就是并不是马上生效，处于 <code>Connecting</code> 状态，而正式下要到达 <code>Ready</code> 状态才可用。</p>
<h4 id="真的连了吗">真的连了吗</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3wakZV.jpg" alt="image"></p>
<p>在抓包工具上提示一个包都没有，那么这算真正连接了吗？我认为这是一个表述问题，我们应该尽可能的严谨。如果你真的想通过 <code>DialContext</code> 方法就打通与服务端的连接，则需要调用 <code>WithBlock</code> 方法，虽然会导致阻塞等待，但最终连接会到达 <code>Ready</code> 状态（握手成功）。如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3waJiD.jpg" alt="image"></p>
<h3 id="二实例化-service-api">二、实例化 Service API</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SearchServiceClient</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Search</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">SearchRequest</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">SearchResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">searchServiceClient</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewSearchServiceClient</span><span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nx">SearchServiceClient</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">searchServiceClient</span><span class="p">{</span><span class="nx">cc</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这块就是实例 Service API interface，比较简单。</p>
<h3 id="三调用">三、调用</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// search.pb.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">searchServiceClient</span><span class="p">)</span> <span class="nf">Search</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">SearchRequest</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">SearchResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">out</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">SearchResponse</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;/proto.SearchService/Search&#34;</span><span class="p">,</span> <span class="nx">in</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">out</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>proto 生成的 RPC 方法更像是一个包装盒，把需要的东西放进去，而实际上调用的还是 <code>grpc.invoke</code> 方法。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">invoke</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">cs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newClientStream</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">unaryStreamDesc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">reply</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>通过概览，可以关注到三块调用。如下：</p>
<ul>
<li>newClientStream：获取传输层 Trasport 并组合封装到 ClientStream 中返回，在这块会涉及负载均衡、超时控制、 Encoding、 Stream 的动作，与服务端基本一致的行为。</li>
<li>cs.SendMsg：发送 RPC 请求出去，但其并不承担等待响应的功能。</li>
<li>cs.RecvMsg：阻塞等待接受到的 RPC 方法响应结果。</li>
</ul>
<h4 id="连接">连接</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// clientconn.go
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">getTransport</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">failfast</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">transport</span><span class="p">.</span><span class="nx">ClientTransport</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">),</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">,</span> <span class="nx">done</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">blockingpicker</span><span class="p">.</span><span class="nf">pick</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">failfast</span><span class="p">,</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">PickOptions</span><span class="p">{</span>
		<span class="nx">FullMethodName</span><span class="p">:</span> <span class="nx">method</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">toRPCErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">done</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>在 <code>newClientStream</code> 方法中，我们通过 <code>getTransport</code> 方法获取了 Transport 层中抽象出来的 ClientTransport 和 ServerTransport，实际上就是获取一个连接给后续 RPC 调用传输使用。</p>
<h3 id="四关闭连接">四、关闭连接</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// conn.Close()
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">cancel</span><span class="p">()</span>
    <span class="o">...</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">csMgr</span><span class="p">.</span><span class="nf">updateState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span><span class="p">)</span>
    <span class="o">...</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">blockingpicker</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">rWrapper</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rWrapper</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">bWrapper</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">bWrapper</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">ac</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">conns</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nf">tearDown</span><span class="p">(</span><span class="nx">ErrClientConnClosing</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">IsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="o">...</span>
		<span class="nx">channelz</span><span class="p">.</span><span class="nf">AddTraceEvent</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="nx">ted</span><span class="p">)</span>
		<span class="nx">channelz</span><span class="p">.</span><span class="nf">RemoveEntry</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>该方法会取消 ClientConn 上下文，同时关闭所有底层传输。涉及如下：</p>
<ul>
<li>Context Cancel</li>
<li>清空并关闭客户端连接</li>
<li>清空并关闭解析器连接</li>
<li>清空并关闭负载均衡连接</li>
<li>添加跟踪引用</li>
<li>移除当前通道信息</li>
</ul>
<h2 id="qa">Q&amp;A</h2>
<h3 id="1-grpc-metadata-是通过什么传输">1. gRPC Metadata 是通过什么传输？</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3waaQA.jpg" alt="image"></p>
<h3 id="2-调用-grpcdial-会真正的去连接服务端吗">2. 调用 grpc.Dial 会真正的去连接服务端吗？</h3>
<p>会，但是是异步连接的，连接状态为正在连接。但如果你设置了 <code>grpc.WithBlock</code> 选项，就会阻塞等待（等待握手成功）。另外你需要注意，当未设置 <code>grpc.WithBlock</code> 时，ctx 超时控制对其无任何效果。</p>
<h3 id="3-调用-clientconn-不-close-会导致泄露吗">3. 调用 ClientConn 不 Close 会导致泄露吗？</h3>
<p>会，除非你的客户端不是常驻进程，那么在应用结束时会被动地回收资源。但如果是常驻进程，你又真的忘记执行 <code>Close</code> 语句，会造成的泄露。如下图：</p>
<p><strong>3.1. 客户端</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wawLt.jpg" alt="image"></p>
<p><strong>3.2. 服务端</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wa6Jg.png" alt="image"></p>
<p><strong>3.3. TCP</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/27/3waWyn.jpg" alt="image"></p>
<h3 id="4-不控制超时调用的话会出现什么问题">4. 不控制超时调用的话，会出现什么问题？</h3>
<p>短时间内不会出现问题，但是会不断积蓄泄露，积蓄到最后当然就是服务无法提供响应了。如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wafLq.jpg" alt="image"></p>
<h3 id="5-为什么默认的拦截器不可以传多个">5. 为什么默认的拦截器不可以传多个？</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chainUnaryClientInterceptors</span><span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">interceptors</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">chainUnaryInts</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">unaryInt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">interceptors</span> <span class="p">=</span> <span class="nb">append</span><span class="p">([]</span><span class="nx">UnaryClientInterceptor</span><span class="p">{</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">unaryInt</span><span class="p">},</span> <span class="nx">interceptors</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">chainedInt</span> <span class="nx">UnaryClientInterceptor</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">interceptors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">chainedInt</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">interceptors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">chainedInt</span> <span class="p">=</span> <span class="nx">interceptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">chainedInt</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">invoker</span> <span class="nx">UnaryInvoker</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">interceptors</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nf">getChainUnaryInvoker</span><span class="p">(</span><span class="nx">interceptors</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">invoker</span><span class="p">),</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">unaryInt</span> <span class="p">=</span> <span class="nx">chainedInt</span>
<span class="p">}</span>
</code></pre></div><p>当存在多个拦截器时，取的就是第一个拦截器。因此结论是允许传多个，但并没有用。</p>
<h3 id="6-真的需要用到多个拦截器的话怎么办">6. 真的需要用到多个拦截器的话，怎么办？</h3>
<p>可以使用 <a href="https://github.com/grpc-ecosystem/go-grpc-middleware">go-grpc-middleware</a> 提供的 <code>grpc.UnaryInterceptor</code> 和 <code>grpc.StreamInterceptor</code> 链式方法，方便快捷省心。</p>
<p>单单会用还不行，我们再深剖一下，看看它是怎么实现的。核心代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChainUnaryClient</span><span class="p">(</span><span class="nx">interceptors</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryClientInterceptor</span><span class="p">)</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryClientInterceptor</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">interceptors</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">lastI</span> <span class="o">:=</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">cc</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">invoker</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryInvoker</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="p">(</span>
				<span class="nx">chainHandler</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">UnaryInvoker</span>
				<span class="nx">curI</span>         <span class="kt">int</span>
			<span class="p">)</span>

			<span class="nx">chainHandler</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">currentCtx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">currentMethod</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">currentReq</span><span class="p">,</span> <span class="nx">currentRepl</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">currentConn</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">currentOpts</span> <span class="o">...</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">CallOption</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">curI</span> <span class="o">==</span> <span class="nx">lastI</span> <span class="p">{</span>
					<span class="k">return</span> <span class="nf">invoker</span><span class="p">(</span><span class="nx">currentCtx</span><span class="p">,</span> <span class="nx">currentMethod</span><span class="p">,</span> <span class="nx">currentReq</span><span class="p">,</span> <span class="nx">currentRepl</span><span class="p">,</span> <span class="nx">currentConn</span><span class="p">,</span> <span class="nx">currentOpts</span><span class="o">...</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">curI</span><span class="o">++</span>
				<span class="nx">err</span> <span class="o">:=</span> <span class="nx">interceptors</span><span class="p">[</span><span class="nx">curI</span><span class="p">](</span><span class="nx">currentCtx</span><span class="p">,</span> <span class="nx">currentMethod</span><span class="p">,</span> <span class="nx">currentReq</span><span class="p">,</span> <span class="nx">currentRepl</span><span class="p">,</span> <span class="nx">currentConn</span><span class="p">,</span> <span class="nx">chainHandler</span><span class="p">,</span> <span class="nx">currentOpts</span><span class="o">...</span><span class="p">)</span>
				<span class="nx">curI</span><span class="o">--</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">}</span>

			<span class="k">return</span> <span class="nx">interceptors</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">reply</span><span class="p">,</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">chainHandler</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>当拦截器数量大于 1 时，从 <code>interceptors[1]</code> 开始递归，每一个递归的拦截器 <code>interceptors[i]</code> 会不断地执行，最后才真正的去执行 <code>handler</code> 方法。同时也经常有人会问拦截器的执行顺序是什么，通过这段代码你得出结论了吗？</p>
<h3 id="7-频繁创建-clientconn-有什么问题">7. 频繁创建 ClientConn 有什么问题？</h3>
<p>这个问题我们可以反向验证一下，假设不公用 ClientConn 看看会怎么样？如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkSearch</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">GetClientConn</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">b</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;GetClientConn err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">Search</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">conn</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">b</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Search err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>    ... connection error: desc = &quot;transport: Error while dialing dial tcp :10001: socket: too many open files&quot;
    ... connection error: desc = &quot;transport: Error while dialing dial tcp :10001: socket: too many open files&quot;
    ... connection error: desc = &quot;transport: Error while dialing dial tcp :10001: socket: too many open files&quot;
    ... connection error: desc = &quot;transport: Error while dialing dial tcp :10001: socket: too many open files&quot;
FAIL
exit status 1
</code></pre><p>当你的应用场景是存在高频次同时生成/调用 ClientConn 时，可能会导致系统的文件句柄占用过多。这种情况下你可以变更应用程序生成/调用 ClientConn 的模式，又或是池化它，这块可以参考 <a href="github.com/processout/grpc-go-pool">grpc-go-pool</a> 项目。</p>
<h3 id="8-客户端请求失败后会默认重试吗">8. 客户端请求失败后会默认重试吗？</h3>
<p>会不断地进行重试，直到上下文取消。而重试时间方面采用 backoff 算法作为的重连机制，默认的最大重试时间间隔是 120s。</p>
<h3 id="9-为什么要用-http2-作为传输协议">9. 为什么要用 HTTP/2 作为传输协议？</h3>
<p>许多客户端要通过 HTTP 代理来访问网络，gRPC 全部用 HTTP/2 实现，等到代理开始支持 HTTP/2 就能透明转发 gRPC 的数据。不光如此，负责负载均衡、访问控制等等的反向代理都能无缝兼容 gRPC，比起自己设计 wire protocol 的 Thrift，这样做科学不少。@ctiller @滕亦飞</p>
<h3 id="10-在-kubernetes-中-grpc-负载均衡有问题">10. 在 Kubernetes 中 gRPC 负载均衡有问题？</h3>
<p>gRPC 的 RPC 协议是基于 HTTP/2 标准实现的，HTTP/2 的一大特性就是不需要像 HTTP/1.1 一样，每次发出请求都要重新建立一个新连接，而是会复用原有的连接。</p>
<p>所以这将导致 kube-proxy 只有在连接建立时才会做负载均衡，而在这之后的每一次 RPC 请求都会利用原本的连接，那么实际上后续的每一次的 RPC 请求都跑到了同一个地方。</p>
<p>注：使用 k8s service 做负载均衡的情况下</p>
<h2 id="总结">总结</h2>
<ul>
<li>gRPC 基于 HTTP/2 + Protobuf。</li>
<li>gRPC 有四种调用方式，分别是一元、服务端/客户端流式、双向流式。</li>
<li>gRPC 的附加信息都会体现在 HEADERS 帧，数据在 DATA 帧上。</li>
<li>Client 请求若使用 grpc.Dial 默认是异步建立连接，当时状态为 Connecting。</li>
<li>Client 请求若需要同步则调用 WithBlock()，完成状态为 Ready。</li>
<li>Server 监听是循环等待连接，若没有则休眠，最大休眠时间 1s；若接收到新请求则起一个新的 goroutine 去处理。</li>
<li>grpc.ClientConn 不关闭连接，会导致 goroutine 和 Memory 等泄露。</li>
<li>任何内/外调用如果不加超时控制，会出现泄漏和客户端不断重试。</li>
<li>特定场景下，如果不对 grpc.ClientConn 加以调控，会影响调用。</li>
<li>拦截器如果不用 go-grpc-middleware 链式处理，会覆盖。</li>
<li>在选择 gRPC 的负载均衡模式时，需要谨慎。</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://doc.oschina.net/grpc">http://doc.oschina.net/grpc</a></li>
<li><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md">https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md</a></li>
<li><a href="https://juejin.im/post/5b88a4f56fb9a01a0b31a67e">https://juejin.im/post/5b88a4f56fb9a01a0b31a67e</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html">https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html</a></li>
<li><a href="https://github.com/grpc/grpc-go/issues/1953">https://github.com/grpc/grpc-go/issues/1953</a></li>
<li><a href="https://www.zhihu.com/question/52670041">https://www.zhihu.com/question/52670041</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载四」gRPC&#43;gRPC Gateway 能不能不用证书？</title>
			<link>https://eddycjy.com/posts/go/grpc-gateway/2019-06-22-grpc-gateway-tls/</link>
			<pubDate>Sat, 22 Jun 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc-gateway/2019-06-22-grpc-gateway-tls/</guid>
			<description>如果你以前有涉猎过 gRPC+gRPC Gateway 这两个组件，你肯定会遇到这个问题，就是 “为什么非得开 TLS，才能够实现同端口双流量，能不能不开？” 又或是 “我不想用证书就实现这些功能，行不行？”。我被无数的人问过无数次这些问题，也说服过很多人，但说服归说服，不代表放弃。前年不行，不代表今年不行，在今天我希望分享来龙去脉和具体的实现方式给你。
过去 为什么 h2 不行 因为 net/http2 仅支持 &amp;ldquo;h2&amp;rdquo; 标识，而 &amp;ldquo;h2&amp;rdquo; 标识 HTTP/2 必须使用传输层安全性（TLS）的协议，此标识符用于 TLS 应用层协议协商字段以及识别 HTTP/2 over TLS。
简单来讲，也就 net/http2 必须使用 TLS 来交互。通俗来讲就要用证书，那么理所当然，也就无法支持非 TLS 的情况了。
寻找 h2c 那这条路不行，我们再想想别的路？那就是 HTTP/2 规范中的 &amp;ldquo;h2c&amp;rdquo; 标识了，&amp;ldquo;h2c&amp;rdquo; 标识允许通过明文 TCP 运行 HTTP/2 的协议，此标识符用于 HTTP/1.1 升级标头字段以及标识 HTTP/2 over TCP。
但是这条路，早在 2015 年就已经有在 issue 中进行讨论，当时 @bradfitz 明确表示 “不打算支持 h2c，对仅支持 TLS 的情况非常满意，一年后再问我一次”，原文回复如下：
 We do not plan to support h2c. I don&amp;rsquo;t want to receive bug reports from users who get bitten by transparent proxies messing with h2c.</description>
			<content type="html"><![CDATA[<p>如果你以前有涉猎过 gRPC+gRPC Gateway 这两个组件，你肯定会遇到这个问题，就是 <strong>“为什么非得开 TLS，才能够实现同端口双流量，能不能不开？”</strong> 又或是 <strong>“我不想用证书就实现这些功能，行不行？”</strong>。我被无数的人问过无数次这些问题，也说服过很多人，但说服归说服，不代表放弃。前年不行，不代表今年不行，在今天我希望分享来龙去脉和具体的实现方式给你。</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLBAx.png" alt="image"></p>
<h2 id="过去">过去</h2>
<h3 id="为什么-h2-不行">为什么 h2 不行</h3>
<p>因为 <code>net/http2</code> 仅支持 &ldquo;h2&rdquo; 标识，而 &ldquo;h2&rdquo; 标识 HTTP/2 必须使用传输层安全性（TLS）的协议，此标识符用于 TLS 应用层协议协商字段以及识别 HTTP/2 over TLS。</p>
<p>简单来讲，也就 <code>net/http2</code> 必须使用 TLS 来交互。通俗来讲就要用证书，那么理所当然，也就无法支持非 TLS 的情况了。</p>
<h3 id="寻找-h2c">寻找 h2c</h3>
<p>那这条路不行，我们再想想别的路？那就是 HTTP/2 规范中的 &ldquo;h2c&rdquo; 标识了，&ldquo;h2c&rdquo; 标识允许通过明文 TCP 运行 HTTP/2 的协议，此标识符用于 HTTP/1.1 升级标头字段以及标识 HTTP/2 over TCP。</p>
<p>但是这条路，早在 2015 年就已经有在 <a href="https://github.com/golang/go/issues/13128#issuecomment-153193762">issue</a> 中进行讨论，当时 @bradfitz 明确表示 “不打算支持 h2c，对仅支持 TLS 的情况非常满意，一年后再问我一次”，原文回复如下：</p>
<blockquote>
<p>We do not plan to support h2c. I don&rsquo;t want to receive bug reports from users who get bitten by transparent proxies messing with h2c. Also, until there&rsquo;s widespread browser support, it&rsquo;s not interesting. I am also not interested in being the chicken or the egg to get browser support going. I&rsquo;m very happy with the TLS-only situation, and things like <a href="https://LetsEncrypt.org/">https://LetsEncrypt.org/</a> will make TLS much easier (and automatic) soon.</p>
</blockquote>
<blockquote>
<p>Ask me again in one year.</p>
</blockquote>
<h3 id="琢磨其他方式">琢磨其他方式</h3>
<h4 id="使用-cmux">使用 cmux</h4>
<p>基于多路复用器 <a href="https://github.com/soheilhy/cmux">soheilhy/cmux</a> 的另类实现 <a href="https://github.com/Stoakes/grpc-gateway-example">Stoakes/grpc-gateway-example</a>。若对 <code>cmux</code> 的实现方式感兴趣，还可以看看 <a href="https://blog.dgraph.io/post/cmux/">《Golang: Run multiple services on one port》</a>。</p>
<h4 id="使用第三方-h2">使用第三方 h2</h4>
<ul>
<li><a href="https://github.com/veqryn/h2c">veqryn/h2c</a></li>
</ul>
<p>这种属于自己实现了 h2c 的逻辑，以此达到效果。</p>
<h2 id="现在">现在</h2>
<p>经过社区的不断讨论，最后在 2018 年 6 月，代表 &ldquo;h2c&rdquo; 标志的 <code>golang.org/x/net/http2/h2c</code> 标准库正式合并进来，自此我们就可以使用官方标准库（h2c），这个标准库实现了 HTTP/2 的未加密模式，因此我们就可以利用该标准库在同个端口上既提供 HTTP/1.1 又提供 HTTP/2 的功能了。</p>
<h3 id="使用标准库-h2c">使用标准库 h2c</h3>
<pre><code>import (
	...

	&quot;golang.org/x/net/http2&quot;
	&quot;golang.org/x/net/http2/h2c&quot;
	&quot;google.golang.org/grpc&quot;

	&quot;github.com/grpc-ecosystem/grpc-gateway/runtime&quot;

	pb &quot;github.com/EDDYCJY/go-grpc-example/proto&quot;
)

...

func grpcHandlerFunc(grpcServer *grpc.Server, otherHandler http.Handler) http.Handler {
	return h2c.NewHandler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.ProtoMajor == 2 &amp;&amp; strings.Contains(r.Header.Get(&quot;Content-Type&quot;), &quot;application/grpc&quot;) {
			grpcServer.ServeHTTP(w, r)
		} else {
			otherHandler.ServeHTTP(w, r)
		}
	}), &amp;http2.Server{})
}

func main() {
	server := grpc.NewServer()

	pb.RegisterSearchServiceServer(server, &amp;SearchService{})

	mux := http.NewServeMux()
	gwmux := runtime.NewServeMux()
	dopts := []grpc.DialOption{grpc.WithInsecure()}

	err := pb.RegisterSearchServiceHandlerFromEndpoint(context.Background(), gwmux, &quot;localhost:&quot;+PORT, dopts)
	...
	mux.Handle(&quot;/&quot;, gwmux)
	http.ListenAndServe(&quot;:&quot;+PORT, grpcHandlerFunc(server, mux))
}
</code></pre><p>我们可以看到关键之处在于调用了 <code>h2c.NewHandler</code> 方法进行了特殊处理，<code>h2c.NewHandler</code> 会返回一个 <code>http.handler</code>，主要的内部逻辑是拦截了所有 <code>h2c</code> 流量，然后根据不同的请求流量类型将其劫持并重定向到相应的 <code>Hander</code> 中去处理。</p>
<h3 id="验证">验证</h3>
<h4 id="http11">HTTP/1.1</h4>
<pre><code>$ curl -X GET 'http://127.0.0.1:9005/search?request=EDDYCJY'
{&quot;response&quot;:&quot;EDDYCJY&quot;}
</code></pre><h4 id="http2grpc">HTTP/2(gRPC)</h4>
<pre><code>...
func main() {
	conn, err := grpc.Dial(&quot;:&quot;+PORT, grpc.WithInsecure())
	...
	client := pb.NewSearchServiceClient(conn)
	resp, err := client.Search(context.Background(), &amp;pb.SearchRequest{
		Request: &quot;gRPC&quot;,
	})
}
</code></pre><p>输出结果：</p>
<pre><code>$ go run main.go
2019/06/21 20:04:09 resp: gRPC h2c Server
</code></pre><h2 id="总结">总结</h2>
<p>在本文中我介绍了大致的前因后果，且介绍了几种解决方法，我建议你选择官方的 <code>h2c</code> 标准库去实现这个功能，也简单。在最后，不管你是否曾经为这个问题烦恼过许久，又或者正在纠结，都希望这篇文章能够帮到你。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/golang/go/issues/13128">https://github.com/golang/go/issues/13128</a></li>
<li><a href="https://github.com/golang/go/issues/14141">https://github.com/golang/go/issues/14141</a></li>
<li><a href="https://github.com/golang/net/commit/c4299a1a0d8524c11563db160fbf9bddbceadb21">https://github.com/golang/net/commit/c4299a1a0d8524c11563db160fbf9bddbceadb21</a></li>
<li><a href="https://go-review.googlesource.com/c/net/+/112997/">https://go-review.googlesource.com/c/net/+/112997/</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go1.12 defer 会有性能损耗，尽量不要用？</title>
			<link>https://eddycjy.com/posts/go/talk/2019-06-16-defer-loss/</link>
			<pubDate>Sun, 16 Jun 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2019-06-16-defer-loss/</guid>
			<description>上个月在 @polaris @轩脉刃 的全栈技术群里看到一个小伙伴问 “说 defer 在栈退出时执行，会有性能损耗，尽量不要用，这个怎么解？”。
恰好前段时间写了一篇 《深入理解 Go defer》 去详细剖析 defer 关键字。那么这一次简单结合前文对这个问题进行探讨一波，希望对你有所帮助，但在此之前希望你花几分钟，自己思考一下答案，再继续往下看。
测试 func DoDefer(key, value string) { defer func(key, value string) { _ = key + value }(key, value) } func DoNotDefer(key, value string) { _ = key + value } 基准测试：
func BenchmarkDoDefer(b *testing.B) { for i := 0; i &amp;lt; b.N; i++ { DoDefer(&amp;#34;煎鱼&amp;#34;, &amp;#34;https://github.com/EDDYCJY/blog&amp;#34;) } } func BenchmarkDoNotDefer(b *testing.B) { for i := 0; i &amp;lt; b.</description>
			<content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/27/3wuUYV.jpg" alt="image"></p>
<p>上个月在 @polaris @轩脉刃 的全栈技术群里看到一个小伙伴问 <strong>“说 defer 在栈退出时执行，会有性能损耗，尽量不要用，这个怎么解？”</strong>。</p>
<p>恰好前段时间写了一篇 <a href="https://segmentfault.com/a/1190000019303572">《深入理解 Go defer》</a> 去详细剖析 <code>defer</code> 关键字。那么这一次简单结合前文对这个问题进行探讨一波，希望对你有所帮助，但在此之前希望你花几分钟，自己思考一下答案，再继续往下看。</p>
<h2 id="测试">测试</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">DoDefer</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">_</span> <span class="p">=</span> <span class="nx">key</span> <span class="o">+</span> <span class="nx">value</span>
    <span class="p">}(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">DoNotDefer</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">_</span> <span class="p">=</span> <span class="nx">key</span> <span class="o">+</span> <span class="nx">value</span>
<span class="p">}</span>
</code></pre></div><p>基准测试：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkDoDefer</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nf">DoDefer</span><span class="p">(</span><span class="s">&#34;煎鱼&#34;</span><span class="p">,</span> <span class="s">&#34;https://github.com/EDDYCJY/blog&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkDoNotDefer</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nf">DoNotDefer</span><span class="p">(</span><span class="s">&#34;煎鱼&#34;</span><span class="p">,</span> <span class="s">&#34;https://github.com/EDDYCJY/blog&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>$ go test -bench=. -benchmem -run=none
goos: darwin
goarch: amd64
pkg: github.com/EDDYCJY/awesomeDefer
BenchmarkDoDefer-4          20000000            91.4 ns/op        48 B/op          1 allocs/op
BenchmarkDoNotDefer-4       30000000            41.6 ns/op        48 B/op          1 allocs/op
PASS
ok      github.com/EDDYCJY/awesomeDefer 3.234s
</code></pre><p>从结果上来，使用 <code>defer</code> 后的函数开销确实比没使用高了不少，这损耗用到哪里去了呢？</p>
<h2 id="想一下">想一下</h2>
<pre><code>$ go tool compile -S main.go
&quot;&quot;.main STEXT size=163 args=0x0 locals=0x40
    ...
    0x0059 00089 (main.go:6)    MOVQ    AX, 16(SP)
    0x005e 00094 (main.go:6)    MOVQ    $1, 24(SP)
    0x0067 00103 (main.go:6)    MOVQ    $1, 32(SP)
    0x0070 00112 (main.go:6)    CALL    runtime.deferproc(SB)
    0x0075 00117 (main.go:6)    TESTL    AX, AX
    0x0077 00119 (main.go:6)    JNE    137
    0x0079 00121 (main.go:7)    XCHGL    AX, AX
    0x007a 00122 (main.go:7)    CALL    runtime.deferreturn(SB)
    0x007f 00127 (main.go:7)    MOVQ    56(SP), BP
    0x0084 00132 (main.go:7)    ADDQ    $64, SP
    0x0088 00136 (main.go:7)    RET
    0x0089 00137 (main.go:6)    XCHGL    AX, AX
    0x008a 00138 (main.go:6)    CALL    runtime.deferreturn(SB)
    0x008f 00143 (main.go:6)    MOVQ    56(SP), BP
    0x0094 00148 (main.go:6)    ADDQ    $64, SP
    0x0098 00152 (main.go:6)    RET
    ...
</code></pre><p>我们在前文提到 <code>defer</code> 关键字其实涉及了一系列的连锁调用，内部 <code>runtime</code> 函数的调用就至少多了三步，分别是 <code>runtime.deferproc</code> 一次和 <code>runtime.deferreturn</code> 两次。</p>
<p>而这还只是在运行时的显式动作，另外编译器做的事也不少，例如：</p>
<ul>
<li>在 <code>deferproc</code> 阶段（注册延迟调用），还得获取/传入目标函数地址、函数参数等等。</li>
<li>在 <code>deferreturn</code> 阶段，需要在函数调用结尾处插入该方法的调用，同时若有被 <code>defer</code> 的函数，还需要使用 <code>runtime·jmpdefer</code> 进行跳转以便于后续调用。</li>
</ul>
<p>这一些动作途中还要涉及最小单元 <code>_defer</code> 的获取/生成， <code>defer</code> 和 <code>recover</code> 链表的逻辑处理和消耗等动作。</p>
<h2 id="qa">Q&amp;A</h2>
<p>最后讨论的时候有提到 <strong>“问题指的是本来就是用来执行 close() 一些操作的，然后说尽量不能用，例子就把 defer db.close() 前面的 defer 删去了”</strong> 这个疑问。</p>
<p>这是一个比较类似 “教科书” 式的说法，在一些入门教程中会潜移默化的告诉你在资源控制后加个 <code>defer</code> 延迟关闭一下。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</code></pre></div><p>但是一定得这么写吗？其实并不，很多人给出的理由都是 “怕你忘记” 这种说辞，这没有毛病。但需要认清场景，假设我的应用场景如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="c1">// do something
</span><span class="c1"></span><span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
</code></pre></div><p>嗯，一个请求当然没问题，流量、并发一下子大了呢，那可能就是个灾难了。你想想为什么？从常见的 <code>defer</code> + <code>close</code> 的使用组合来讲，用之前建议先看清楚应用场景，在保证无异常的情况下确保尽早关闭才是首选。如果只是小范围调用很快就返回的话，偷个懒直接一套组合拳出去也未尝不可。</p>
<h2 id="结论">结论</h2>
<p>一个 <code>defer</code> 关键字实际上包含了不少的动作和处理，和你单纯调用一个函数一条指令是没法比的。而与对照物相比，它确确实实是有性能损耗，目前延迟调用的全部开销大约在 50ns，但 <code>defer</code> 所提供的作用远远大于此，你从全局来看，它的损耗非常小，并且官方还不断地在优化中。</p>
<p>因此，对于 “Go defer 会有性能损耗，尽量不能用？” 这个问题，我认为<strong>该用就用，应该及时关闭就不要延迟，在 hot paths 用时一定要想清楚场景</strong>。</p>
<h2 id="补充">补充</h2>
<p>最后补充上柴大的回复：<strong>“不是性能问题，defer 最大的功能是 Panic 后依然有效。如果没有 defer，Panic 后就会导致 unlock 丢失，从而导致死锁了”</strong>，非常经典。</p>
]]></content>
		</item>
		
		<item>
			<title>深入理解 Go defer</title>
			<link>https://eddycjy.com/posts/go/defer/2019-05-27-defer/</link>
			<pubDate>Mon, 27 May 2019 12:30:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/defer/2019-05-27-defer/</guid>
			<description>在上一章节 《深入理解 Go panic and recover》中，我们发现了 defer 与其关联性极大，还是觉得非常有必要深入一下。希望通过本章节大家可以对 defer 关键字有一个深刻的理解，那么我们开始吧。你先等等，请排好队，我们这儿采取后进先出 LIFO 的出站方式&amp;hellip;
特性 我们简单的过一下 defer 关键字的基础使用，让大家先有一个基础的认知
一、延迟调用 func main() { defer log.Println(&amp;#34;EDDYCJY.&amp;#34;) log.Println(&amp;#34;end.&amp;#34;) } 输出结果：
$ go run main.go 2019/05/19 21:15:02 end. 2019/05/19 21:15:02 EDDYCJY. 二、后进先出 func main() { for i := 0; i &amp;lt; 6; i++ { defer log.Println(&amp;#34;EDDYCJY&amp;#34; + strconv.Itoa(i) + &amp;#34;.&amp;#34;) } log.Println(&amp;#34;end.&amp;#34;) } 输出结果：
$ go run main.go 2019/05/19 21:19:17 end. 2019/05/19 21:19:17 EDDYCJY5. 2019/05/19 21:19:17 EDDYCJY4.</description>
			<content type="html"><![CDATA[<p>在上一章节 《深入理解 Go panic and recover》中，我们发现了 <code>defer</code> 与其关联性极大，还是觉得非常有必要深入一下。希望通过本章节大家可以对 <code>defer</code> 关键字有一个深刻的理解，那么我们开始吧。你先等等，请排好队，我们这儿采取后进先出 LIFO 的出站方式&hellip;</p>
<h2 id="特性">特性</h2>
<p>我们简单的过一下 <code>defer</code> 关键字的基础使用，让大家先有一个基础的认知</p>
<h3 id="一延迟调用">一、延迟调用</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;EDDYCJY.&#34;</span><span class="p">)</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;end.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>$ go run main.go
2019/05/19 21:15:02 end.
2019/05/19 21:15:02 EDDYCJY.
</code></pre><h3 id="二后进先出">二、后进先出</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;EDDYCJY&#34;</span> <span class="o">+</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;.&#34;</span><span class="p">)</span>
	<span class="p">}</span>


	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;end.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>$ go run main.go
2019/05/19 21:19:17 end.
2019/05/19 21:19:17 EDDYCJY5.
2019/05/19 21:19:17 EDDYCJY4.
2019/05/19 21:19:17 EDDYCJY3.
2019/05/19 21:19:17 EDDYCJY2.
2019/05/19 21:19:17 EDDYCJY1.
2019/05/19 21:19:17 EDDYCJY0.
</code></pre><h3 id="三运行时间点">三、运行时间点</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		 <span class="k">defer</span> <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;defer.EDDYCJY.&#34;</span><span class="p">)</span>
	<span class="p">}()</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main.EDDYCJY.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>$ go run main.go
2019/05/22 23:30:27 defer.EDDYCJY.
2019/05/22 23:30:27 main.EDDYCJY.
</code></pre><h3 id="四异常处理">四、异常处理</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;EDDYCJY.&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;end.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>$ go run main.go
2019/05/20 22:22:57 EDDYCJY.
</code></pre><h2 id="源码剖析">源码剖析</h2>
<pre><code>$ go tool compile -S main.go
&quot;&quot;.main STEXT size=163 args=0x0 locals=0x40
	...
	0x0059 00089 (main.go:6)	MOVQ	AX, 16(SP)
	0x005e 00094 (main.go:6)	MOVQ	$1, 24(SP)
	0x0067 00103 (main.go:6)	MOVQ	$1, 32(SP)
	0x0070 00112 (main.go:6)	CALL	runtime.deferproc(SB)
	0x0075 00117 (main.go:6)	TESTL	AX, AX
	0x0077 00119 (main.go:6)	JNE	137
	0x0079 00121 (main.go:7)	XCHGL	AX, AX
	0x007a 00122 (main.go:7)	CALL	runtime.deferreturn(SB)
	0x007f 00127 (main.go:7)	MOVQ	56(SP), BP
	0x0084 00132 (main.go:7)	ADDQ	$64, SP
	0x0088 00136 (main.go:7)	RET
	0x0089 00137 (main.go:6)	XCHGL	AX, AX
	0x008a 00138 (main.go:6)	CALL	runtime.deferreturn(SB)
	0x008f 00143 (main.go:6)	MOVQ	56(SP), BP
	0x0094 00148 (main.go:6)	ADDQ	$64, SP
	0x0098 00152 (main.go:6)	RET
	...
</code></pre><p>首先我们需要找到它，找到它实际对应什么执行代码。通过汇编代码，可得知涉及如下方法：</p>
<ul>
<li>runtime.deferproc</li>
<li>runtime.deferreturn</li>
</ul>
<p>很显然是运行时的方法，是对的人。我们继续往下走看看都分别承担了什么行为</p>
<h3 id="数据结构">数据结构</h3>
<p>在开始前我们需要先介绍一下 <code>defer</code> 的基础单元 <code>_defer</code> 结构体，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">_defer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">siz</span>     <span class="kt">int32</span>
	<span class="nx">started</span> <span class="kt">bool</span>
	<span class="nx">sp</span>      <span class="kt">uintptr</span> <span class="c1">// sp at time of defer
</span><span class="c1"></span>	<span class="nx">pc</span>      <span class="kt">uintptr</span>
	<span class="nx">fn</span>      <span class="o">*</span><span class="nx">funcval</span>
	<span class="nx">_panic</span>  <span class="o">*</span><span class="nx">_panic</span> <span class="c1">// panic that is running defer
</span><span class="c1"></span>	<span class="nx">link</span>    <span class="o">*</span><span class="nx">_defer</span>
<span class="p">}</span>

<span class="o">...</span>
<span class="kd">type</span> <span class="nx">funcval</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">fn</span> <span class="kt">uintptr</span>
	<span class="c1">// variable-size, fn-specific data here
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><ul>
<li>siz：所有传入参数的总大小</li>
<li>started：该 <code>defer</code> 是否已经执行过</li>
<li>sp：函数栈指针寄存器，一般指向当前函数栈的栈顶</li>
<li>pc：程序计数器，有时称为指令指针(IP)，线程利用它来跟踪下一个要执行的指令。在大多数处理器中，PC 指向的是下一条指令，而不是当前指令</li>
<li>fn：指向传入的函数地址和参数</li>
<li>_panic：指向 <code>_panic</code> 链表</li>
<li>link：指向 <code>_defer</code> 链表</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLNjJ.png" alt="image"></p>
<h3 id="deferproc">deferproc</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">deferproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="nx">argp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
	<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>

	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">newdefer</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span>
    <span class="o">...</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="nx">fn</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">callerpc</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="k">switch</span> <span class="nx">siz</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// Do nothing.
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nf">memmove</span><span class="p">(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="nf">return0</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>获取调用 <code>defer</code> 函数的函数栈指针、传入函数的参数具体地址以及 PC （程序计数器），也就是下一个要执行的指令。这些相当于是预备参数，便于后续的流转控制</li>
<li>创建一个新的 <code>defer</code> 最小单元 <code>_defer</code>，填入先前准备的参数</li>
<li>调用 <code>memmove</code> 将传入的参数存储到新 <code>_defer</code> （当前使用）中去，便于后续的使用</li>
<li>最后调用 <code>return0</code> 进行返回，这个函数非常重要。能够避免在 <code>deferproc</code> 中又因为返回 <code>return</code>，而诱发 <code>deferreturn</code> 方法的调用。其根本原因是一个停止 <code>panic</code> 的延迟方法会使 <code>deferproc</code> 返回 1，但在机制中如果 <code>deferproc</code> 返回不等于 0，将会总是检查返回值并跳转到函数的末尾。而 <code>return0</code> 返回的就是 0，因此可以防止重复调用</li>
</ul>
<h4 id="小结">小结</h4>
<p>在<strong>这个函数中会为新的 <code>_defer</code> 设置一些基础属性，并将调用函数的参数集传入。最后通过特殊的返回方法结束函数调用</strong>。另外这一块与先前 <a href="https://segmentfault.com/a/1190000019251478#articleHeader9">《深入理解 Go panic and recover》</a> 的处理逻辑有一定关联性，其实就是 <code>gp.sched.ret</code> 返回 0 还是 1 会分流至不同处理方式</p>
<h3 id="newdefer">newdefer</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newdefer</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">_defer</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span>
	<span class="nx">sc</span> <span class="o">:=</span> <span class="nf">deferclass</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">))</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">sc</span> <span class="p">&lt;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">{}.</span><span class="nx">deferpool</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="o">...</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
			<span class="nx">d</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="o">...</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">total</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nf">totaldefersize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)))</span>
			<span class="nx">d</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">_defer</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">total</span><span class="p">,</span> <span class="nx">deferType</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="p">})</span>
		<span class="o">...</span>
	<span class="p">}</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">=</span> <span class="nx">siz</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span>
	<span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>从池中获取可以使用的 <code>_defer</code>，则复用作为新的基础单元</li>
<li>若在池中没有获取到可用的，则调用 <code>mallocgc</code> 重新申请一个新的</li>
<li>设置 <code>defer</code> 的基础属性，最后修改当前 <code>Goroutine</code> 的 <code>_defer</code> 指向</li>
</ul>
<p>通过这个方法我们可以注意到两点，如下：</p>
<ul>
<li><code>defer</code> 与 <code>Goroutine(g)</code> 有直接关系，所以讨论 <code>defer</code> 时基本离不开 <code>g</code> 的关联</li>
<li>新的 <code>defer</code> 总是会在现有的链表中的最前面，也就是 <code>defer</code> 的特性后进先出</li>
</ul>
<h4 id="小结-1">小结</h4>
<p>这个函数主要承担了获取新的 <code>_defer</code> 的作用，它有可能是从 <code>deferpool</code> 中获取的，也有可能是重新申请的</p>
<h3 id="deferreturn">deferreturn</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">deferreturn</span><span class="p">(</span><span class="nx">arg0</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="o">!=</span> <span class="nx">sp</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// Do nothing.
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">))</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">),</span> <span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fn</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
	<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="nf">jmpdefer</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><p>如果在一个方法中调用过 <code>defer</code> 关键字，那么编译器将会在结尾处插入 <code>deferreturn</code> 方法的调用。而该方法中主要做了如下事项：</p>
<ul>
<li>清空当前节点 <code>_defer</code> 被调用的函数调用信息</li>
<li>释放当前节点的 <code>_defer</code> 的存储信息并放回池中（便于复用）</li>
<li>跳转到调用 <code>defer</code> 关键字的调用函数处</li>
</ul>
<p>在这段代码中，跳转方法 <code>jmpdefer</code> 格外重要。因为它显式的控制了流转，代码如下：</p>
<pre><code>// asm_amd64.s
TEXT runtime·jmpdefer(SB), NOSPLIT, $0-16
	MOVQ	fv+0(FP), DX	// fn
	MOVQ	argp+8(FP), BX	// caller sp
	LEAQ	-8(BX), SP	// caller sp after CALL
	MOVQ	-8(SP), BP	// restore BP as if deferreturn returned (harmless if framepointers not in use)
	SUBQ	$5, (SP)	// return to CALL again
	MOVQ	0(DX), BX
	JMP	BX	// but first run the deferred function
</code></pre><p>通过源码的分析，我们发现它做了两个很 “奇怪” 又很重要的事，如下：</p>
<ul>
<li>MOVQ -8(SP), BP：<code>-8(BX)</code> 这个位置保存的是 <code>deferreturn</code> 执行完毕后的地址</li>
<li>SUBQ $5, (SP)：<code>SP</code> 的地址减 5 ，其减掉的长度就恰好是 <code>runtime.deferreturn</code> 的长度</li>
</ul>
<p>你可能会问，为什么是 5？好吧。翻了半天最后看了一下汇编代码&hellip;嗯，相减的确是 5 没毛病，如下：</p>
<pre><code>	0x007a 00122 (main.go:7)	CALL	runtime.deferreturn(SB)
	0x007f 00127 (main.go:7)	MOVQ	56(SP), BP
</code></pre><p>我们整理一下思绪，照上述逻辑的话，那 <code>deferreturn</code> 就是一个 “递归” 了哦。每次都会重新回到 <code>deferreturn</code> 函数，那它在什么时候才会结束呢，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">deferreturn</span><span class="p">(</span><span class="nx">arg0</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>也就是会不断地进入 <code>deferreturn</code> 函数，判断链表中是否还存着 <code>_defer</code>。若已经不存在了，则返回，结束掉它。简单来讲，就是处理完全部 <code>defer</code> 才允许你真的离开它。果真如此吗？我们再看看上面的汇编代码，如下：</p>
<pre><code>    。..
	0x0070 00112 (main.go:6)	CALL	runtime.deferproc(SB)
	0x0075 00117 (main.go:6)	TESTL	AX, AX
	0x0077 00119 (main.go:6)	JNE	137
	0x0079 00121 (main.go:7)	XCHGL	AX, AX
	0x007a 00122 (main.go:7)	CALL	runtime.deferreturn(SB)
	0x007f 00127 (main.go:7)	MOVQ	56(SP), BP
	0x0084 00132 (main.go:7)	ADDQ	$64, SP
	0x0088 00136 (main.go:7)	RET
	0x0089 00137 (main.go:6)	XCHGL	AX, AX
	0x008a 00138 (main.go:6)	CALL	runtime.deferreturn(SB)
	...
</code></pre><p>的确如上述流程所分析一致，验证完毕</p>
<h4 id="小结-2">小结</h4>
<p>这个函数主要承担了清空已使用的 <code>defer</code> 和跳转到调用 <code>defer</code> 关键字的函数处，非常重要</p>
<h2 id="总结">总结</h2>
<p>我们有提到 <code>defer</code> 关键字涉及两个核心的函数，分别是 <code>deferproc</code> 和 <code>deferreturn</code> 函数。而 <code>deferreturn</code> 函数比较特殊，是当应用函数调用 <code>defer</code> 关键字时，编译器会在其结尾处插入 <code>deferreturn</code> 的调用，它们俩一般都是成对出现的</p>
<p>但是当一个 <code>Goroutine</code> 上存在着多次 <code>defer</code> 行为（也就是多个 <code>_defer</code>）时，编译器会进行利用一些小技巧， 重新回到 <code>deferreturn</code> 函数去消耗 <code>_defer</code> 链表，直到一个不剩才允许真正的结束</p>
<p>而新增的基础单元 <code>_defer</code>，有可能是被复用的，也有可能是全新申请的。它最后都会被追加到 <code>_defer</code> 链表的表头，从而设定了后进先出的调用特性</p>
<h2 id="关联">关联</h2>
<ul>
<li><a href="https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2019-05-18-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-panic-and-recover.md">深入理解 Go panic and recover</a></li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">Scheduling In Go</a></li>
<li><a href="http://hustcat.github.io/dive-into-stack-defer-panic-recover-in-go/">Dive into stack and defer/panic/recover in go</a></li>
<li><a href="https://github.com/cch123/golang-notes/blob/master/defer.md">golang-notes</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>深入理解 Go panic and recover</title>
			<link>https://eddycjy.com/posts/go/panic/2019-05-21-panic-and-recover/</link>
			<pubDate>Tue, 21 May 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/panic/2019-05-21-panic-and-recover/</guid>
			<description>作为一个 gophper，我相信你对于 panic 和 recover 肯定不陌生，但是你有没有想过。当我们执行了这两条语句之后。底层到底发生了什么事呢？前几天和同事刚好聊到相关的话题，发现其实大家对这块理解还是比较模糊的。希望这篇文章能够从更深入的角度告诉你为什么，它到底做了什么事？
思考 一、为什么会中止运行 func main() { panic(&amp;quot;EDDYCJY.&amp;quot;) } 输出结果：
$ go run main.go panic: EDDYCJY. goroutine 1 [running]: main.main() /Users/eddycjy/go/src/github.com/EDDYCJY/awesomeProject/main.go:4 +0x39 exit status 2 请思考一下，为什么执行 panic 后会导致应用程序运行中止？（而不是单单说执行了 panic 所以就结束了这么含糊）
二、为什么不会中止运行 func main() { defer func() { if err := recover(); err != nil { log.Printf(&amp;quot;recover: %v&amp;quot;, err) } }() panic(&amp;quot;EDDYCJY.&amp;quot;) } 输出结果：
$ go run main.go 2019/05/11 23:39:47 recover: EDDYCJY. 请思考一下，为什么加上 defer + recover 组合就可以保护应用程序？</description>
			<content type="html"><![CDATA[<p>作为一个 gophper，我相信你对于 <code>panic</code> 和 <code>recover</code> 肯定不陌生，但是你有没有想过。当我们执行了这两条语句之后。底层到底发生了什么事呢？前几天和同事刚好聊到相关的话题，发现其实大家对这块理解还是比较模糊的。希望这篇文章能够从更深入的角度告诉你为什么，它到底做了什么事？</p>
<h2 id="思考">思考</h2>
<h3 id="一为什么会中止运行">一、为什么会中止运行</h3>
<pre><code>func main() {
	panic(&quot;EDDYCJY.&quot;)
}
</code></pre><p>输出结果：</p>
<pre><code>$ go run main.go
panic: EDDYCJY.

goroutine 1 [running]:
main.main()
	/Users/eddycjy/go/src/github.com/EDDYCJY/awesomeProject/main.go:4 +0x39
exit status 2
</code></pre><p>请思考一下，为什么执行 <code>panic</code> 后会导致应用程序运行中止？（而不是单单说执行了 <code>panic</code> 所以就结束了这么含糊）</p>
<h3 id="二为什么不会中止运行">二、为什么不会中止运行</h3>
<pre><code>func main() {
	defer func() {
		if err := recover(); err != nil {
			log.Printf(&quot;recover: %v&quot;, err)
		}
	}()

	panic(&quot;EDDYCJY.&quot;)
}
</code></pre><p>输出结果：</p>
<pre><code>$ go run main.go 
2019/05/11 23:39:47 recover: EDDYCJY.
</code></pre><p>请思考一下，为什么加上 <code>defer</code> + <code>recover</code> 组合就可以保护应用程序？</p>
<h3 id="三不设置-defer-行不">三、不设置 defer 行不</h3>
<p>上面问题二是 <code>defer</code> + <code>recover</code> 组合，那我去掉 <code>defer</code> 是不是也可以呢？如下：</p>
<pre><code>func main() {
	if err := recover(); err != nil {
		log.Printf(&quot;recover: %v&quot;, err)
	}

	panic(&quot;EDDYCJY.&quot;)
}
</code></pre><p>输出结果：</p>
<pre><code>$ go run main.go
panic: EDDYCJY.

goroutine 1 [running]:
main.main()
	/Users/eddycjy/go/src/github.com/EDDYCJY/awesomeProject/main.go:10 +0xa1
exit status 2
</code></pre><p>竟然不行，啊呀毕竟入门教程都写的 <code>defer</code> + <code>recover</code> 组合 “万能” 捕获。但是为什么呢。去掉 <code>defer</code> 后为什么就无法捕获了？</p>
<p>请思考一下，为什么需要设置 <code>defer</code> 后 <code>recover</code> 才能起作用？</p>
<p>同时你还需要仔细想想，我们设置 <code>defer</code> + <code>recover</code> 组合后就能无忧无虑了吗，各种 “乱” 写了吗？</p>
<h3 id="四为什么起个-goroutine-就不行">四、为什么起个 goroutine 就不行</h3>
<pre><code>func main() {
	go func() {
		defer func() {
			if err := recover(); err != nil {
				log.Printf(&quot;recover: %v&quot;, err)
			}
		}()
	}()

	panic(&quot;EDDYCJY.&quot;)
}
</code></pre><p>输出结果：</p>
<pre><code>$ go run main.go 
panic: EDDYCJY.

goroutine 1 [running]:
main.main()
	/Users/eddycjy/go/src/github.com/EDDYCJY/awesomeProject/main.go:14 +0x51
exit status 2
</code></pre><p>请思考一下，为什么新起了一个 <code>Goroutine</code> 就无法捕获到异常了？到底发生了什么事&hellip;</p>
<h2 id="源码">源码</h2>
<p>接下来我们将带着上述 4+1 个小思考题，开始对源码的剖析和分析，尝试从阅读源码中找到思考题的答案和更多为什么</p>
<h3 id="数据结构">数据结构</h3>
<pre><code>type _panic struct {
	argp      unsafe.Pointer
	arg       interface{} 
	link      *_panic 
	recovered bool
	aborted   bool 
}
</code></pre><p>在 <code>panic</code> 中是使用 <code>_panic</code> 作为其基础单元的，每执行一次 <code>panic</code> 语句，都会创建一个 <code>_panic</code>。它包含了一些基础的字段用于存储当前的 <code>panic</code> 调用情况，涉及的字段如下：</p>
<ul>
<li>argp：指向 <code>defer</code> 延迟调用的参数的指针</li>
<li>arg：<code>panic</code> 的原因，也就是调用 <code>panic</code> 时传入的参数</li>
<li>link：指向上一个调用的 <code>_panic</code></li>
<li>recovered：<code>panic</code> 是否已经被处理，也就是是否被 <code>recover</code></li>
<li>aborted：<code>panic</code> 是否被中止</li>
</ul>
<p>另外通过查看 <code>link</code> 字段，可得知其是一个链表的数据结构，如下图：</p>
<p><img src="http://wx3.sinaimg.cn/large/006fVPCvly1g2muc73jp1j30hc099q2x.jpg" alt="image"></p>
<h3 id="恐慌-panic">恐慌 panic</h3>
<pre><code>func main() {
	panic(&quot;EDDYCJY.&quot;)
}
</code></pre><p>输出结果：</p>
<pre><code>$ go run main.go
panic: EDDYCJY.

goroutine 1 [running]:
main.main()
	/Users/eddycjy/go/src/github.com/EDDYCJY/awesomeProject/main.go:4 +0x39
exit status 2
</code></pre><p>我们去反查一下 <code>panic</code> 处理具体逻辑的地方在哪，如下：</p>
<pre><code>$ go tool compile -S main.go
&quot;&quot;.main STEXT size=66 args=0x0 locals=0x18
	0x0000 00000 (main.go:23)	TEXT	&quot;&quot;.main(SB), ABIInternal, $24-0
	0x0000 00000 (main.go:23)	MOVQ	(TLS), CX
	0x0009 00009 (main.go:23)	CMPQ	SP, 16(CX)
	...
	0x002f 00047 (main.go:24)	PCDATA	$2, $0
	0x002f 00047 (main.go:24)	MOVQ	AX, 8(SP)
	0x0034 00052 (main.go:24)	CALL	runtime.gopanic(SB)
</code></pre><p>显然汇编代码直指内部实现是 <code>runtime.gopanic</code>，我们一起来看看这个方法做了什么事，如下（省略了部分）：</p>
<pre><code>func gopanic(e interface{}) {
	gp := getg()
	...
	var p _panic
	p.arg = e
	p.link = gp._panic
	gp._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))
    
	for {
		d := gp._defer
		if d == nil {
			break
		}

		// defer...
		...
		d._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))

		p.argp = unsafe.Pointer(getargp(0))
		reflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz))
		p.argp = nil

		// recover...
		if p.recovered {
			...
			mcall(recovery)
			throw(&quot;recovery failed&quot;) // mcall should not return
		}
	}

	preprintpanics(gp._panic)

	fatalpanic(gp._panic) // should not return
	*(*int)(nil) = 0      // not reached
}
</code></pre><ul>
<li>获取指向当前 <code>Goroutine</code> 的指针</li>
<li>初始化一个 <code>panic</code> 的基本单位 <code>_panic</code> 用作后续的操作</li>
<li>获取当前 <code>Goroutine</code> 上挂载的 <code>_defer</code>（数据结构也是链表）</li>
<li>若当前存在 <code>defer</code> 调用，则调用 <code>reflectcall</code> 方法去执行先前 <code>defer</code> 中延迟执行的代码，若在执行过程中需要运行 <code>recover</code> 将会调用 <code>gorecover</code> 方法</li>
<li>结束前，使用 <code>preprintpanics</code> 方法打印出所涉及的 <code>panic</code> 消息</li>
<li>最后调用 <code>fatalpanic</code> 中止应用程序，实际是执行 <code>exit(2)</code> 进行最终退出行为的</li>
</ul>
<p>通过对上述代码的执行分析，可得知 <code>panic</code> 方法实际上就是处理当前 <code>Goroutine(g)</code> 上所挂载的 <code>._panic</code> 链表（所以无法对其他 <code>Goroutine</code> 的异常事件响应），然后对其所属的 <code>defer</code> 链表和 <code>recover</code> 进行检测并处理，最后调用退出命令中止应用程序</p>
<h3 id="无法恢复的恐慌-fatalpanic">无法恢复的恐慌 fatalpanic</h3>
<pre><code>func fatalpanic(msgs *_panic) {
	pc := getcallerpc()
	sp := getcallersp()
	gp := getg()
	var docrash bool

	systemstack(func() {
		if startpanic_m() &amp;&amp; msgs != nil {
		    ...
			printpanics(msgs)
		}

		docrash = dopanic_m(gp, pc, sp)
	})

	systemstack(func() {
		exit(2)
	})

	*(*int)(nil) = 0
}
</code></pre><p>我们看到在异常处理的最后会执行该方法，似乎它承担了所有收尾工作。实际呢，它是在最后对程序执行 <code>exit</code> 指令来达到中止运行的作用，但在结束前它会通过 <code>printpanics</code> 递归输出所有的异常消息及参数。代码如下：</p>
<pre><code>func printpanics(p *_panic) {
	if p.link != nil {
		printpanics(p.link)
		print(&quot;\t&quot;)
	}
	print(&quot;panic: &quot;)
	printany(p.arg)
	if p.recovered {
		print(&quot; [recovered]&quot;)
	}
	print(&quot;\n&quot;)
}
</code></pre><p>所以不要以为所有的异常都能够被 <code>recover</code> 到，实际上像 <code>fatal error</code> 和 <code>runtime.throw</code> 都是无法被 <code>recover</code> 到的，甚至是 oom 也是直接中止程序的，也有反手就给你来个 <code>exit(2)</code> 教做人。因此在写代码时你应该要相对注意些，“恐慌” 是存在无法恢复的场景的</p>
<h3 id="恢复-recover">恢复 recover</h3>
<pre><code>func main() {
	defer func() {
		if err := recover(); err != nil {
			log.Printf(&quot;recover: %v&quot;, err)
		}
	}()

	panic(&quot;EDDYCJY.&quot;)
}
</code></pre><p>输出结果：</p>
<pre><code>$ go run main.go 
2019/05/11 23:39:47 recover: EDDYCJY.
</code></pre><p>和预期一致，成功捕获到了异常。但是 <code>recover</code> 是怎么恢复 <code>panic</code> 的呢？再看看汇编代码，如下：</p>
<pre><code>$ go tool compile -S main.go
&quot;&quot;.main STEXT size=110 args=0x0 locals=0x18
	0x0000 00000 (main.go:5)	TEXT	&quot;&quot;.main(SB), ABIInternal, $24-0
	...
	0x0024 00036 (main.go:6)	LEAQ	&quot;&quot;.main.func1·f(SB), AX
	0x002b 00043 (main.go:6)	PCDATA	$2, $0
	0x002b 00043 (main.go:6)	MOVQ	AX, 8(SP)
	0x0030 00048 (main.go:6)	CALL	runtime.deferproc(SB)
	...
	0x0050 00080 (main.go:12)	CALL	runtime.gopanic(SB)
	0x0055 00085 (main.go:12)	UNDEF
	0x0057 00087 (main.go:6)	XCHGL	AX, AX
	0x0058 00088 (main.go:6)	CALL	runtime.deferreturn(SB)
	...
	0x0022 00034 (main.go:7)	MOVQ	AX, (SP)
	0x0026 00038 (main.go:7)	CALL	runtime.gorecover(SB)
	0x002b 00043 (main.go:7)	PCDATA	$2, $1
	0x002b 00043 (main.go:7)	MOVQ	16(SP), AX
	0x0030 00048 (main.go:7)	MOVQ	8(SP), CX
	...
	0x0056 00086 (main.go:8)	LEAQ	go.string.&quot;recover: %v&quot;(SB), AX
	...
	0x0086 00134 (main.go:8)	CALL	log.Printf(SB)
	...
</code></pre><p>通过分析底层调用，可得知主要是如下几个方法：</p>
<ul>
<li>runtime.deferproc</li>
<li>runtime.gopanic</li>
<li>runtime.deferreturn</li>
<li>runtime.gorecover</li>
</ul>
<p>在上小节中，我们讲述了简单的流程，<code>gopanic</code> 方法会调用当前 <code>Goroutine</code> 下的 <code>defer</code> 链表，若 <code>reflectcall</code> 执行中遇到 <code>recover</code> 就会调用 <code>gorecover</code> 进行处理，该方法代码如下：</p>
<pre><code>func gorecover(argp uintptr) interface{} {
	gp := getg()
	p := gp._panic
	if p != nil &amp;&amp; !p.recovered &amp;&amp; argp == uintptr(p.argp) {
		p.recovered = true
		return p.arg
	}
	return nil
}
</code></pre><p>这代码，看上去挺简单的，核心就是修改 <code>recovered</code> 字段。该字段是用于标识当前 <code>panic</code> 是否已经被 <code>recover</code> 处理。但是这和我们想象的并不一样啊，程序是怎么从 <code>panic</code> 流转回去的呢？是不是在核心方法里处理了呢？我们再看看 <code>gopanic</code> 的代码，如下：</p>
<pre><code>func gopanic(e interface{}) {
	...
	for {
		// defer...
		...
		pc := d.pc
		sp := unsafe.Pointer(d.sp) // must be pointer so it gets adjusted during stack copy
		freedefer(d)
		
		// recover...
		if p.recovered {
			atomic.Xadd(&amp;runningPanicDefers, -1)

			gp._panic = p.link
			for gp._panic != nil &amp;&amp; gp._panic.aborted {
				gp._panic = gp._panic.link
			}
			if gp._panic == nil { 
				gp.sig = 0
			}

			gp.sigcode0 = uintptr(sp)
			gp.sigcode1 = pc
			mcall(recovery)
			throw(&quot;recovery failed&quot;) 
		}
	}
    ...
}
</code></pre><p>我们回到 <code>gopanic</code> 方法中再仔细看看，发现实际上是包含对 <code>recover</code> 流转的处理代码的。恢复流程如下：</p>
<ul>
<li>判断当前 <code>_panic</code> 中的 <code>recover</code> 是否已标注为处理</li>
<li>从 <code>_panic</code> 链表中删除已标注中止的 <code>panic</code> 事件，也就是删除已经被恢复的 <code>panic</code> 事件</li>
<li>将相关需要恢复的栈帧信息传递给 <code>recovery</code> 方法的 <code>gp</code> 参数（每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的返回地址和局部变量）</li>
<li>执行 <code>recovery</code> 进行恢复动作</li>
</ul>
<p>从流程来看，最核心的是 <code>recovery</code> 方法。它承担了异常流转控制的职责。代码如下：</p>
<pre><code>func recovery(gp *g) {
	sp := gp.sigcode0
	pc := gp.sigcode1

	if sp != 0 &amp;&amp; (sp &lt; gp.stack.lo || gp.stack.hi &lt; sp) {
		print(&quot;recover: &quot;, hex(sp), &quot; not in [&quot;, hex(gp.stack.lo), &quot;, &quot;, hex(gp.stack.hi), &quot;]\n&quot;)
		throw(&quot;bad recovery&quot;)
	}

	gp.sched.sp = sp
	gp.sched.pc = pc
	gp.sched.lr = 0
	gp.sched.ret = 1
	gogo(&amp;gp.sched)
}
</code></pre><p>粗略一看，似乎就是很简单的设置了一些值？但实际上设置的是编译器中伪寄存器的值，常常被用于维护上下文等。在这里我们需要结合 <code>gopanic</code> 方法一同观察 <code>recovery</code> 方法。它所使用的栈指针 <code>sp</code> 和程序计数器 <code>pc</code> 是由当前 <code>defer</code> 在调用流程中的 <code>deferproc</code> 传递下来的，因此实际上最后是通过 <code>gogo</code> 方法跳回了 <code>deferproc</code> 方法。另外我们注意到：</p>
<pre><code>gp.sched.ret = 1
</code></pre><p>在底层中程序将 <code>gp.sched.ret</code> 设置为了 1，也就是<strong>没有实际调用</strong> <code>deferproc</code> 方法，直接修改了其返回值。意味着默认它已经处理完成。直接转移到 <code>deferproc</code> 方法的下一条指令去。至此为止，异常状态的流转控制就已经结束了。接下来就是继续走 <code>defer</code> 的流程了</p>
<p>为了验证这个想法，我们可以看一下核心的跳转方法 <code>gogo</code> ，代码如下：</p>
<pre><code>// void gogo(Gobuf*)
// restore state from Gobuf; longjmp
TEXT runtime·gogo(SB),NOSPLIT,$8-4
	MOVW	buf+0(FP), R1
	MOVW	gobuf_g(R1), R0
	BL	setg&lt;&gt;(SB)

	MOVW	gobuf_sp(R1), R13	// restore SP==R13
	MOVW	gobuf_lr(R1), LR
	MOVW	gobuf_ret(R1), R0
	MOVW	gobuf_ctxt(R1), R7
	MOVW	$0, R11
	MOVW	R11, gobuf_sp(R1)	// clear to help garbage collector
	MOVW	R11, gobuf_ret(R1)
	MOVW	R11, gobuf_lr(R1)
	MOVW	R11, gobuf_ctxt(R1)
	MOVW	gobuf_pc(R1), R11
	CMP	R11, R11 // set condition codes for == test, needed by stack split
	B	(R11)
</code></pre><p>通过查看代码可得知其主要作用是从 <code>Gobuf</code> 恢复状态。简单来讲就是将寄存器的值修改为对应 <code>Goroutine(g)</code> 的值，而在文中讲了很多次的 <code>Gobuf</code>，如下：</p>
<pre><code>type gobuf struct {
	sp   uintptr
	pc   uintptr
	g    guintptr
	ctxt unsafe.Pointer
	ret  sys.Uintreg
	lr   uintptr
	bp   uintptr
}
</code></pre><p>讲道理，其实它存储的就是 <code>Goroutine</code> 切换上下文时所需要的一些东西</p>
<h2 id="拓展">拓展</h2>
<pre><code>const(
	OPANIC       // panic(Left)
	ORECOVER     // recover()
	...
)
...
func walkexpr(n *Node, init *Nodes) *Node {
    ...
	switch n.Op {
	default:
		Dump(&quot;walk&quot;, n)
		Fatalf(&quot;walkexpr: switch 1 unknown op %+S&quot;, n)

	case ONONAME, OINDREGSP, OEMPTY, OGETG:
	case OTYPE, ONAME, OLITERAL:
	    ...
	case OPANIC:
		n = mkcall(&quot;gopanic&quot;, nil, init, n.Left)

	case ORECOVER:
		n = mkcall(&quot;gorecover&quot;, n.Type, init, nod(OADDR, nodfp, nil))
	...
}
</code></pre><p>实际上在调用 <code>panic</code> 和 <code>recover</code> 关键字时，是在编译阶段先转换为相应的 OPCODE 后，再由编译器转换为对应的运行时方法。并不是你所想像那样一步到位，有兴趣的小伙伴可以研究一下</p>
<h2 id="总结">总结</h2>
<p>本文主要针对 <code>panic</code> 和 <code>recover</code> 关键字进行了深入源码的剖析，而开头的 4+1 个思考题，就是希望您能够带着疑问去学习，达到事半功倍的功效</p>
<p>另外本文和 <code>defer</code> 有一定的关联性，因此需要有一定的基础知识。若刚刚看的时候这部分不理解，学习后可以再读一遍加深印象</p>
<p>在最后，现在的你可以回答这几个思考题了吗？说出来了才是真的懂 ：）</p>
]]></content>
		</item>
		
		<item>
			<title>我要在栈上。不，你应该在堆上</title>
			<link>https://eddycjy.com/posts/go/talk/2019-05-20-stack-heap/</link>
			<pubDate>Mon, 20 May 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2019-05-20-stack-heap/</guid>
			<description>我们在写代码的时候，有时候会想这个变量到底分配到哪里了？这时候可能会有人说，在栈上，在堆上。信我准没错&amp;hellip;
但从结果上来讲你还是一知半解，这可不行，万一被人懵了呢。今天我们一起来深挖下 Go 在这块的奥妙，自己动手丰衣足食
问题 type User struct { ID int64 Name string Avatar string } func GetUserInfo() *User { return &amp;amp;User{ID: 13746731, Name: &amp;#34;EDDYCJY&amp;#34;, Avatar: &amp;#34;https://avatars0.githubusercontent.com/u/13746731&amp;#34;} } func main() { _ = GetUserInfo() } 开局就是一把问号，带着问题进行学习。请问 main 调用 GetUserInfo 后返回的 &amp;amp;User{...}。这个变量是分配到栈上了呢，还是分配到堆上了？
什么是堆/栈 在这里并不打算详细介绍堆栈，仅简单介绍本文所需的基础知识。如下：
 堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多 栈（Stack）：由编译器进行管理，自动申请、分配、释放。一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上  今天我们介绍的 Go 语言，它的堆栈分配是通过 Compiler 进行分析，GC 去管理的，而对其的分析选择动作就是今天探讨的重点
什么是逃逸分析 在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针
通俗地讲，逃逸分析就是确定一个变量要放堆上还是栈上，规则如下：
 是否有在其他地方（非局部）被引用。只要有可能被引用了，那么它一定分配到堆上。否则分配到栈上 即使没有被外部引用，但对象过大，无法存放在栈区上。依然有可能分配到堆上  对此你可以理解为，逃逸分析是编译器用于决定变量分配到堆上还是栈上的一种行为
在什么阶段确立逃逸 在编译阶段确立逃逸，注意并不是在运行时
为什么需要逃逸 这个问题我们可以反过来想，如果变量都分配到堆上了会出现什么事情？例如：
 垃圾回收（GC）的压力不断增大 申请、分配、回收内存的系统开销增大（相对于栈） 动态分配产生一定量的内存碎片  其实总的来说，就是频繁申请、分配堆内存是有一定 “代价” 的。会影响应用程序运行的效率，间接影响到整体系统。因此 “按需分配” 最大限度的灵活利用资源，才是正确的治理之道。这就是为什么需要逃逸分析的原因，你觉得呢？</description>
			<content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/27/3wK39K.jpg" alt="image"></p>
<p>我们在写代码的时候，有时候会想这个变量到底分配到哪里了？这时候可能会有人说，在栈上，在堆上。信我准没错&hellip;</p>
<p>但从结果上来讲你还是一知半解，这可不行，万一被人懵了呢。今天我们一起来深挖下 Go 在这块的奥妙，自己动手丰衣足食</p>
<h2 id="问题">问题</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span>     <span class="kt">int64</span>
	<span class="nx">Name</span>   <span class="kt">string</span>
	<span class="nx">Avatar</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetUserInfo</span><span class="p">()</span> <span class="o">*</span><span class="nx">User</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span><span class="nx">ID</span><span class="p">:</span> <span class="mi">13746731</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;EDDYCJY&#34;</span><span class="p">,</span> <span class="nx">Avatar</span><span class="p">:</span> <span class="s">&#34;https://avatars0.githubusercontent.com/u/13746731&#34;</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nf">GetUserInfo</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>开局就是一把问号，带着问题进行学习。请问 main 调用 <code>GetUserInfo</code> 后返回的 <code>&amp;User{...}</code>。这个变量是分配到栈上了呢，还是分配到堆上了？</p>
<h2 id="什么是堆栈">什么是堆/栈</h2>
<p>在这里并不打算详细介绍堆栈，仅简单介绍本文所需的基础知识。如下：</p>
<ul>
<li>堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多</li>
<li>栈（Stack）：由编译器进行管理，自动申请、分配、释放。一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上</li>
</ul>
<p>今天我们介绍的 Go 语言，它的堆栈分配是通过 Compiler 进行分析，GC 去管理的，而对其的分析选择动作就是今天探讨的重点</p>
<h2 id="什么是逃逸分析">什么是逃逸分析</h2>
<p>在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针</p>
<p>通俗地讲，逃逸分析就是确定一个变量要放堆上还是栈上，规则如下：</p>
<ol>
<li>是否有在其他地方（非局部）被引用。只要<strong>有可能</strong>被引用了，那么它<strong>一定</strong>分配到堆上。否则分配到栈上</li>
<li>即使没有被外部引用，但对象过大，无法存放在栈区上。依然有可能分配到堆上</li>
</ol>
<p>对此你可以理解为，逃逸分析是编译器用于决定变量分配到堆上还是栈上的一种行为</p>
<h2 id="在什么阶段确立逃逸">在什么阶段确立逃逸</h2>
<p>在编译阶段确立逃逸，注意并不是在运行时</p>
<h2 id="为什么需要逃逸">为什么需要逃逸</h2>
<p>这个问题我们可以反过来想，如果变量都分配到堆上了会出现什么事情？例如：</p>
<ul>
<li>垃圾回收（GC）的压力不断增大</li>
<li>申请、分配、回收内存的系统开销增大（相对于栈）</li>
<li>动态分配产生一定量的内存碎片</li>
</ul>
<p>其实总的来说，就是频繁申请、分配堆内存是有一定 “代价” 的。会影响应用程序运行的效率，间接影响到整体系统。因此 “按需分配” 最大限度的灵活利用资源，才是正确的治理之道。这就是为什么需要逃逸分析的原因，你觉得呢？</p>
<h2 id="怎么确定是否逃逸">怎么确定是否逃逸</h2>
<p>第一，通过编译器命令，就可以看到详细的逃逸分析过程。而指令集 <code>-gcflags</code> 用于将标识参数传递给 Go 编译器，涉及如下：</p>
<ul>
<li>
<p><code>-m</code> 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 <code>-m</code>，但是信息量较大，一般用 1 个就可以了</p>
</li>
<li>
<p><code>-l</code> 会禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰</p>
</li>
</ul>
<pre><code>$ go build -gcflags '-m -l' main.go
</code></pre><p>第二，通过反编译命令查看</p>
<pre><code>$ go tool compile -S main.go
</code></pre><p>注：可以通过 <code>go tool compile -help</code> 查看所有允许传递给编译器的标识参数</p>
<h2 id="逃逸案例">逃逸案例</h2>
<h3 id="案例一指针">案例一：指针</h3>
<p>第一个案例是一开始抛出的问题，现在你再看看，想想，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span>     <span class="kt">int64</span>
	<span class="nx">Name</span>   <span class="kt">string</span>
	<span class="nx">Avatar</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetUserInfo</span><span class="p">()</span> <span class="o">*</span><span class="nx">User</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span><span class="nx">ID</span><span class="p">:</span> <span class="mi">13746731</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;EDDYCJY&#34;</span><span class="p">,</span> <span class="nx">Avatar</span><span class="p">:</span> <span class="s">&#34;https://avatars0.githubusercontent.com/u/13746731&#34;</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nf">GetUserInfo</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>执行命令观察一下，如下：</p>
<pre><code>$ go build -gcflags '-m -l' main.go
# command-line-arguments
./main.go:10:54: &amp;User literal escapes to heap
</code></pre><p>通过查看分析结果，可得知 <code>&amp;User</code> 逃到了堆里，也就是分配到堆上了。这是不是有问题啊&hellip;再看看汇编代码确定一下，如下：</p>
<pre><code>$ go tool compile -S main.go
&quot;&quot;.GetUserInfo STEXT size=190 args=0x8 locals=0x18
	0x0000 00000 (main.go:9)	TEXT	&quot;&quot;.GetUserInfo(SB), $24-8
	...
	0x0028 00040 (main.go:10)	MOVQ	AX, (SP)
	0x002c 00044 (main.go:10)	CALL	runtime.newobject(SB)
	0x0031 00049 (main.go:10)	PCDATA	$2, $1
	0x0031 00049 (main.go:10)	MOVQ	8(SP), AX
	0x0036 00054 (main.go:10)	MOVQ	$13746731, (AX)
	0x003d 00061 (main.go:10)	MOVQ	$7, 16(AX)
	0x0045 00069 (main.go:10)	PCDATA	$2, $-2
	0x0045 00069 (main.go:10)	PCDATA	$0, $-2
	0x0045 00069 (main.go:10)	CMPL	runtime.writeBarrier(SB), $0
	0x004c 00076 (main.go:10)	JNE	156
	0x004e 00078 (main.go:10)	LEAQ	go.string.&quot;EDDYCJY&quot;(SB), CX
    ...
</code></pre><p>我们将目光集中到 CALL 指令，发现其执行了 <code>runtime.newobject</code> 方法，也就是确实是分配到了堆上。这是为什么呢？</p>
<h4 id="分析结果">分析结果</h4>
<p>这是因为 <code>GetUserInfo()</code> 返回的是指针对象，引用被返回到了方法之外了。因此编译器会把该对象分配到堆上，而不是栈上。否则方法结束之后，局部变量就被回收了，岂不是翻车。所以最终分配到堆上是理所当然的</p>
<h4 id="再想想">再想想</h4>
<p>那你可能会想，那就是所有指针对象，都应该在堆上？并不。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">str</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
	<span class="o">*</span><span class="nx">str</span> <span class="p">=</span> <span class="s">&#34;EDDYCJY&#34;</span>
<span class="p">}</span>
</code></pre></div><p>你想想这个对象会分配到哪里？如下：</p>
<pre><code>$ go build -gcflags '-m -l' main.go
# command-line-arguments
./main.go:4:12: main new(string) does not escape
</code></pre><p>显然，该对象分配到栈上了。很核心的一点就是它有没有被作用域之外所引用，而这里作用域仍然保留在 <code>main</code> 中，因此它没有发生逃逸</p>
<h3 id="案例二未确定类型">案例二：未确定类型</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">str</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
	<span class="o">*</span><span class="nx">str</span> <span class="p">=</span> <span class="s">&#34;EDDYCJY&#34;</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>执行命令观察一下，如下：</p>
<pre><code>$ go build -gcflags '-m -l' main.go
# command-line-arguments
./main.go:9:13: str escapes to heap
./main.go:6:12: new(string) escapes to heap
./main.go:9:13: main ... argument does not escape
</code></pre><p>通过查看分析结果，可得知 <code>str</code> 变量逃到了堆上，也就是该对象在堆上分配。但上个案例时它还在栈上，我们也就 <code>fmt</code> 输出了它而已。这&hellip;到底发生了什么事？</p>
<h4 id="分析结果-1">分析结果</h4>
<p>相对案例一，案例二只加了一行代码 <code>fmt.Println(str)</code>，问题肯定出在它身上。其原型：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>通过对其分析，可得知当形参为 <code>interface</code> 类型时，在编译阶段编译器无法确定其具体的类型。因此会产生逃逸，最终分配到堆上</p>
<p>如果你有兴趣追源码的话，可以看下内部的 <code>reflect.TypeOf(arg).Kind()</code> 语句，其会造成堆逃逸，而表象就是 <code>interface</code> 类型会导致该对象分配到堆上</p>
<h3 id="案例三泄露参数">案例三、泄露参数</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span>     <span class="kt">int64</span>
	<span class="nx">Name</span>   <span class="kt">string</span>
	<span class="nx">Avatar</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetUserInfo</span><span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">User</span><span class="p">)</span> <span class="o">*</span><span class="nx">User</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">u</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nf">GetUserInfo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span><span class="nx">ID</span><span class="p">:</span> <span class="mi">13746731</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;EDDYCJY&#34;</span><span class="p">,</span> <span class="nx">Avatar</span><span class="p">:</span> <span class="s">&#34;https://avatars0.githubusercontent.com/u/13746731&#34;</span><span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>执行命令观察一下，如下：</p>
<pre><code>$ go build -gcflags '-m -l' main.go
# command-line-arguments
./main.go:9:18: leaking param: u to result ~r1 level=0
./main.go:14:63: main &amp;User literal does not escape
</code></pre><p>我们注意到 <code>leaking param</code> 的表述，它说明了变量 <code>u</code> 是一个泄露参数。结合代码可得知其传给 <code>GetUserInfo</code> 方法后，没有做任何引用之类的涉及变量的动作，直接就把这个变量返回出去了。因此这个变量实际上并没有逃逸，它的作用域还在 <code>main()</code> 之中，所以分配在栈上</p>
<h4 id="再想想-1">再想想</h4>
<p>那你再想想怎么样才能让它分配到堆上？结合案例一，举一反三。修改如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span>     <span class="kt">int64</span>
	<span class="nx">Name</span>   <span class="kt">string</span>
	<span class="nx">Avatar</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetUserInfo</span><span class="p">(</span><span class="nx">u</span> <span class="nx">User</span><span class="p">)</span> <span class="o">*</span><span class="nx">User</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">u</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nf">GetUserInfo</span><span class="p">(</span><span class="nx">User</span><span class="p">{</span><span class="nx">ID</span><span class="p">:</span> <span class="mi">13746731</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;EDDYCJY&#34;</span><span class="p">,</span> <span class="nx">Avatar</span><span class="p">:</span> <span class="s">&#34;https://avatars0.githubusercontent.com/u/13746731&#34;</span><span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>执行命令观察一下，如下：</p>
<pre><code>$ go build -gcflags '-m -l' main.go
# command-line-arguments
./main.go:10:9: &amp;u escapes to heap
./main.go:9:18: moved to heap: u
</code></pre><p>只要一小改，它就考虑会被外部所引用，因此妥妥的分配到堆上了</p>
<h2 id="总结">总结</h2>
<p>在本文我给你介绍了逃逸分析的概念和规则，并列举了一些例子加深理解。但实际肯定远远不止这些案例，你需要做到的是掌握方法，遇到再看就好了。除此之外你还需要注意：</p>
<ul>
<li>静态分配到栈上，性能一定比动态分配到堆上好</li>
<li>底层分配到堆，还是栈。实际上对你来说是透明的，不需要过度关心</li>
<li>每个 Go 版本的逃逸分析都会有所不同（会改变，会优化）</li>
<li>直接通过 <code>go build -gcflags '-m -l'</code> 就可以看到逃逸分析的过程和结果</li>
<li>到处都用指针传递并不一定是最好的，要用对</li>
</ul>
<p>之前就有想过要不要写 “逃逸分析” 相关的文章，直到最近看到在夜读里有人问，还是有写的必要。对于这块的知识点。我的建议是适当了解，但没必要硬记。靠基础知识点加命令调试观察就好了。像是曹大之前讲的 “你琢磨半天逃逸分析，一压测，瓶颈在锁上”，完全没必要过度在意&hellip;</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html">Golang escape analysis</a></li>
<li><a href="https://golang.org/doc/faq#stack_or_heap">FAQ</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>为什么遍历 Go map 是无序的</title>
			<link>https://eddycjy.com/posts/go/map/2019-04-07-why-map-no-order/</link>
			<pubDate>Sun, 07 Apr 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/map/2019-04-07-why-map-no-order/</guid>
			<description>有的小伙伴没留意过 Go map 输出顺序，以为它是稳定的有序的；有的小伙伴知道是无序的，但却不知道为什么？有的却理解错误？今天我们将通过本文，揭开 for range map 的 “神秘” 面纱，看看它内部实现到底是怎么样的，输出顺序到底是怎么样？
前言 func main() { m := make(map[int32]string) m[0] = &amp;#34;EDDYCJY1&amp;#34; m[1] = &amp;#34;EDDYCJY2&amp;#34; m[2] = &amp;#34;EDDYCJY3&amp;#34; m[3] = &amp;#34;EDDYCJY4&amp;#34; m[4] = &amp;#34;EDDYCJY5&amp;#34; for k, v := range m { log.Printf(&amp;#34;k: %v, v: %v&amp;#34;, k, v) } } 假设运行这段代码，输出结果是按顺序？还是无序输出呢？
2019/04/03 23:27:29 k: 3, v: EDDYCJY4 2019/04/03 23:27:29 k: 4, v: EDDYCJY5 2019/04/03 23:27:29 k: 0, v: EDDYCJY1 2019/04/03 23:27:29 k: 1, v: EDDYCJY2 2019/04/03 23:27:29 k: 2, v: EDDYCJY3 从输出结果上来讲，是非固定顺序输出的，也就是每次都不一样（标题也讲了）。但这是为什么呢？</description>
			<content type="html"><![CDATA[<p><img src="http://wx2.sinaimg.cn/large/006fVPCvly1g1s1ah84k8j30k70dvaac.jpg" alt="image"></p>
<p>有的小伙伴没留意过 Go map 输出顺序，以为它是稳定的有序的；有的小伙伴知道是无序的，但却不知道为什么？有的却理解错误？今天我们将通过本文，揭开 <code>for range map</code> 的 “神秘” 面纱，看看它内部实现到底是怎么样的，输出顺序到底是怎么样？</p>
<h2 id="前言">前言</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int32</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
	<span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;EDDYCJY1&#34;</span>
	<span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;EDDYCJY2&#34;</span>
	<span class="nx">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;EDDYCJY3&#34;</span>
	<span class="nx">m</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;EDDYCJY4&#34;</span>
	<span class="nx">m</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;EDDYCJY5&#34;</span>

	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;k: %v, v: %v&#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>假设运行这段代码，输出结果是按顺序？还是无序输出呢？</p>
<pre><code>2019/04/03 23:27:29 k: 3, v: EDDYCJY4
2019/04/03 23:27:29 k: 4, v: EDDYCJY5
2019/04/03 23:27:29 k: 0, v: EDDYCJY1
2019/04/03 23:27:29 k: 1, v: EDDYCJY2
2019/04/03 23:27:29 k: 2, v: EDDYCJY3
</code></pre><p>从输出结果上来讲，是非固定顺序输出的，也就是每次都不一样（标题也讲了）。但这是为什么呢？</p>
<p>首先<strong>建议你先自己想想原因</strong>。其次我在面试时听过一些说法。有人说因为是哈希的所以就是无（乱）序等等说法。当时我是有点 ？？？</p>
<p>这也是这篇文章出现的原因，希望大家可以一起研讨一下，理清这个问题 ：）</p>
<h2 id="看一下汇编">看一下汇编</h2>
<pre><code>    ...
	0x009b 00155 (main.go:11)	LEAQ	type.map[int32]string(SB), AX
	0x00a2 00162 (main.go:11)	PCDATA	$2, $0
	0x00a2 00162 (main.go:11)	MOVQ	AX, (SP)
	0x00a6 00166 (main.go:11)	PCDATA	$2, $2
	0x00a6 00166 (main.go:11)	LEAQ	&quot;&quot;..autotmp_3+24(SP), AX
	0x00ab 00171 (main.go:11)	PCDATA	$2, $0
	0x00ab 00171 (main.go:11)	MOVQ	AX, 8(SP)
	0x00b0 00176 (main.go:11)	PCDATA	$2, $2
	0x00b0 00176 (main.go:11)	LEAQ	&quot;&quot;..autotmp_2+72(SP), AX
	0x00b5 00181 (main.go:11)	PCDATA	$2, $0
	0x00b5 00181 (main.go:11)	MOVQ	AX, 16(SP)
	0x00ba 00186 (main.go:11)	CALL	runtime.mapiterinit(SB)
	0x00bf 00191 (main.go:11)	JMP	207
	0x00c1 00193 (main.go:11)	PCDATA	$2, $2
	0x00c1 00193 (main.go:11)	LEAQ	&quot;&quot;..autotmp_2+72(SP), AX
	0x00c6 00198 (main.go:11)	PCDATA	$2, $0
	0x00c6 00198 (main.go:11)	MOVQ	AX, (SP)
	0x00ca 00202 (main.go:11)	CALL	runtime.mapiternext(SB)
	0x00cf 00207 (main.go:11)	CMPQ	&quot;&quot;..autotmp_2+72(SP), $0
	0x00d5 00213 (main.go:11)	JNE	193
	...
</code></pre><p>我们大致看一下整体过程，重点处理 Go map 循环迭代的是两个 runtime 方法，如下：</p>
<ul>
<li>runtime.mapiterinit</li>
<li>runtime.mapiternext</li>
</ul>
<p>但你可能会想，明明用的是 <code>for range</code> 进行循环迭代，怎么出现了这两个函数，怎么回事？</p>
<h2 id="看一下转换后">看一下转换后</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">hiter</span> <span class="nx">map_iteration_struct</span>
<span class="k">for</span> <span class="nf">mapiterinit</span><span class="p">(</span><span class="kd">type</span><span class="p">,</span> <span class="k">range</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">hiter</span><span class="p">);</span> <span class="nx">hiter</span><span class="p">.</span><span class="nx">key</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nf">mapiternext</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">index_temp</span> <span class="p">=</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">.</span><span class="nx">key</span>
    <span class="nx">value_temp</span> <span class="p">=</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">.</span><span class="nx">val</span>
    <span class="nx">index</span> <span class="p">=</span> <span class="nx">index_temp</span>
    <span class="nx">value</span> <span class="p">=</span> <span class="nx">value_temp</span>
    <span class="nx">original</span> <span class="nx">body</span>
<span class="p">}</span>
</code></pre></div><p>实际上编译器对于 slice 和 map 的循环迭代有不同的实现方式，并不是 <code>for</code> 一扔就完事了，还做了一些附加动作进行处理。而上述代码就是 <code>for range map</code> 在编译器展开后的伪实现</p>
<h2 id="看一下源码">看一下源码</h2>
<h3 id="runtimemapiterinit">runtime.mapiterinit</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapiterinit</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">h</span> <span class="p">=</span> <span class="nx">h</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindNoPointers</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">createOverflow</span><span class="p">()</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span>
	<span class="p">}</span>

	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">31</span><span class="o">-</span><span class="nx">bucketCntBits</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span>
	<span class="p">}</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="p">=</span> <span class="nx">r</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">r</span> <span class="o">&gt;&gt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span>
    <span class="o">...</span>

	<span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>通过对 <code>mapiterinit</code> 方法阅读，可得知其主要用途是在 map 进行遍历迭代时<strong>进行初始化动作</strong>。共有三个形参，用于读取当前哈希表的类型信息、当前哈希表的存储信息和当前遍历迭代的数据</p>
<h4 id="为什么">为什么</h4>
<p>咱们关注到源码中 <code>fastrand</code> 的部分，这个方法名，是不是迷之眼熟。没错，它是一个生成随机数的方法。再看看上下文：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="c1">// decide where to start
</span><span class="c1"></span><span class="nx">r</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span>
<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">31</span><span class="o">-</span><span class="nx">bucketCntBits</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span>
<span class="p">}</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span> <span class="p">=</span> <span class="nx">r</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
<span class="nx">it</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">r</span> <span class="o">&gt;&gt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">bucketCnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1">// iterator state
</span><span class="c1"></span><span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">startBucket</span>
</code></pre></div><p>在这段代码中，它生成了随机数。用于决定从哪里开始循环迭代。更具体的话就是根据随机数，选择一个桶位置作为起始点进行遍历迭代</p>
<p>因此每次重新 <code>for range map</code>，你见到的结果都是不一样的。那是因为它的起始位置根本就不固定！</p>
<h3 id="runtimemapiternext">runtime.mapiternext</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapiternext</span><span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">hiter</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="o">...</span>
		<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="nx">v</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">offi</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
		<span class="o">...</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedX</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">offi</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">evacuatedY</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">!(</span><span class="nx">t</span><span class="p">.</span><span class="nx">reflexivekey</span> <span class="o">||</span> <span class="nx">alg</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">k</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">...</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">k</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">v</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">rk</span><span class="p">,</span> <span class="nx">rv</span> <span class="o">:=</span> <span class="nf">mapaccessK</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">rk</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">continue</span> <span class="c1">// key has been deleted
</span><span class="c1"></span>			<span class="p">}</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">rk</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">rv</span>
		<span class="p">}</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">bucket</span>
		<span class="k">if</span> <span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span> <span class="o">!=</span> <span class="nx">b</span> <span class="p">{</span>
			<span class="nx">it</span><span class="p">.</span><span class="nx">bptr</span> <span class="p">=</span> <span class="nx">b</span>
		<span class="p">}</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">checkBucket</span> <span class="p">=</span> <span class="nx">checkBucket</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">goto</span> <span class="nx">next</span>
<span class="p">}</span>
</code></pre></div><p>在上小节中，咱们已经选定了起始桶的位置。接下来就是通过 <code>mapiternext</code> 进行<strong>具体的循环遍历动作</strong>。该方法主要涉及如下：</p>
<ul>
<li>从已选定的桶中开始进行遍历，寻找桶中的下一个元素进行处理</li>
<li>如果桶已经遍历完，则对溢出桶 <code>overflow buckets</code> 进行遍历处理</li>
</ul>
<p>通过对本方法的阅读，可得知其对 buckets 的<strong>遍历规则</strong>以及对于扩容的一些处理（这不是本文重点。因此没有具体展开）</p>
<h2 id="总结">总结</h2>
<p>在本文开始，咱们先提出核心讨论点：“为什么 Go map 遍历输出是不固定顺序？”。而通过这一番分析，原因也很简单明了。就是 <code>for range map</code> 在开始处理循环逻辑的时候，就做了随机播种&hellip;</p>
<p>你想问为什么要这么做？当然是官方有意为之，因为 Go 在早期（1.0）的时候，虽是稳定迭代的，但从结果来讲，其实是无法保证每个 Go 版本迭代遍历规则都是一样的。而这将会导致可移植性问题。因此，改之。也请不要依赖&hellip;</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://blog.golang.org/go-maps-in-action">Go maps in action</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>简单围观一下有趣的 //go: 指令</title>
			<link>https://eddycjy.com/posts/go/talk/2019-03-31-go-ins/</link>
			<pubDate>Sun, 31 Mar 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2019-03-31-go-ins/</guid>
			<description>前言 如果你平时有翻看源码的习惯，你肯定会发现。咦，怎么有的方法上面总是写着 //go: 这类指令呢。他们到底是干嘛用的？
今天我们一同揭开他们的面纱，我将简单给你介绍一下，它们都负责些什么
go:linkname //go:linkname localname importpath.name 该指令指示编译器使用 importpath.name 作为源代码中声明为 localname 的变量或函数的目标文件符号名称。但是由于这个伪指令，可以破坏类型系统和包模块化。因此只有引用了 unsafe 包才可以使用
简单来讲，就是 importpath.name 是 localname 的符号别名，编译器实际上会调用 localname 。但前提是使用了 unsafe 包才能使用
案例 time/time.go ... func now() (sec int64, nsec int32, mono int64) runtime/timestub.go import _ &amp;quot;unsafe&amp;quot; // for go:linkname //go:linkname time_now time.now func time_now() (sec int64, nsec int32, mono int64) { sec, nsec = walltime() return sec, nsec, nanotime() - startNano } 在这个案例中可以看到 time.now，它并没有具体的实现。如果你初看可能会懵逼。这时候建议你全局搜索一下源码，你就会发现其实现在 runtime.time_now 中</description>
			<content type="html"><![CDATA[<p><img src="http://wx2.sinaimg.cn/large/006fVPCvly1g1m1bplu3mj30xc0m8myg.jpg" alt="image"></p>
<h2 id="前言">前言</h2>
<p>如果你平时有翻看源码的习惯，你肯定会发现。咦，怎么有的方法上面总是写着 <code>//go:</code>  这类指令呢。他们到底是干嘛用的？</p>
<p>今天我们一同揭开他们的面纱，我将简单给你介绍一下，它们都负责些什么</p>
<h2 id="golinkname">go:linkname</h2>
<pre><code>//go:linkname localname importpath.name
</code></pre><p>该指令指示编译器使用 <code>importpath.name</code> 作为源代码中声明为 <code>localname</code> 的变量或函数的目标文件符号名称。但是由于这个伪指令，可以破坏类型系统和包模块化。因此只有引用了 unsafe 包才可以使用</p>
<p>简单来讲，就是 <code>importpath.name</code> 是 <code>localname</code> 的符号别名，编译器实际上会调用 <code>localname</code> 。但前提是使用了 <code>unsafe</code> 包才能使用</p>
<h3 id="案例">案例</h3>
<h4 id="timetimego">time/time.go</h4>
<pre><code>...
func now() (sec int64, nsec int32, mono int64)
</code></pre><h4 id="runtimetimestubgo">runtime/timestub.go</h4>
<pre><code>import _ &quot;unsafe&quot; // for go:linkname

//go:linkname time_now time.now
func time_now() (sec int64, nsec int32, mono int64) {
	sec, nsec = walltime()
	return sec, nsec, nanotime() - startNano
}
</code></pre><p>在这个案例中可以看到 <code>time.now</code>，它并没有具体的实现。如果你初看可能会懵逼。这时候建议你全局搜索一下源码，你就会发现其实现在 <code>runtime.time_now</code> 中</p>
<p>配合先前的用法解释，可得知在 runtime 包中，我们声明了 <code>time_now</code> 方法是 <code>time.now</code> 的符号别名。并且在文件头引入了 <code>unsafe</code> 达成前提条件</p>
<h2 id="gonoescape">go:noescape</h2>
<pre><code>//go:noescape
</code></pre><p>该指令指定下一个有声明但没有主体（意味着实现有可能不是 Go）的函数，不允许编译器对其做逃逸分析</p>
<p>一般情况下，该指令用于内存分配优化。因为编译器默认会进行逃逸分析，会通过规则判定一个变量是分配到堆上还是栈上。但凡事有意外，一些函数虽然逃逸分析其是存放到堆上。但是对于我们来说，它是特别的。我们就可以使用 <code>go:noescape</code> 指令强制要求编译器将其分配到函数栈上</p>
<h3 id="案例-1">案例</h3>
<pre><code>// memmove copies n bytes from &quot;from&quot; to &quot;to&quot;.
// in memmove_*.s
//go:noescape
func memmove(to, from unsafe.Pointer, n uintptr)
</code></pre><p>我们观察一下这个案例，它满足了该指令的常见特性。如下：</p>
<ul>
<li>memmove_*.s：只有声明，没有主体。其主体是由底层汇编实现的</li>
<li>memmove：函数功能，在栈上处理性能会更好</li>
</ul>
<h2 id="gonosplit">go:nosplit</h2>
<pre><code>//go:nosplit
</code></pre><p>该指令指定文件中声明的下一个函数不得包含堆栈溢出检查。简单来讲，就是这个函数跳过堆栈溢出的检查</p>
<h3 id="案例-2">案例</h3>
<pre><code>//go:nosplit
func key32(p *uintptr) *uint32 {
	return (*uint32)(unsafe.Pointer(p))
}
</code></pre><h2 id="gonowritebarrierrec">go:nowritebarrierrec</h2>
<pre><code>//go:nowritebarrierrec
</code></pre><p>该指令表示编译器遇到写屏障时就会产生一个错误，并且允许递归。也就是这个函数调用的其他函数如果有写屏障也会报错。简单来讲，就是针对写屏障的处理，防止其死循环</p>
<h3 id="案例-3">案例</h3>
<pre><code>//go:nowritebarrierrec
func gcFlushBgCredit(scanWork int64) {
    ...
}
</code></pre><h2 id="goyeswritebarrierrec">go:yeswritebarrierrec</h2>
<pre><code>//go:yeswritebarrierrec
</code></pre><p>该指令与 <code>go:nowritebarrierrec</code> 相对，在标注 <code>go:nowritebarrierrec</code> 指令的函数上，遇到写屏障会产生错误。而当编译器遇到 <code>go:yeswritebarrierrec</code> 指令时将会停止</p>
<h3 id="案例-4">案例</h3>
<pre><code>//go:yeswritebarrierrec
func gchelper() {
	...
}
</code></pre><h2 id="gonoinline">go:noinline</h2>
<p>该指令表示该函数禁止进行内联</p>
<h3 id="案例-5">案例</h3>
<pre><code>//go:noinline
func unexportedPanicForTesting(b []byte, i int) byte {
	return b[i]
}
</code></pre><p>我们观察一下这个案例，是直接通过索引取值，逻辑比较简单。如果不加上 <code>go:noinline</code> 的话，就会出现编译器对其进行内联优化</p>
<p>显然，内联有好有坏。该指令就是提供这一特殊处理</p>
<h2 id="gonorace">go:norace</h2>
<pre><code>//go:norace
</code></pre><p>该指令表示禁止进行竞态检测。而另外一种常见的形式就是在启动时执行 <code>go run -race</code>，能够检测应用程序中是否存在双向的数据竞争。非常有用</p>
<h3 id="案例-6">案例</h3>
<pre><code>//go:norace
func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err Errno) {
    ...
}
</code></pre><h2 id="gonotinheap">go:notinheap</h2>
<pre><code>//go:notinheap
</code></pre><p>该指令常用于类型声明，它表示这个类型不允许从 GC 堆上进行申请内存。在运行时中常用其来做较低层次的内部结构，避免调度器和内存分配中的写屏障。能够提高性能</p>
<h3 id="案例-7">案例</h3>
<pre><code>// notInHeap is off-heap memory allocated by a lower-level allocator
// like sysAlloc or persistentAlloc.
//
// In general, it's better to use real types marked as go:notinheap,
// but this serves as a generic type for situations where that isn't
// possible (like in the allocators).
//
//go:notinheap
type notInHeap struct{}
</code></pre><h2 id="总结">总结</h2>
<p>在本文我们简单介绍了一些常见的指令集，我建议仅供了解。一般我们是用不到的，因为你的瓶颈可能更多的在自身应用上</p>
<p>但是了解这一些，对你了解底层源码和运行机制会更有帮助。如果想再深入些，可阅读我给出的参考链接 ：）</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/HACKING.md">HACKING</a></li>
<li><a href="https://golang.org/cmd/compile/">Command compile</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>深入理解 Go map：赋值和扩容迁移</title>
			<link>https://eddycjy.com/posts/go/map/2019-03-24-map-assign/</link>
			<pubDate>Sun, 24 Mar 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/map/2019-03-24-map-assign/</guid>
			<description>概要 在 上一章节 中，数据结构小节里讲解了大量基础字段，可能你会疑惑需要 #&amp;amp;（！……#（！￥！ 来干嘛？接下来我们一起简单了解一下基础概念。再开始研讨今天文章的重点内容。我相信这样你能更好的读懂这篇文章
哈希函数 哈希函数，又称散列算法、散列函数。主要作用是通过特定算法将数据根据一定规则组合重新生成得到一个散列值
而在哈希表中，其生成的散列值常用于寻找其键映射到哪一个桶上。而一个好的哈希函数，应当尽量少的出现哈希冲突，以此保证操作哈希表的时间复杂度（但是哈希冲突在目前来讲，是无法避免的。我们需要 “解决” 它）
链地址法 在哈希操作中，相当核心的一个处理动作就是 “哈希冲突” 的解决。而在 Go map 中采用的就是 &amp;ldquo;链地址法 &amp;quot; 去解决哈希冲突，又称 &amp;ldquo;拉链法&amp;rdquo;。其主要做法是数组 + 链表的数据结构，其溢出节点的存储内存都是动态申请的，因此相对更灵活。而每一个元素都是一个链表。如下图：
桶/溢出桶 type hmap struct { ... buckets unsafe.Pointer ... extra *mapextra } type mapextra struct { overflow *[]*bmap oldoverflow *[]*bmap nextOverflow *bmap } 在上章节中，我们介绍了 Go map 中的桶和溢出桶的概念，在其桶中只能存储 8 个键值对元素。当超过 8 个时，将会使用溢出桶进行存储或进行扩容
你可能会有疑问，hint 大于 8 又会怎么样？答案很明显，性能问题，其时间复杂度改变（也就是执行效率出现问题）
前言 概要复习的差不多后，接下来我们将一同研讨 Go map 的另外三个核心行为：赋值、扩容、迁移。正式开始我们的研讨之旅吧 ：）
赋值 m := make(map[int32]string) m[0] = &amp;#34;EDDYCJY&amp;#34; 函数原型 在 map 的赋值动作中，依旧是针对 32/64 位、string、pointer 类型有不同的转换处理，总的函数原型如下：</description>
			<content type="html"><![CDATA[<h2 id="概要">概要</h2>
<p>在 <a href="https://book.eddycjy.com/golang/map/map-access.html">上一章节</a> 中，数据结构小节里讲解了大量基础字段，可能你会疑惑需要 #&amp;（！……#（！￥！ 来干嘛？接下来我们一起简单了解一下基础概念。再开始研讨今天文章的重点内容。我相信这样你能更好的读懂这篇文章</p>
<h3 id="哈希函数">哈希函数</h3>
<p>哈希函数，又称散列算法、散列函数。主要作用是通过特定算法将数据根据一定规则组合重新生成得到一个<strong>散列值</strong></p>
<p>而在哈希表中，其生成的散列值常用于寻找其键映射到哪一个桶上。而一个好的哈希函数，应当尽量少的出现哈希冲突，以此保证操作哈希表的时间复杂度（但是哈希冲突在目前来讲，是无法避免的。我们需要 “解决” 它）</p>
<p><img src="http://wx3.sinaimg.cn/large/006fVPCvly1g161h7r7hgj30is0dmjro.jpg" alt="image"></p>
<h3 id="链地址法">链地址法</h3>
<p>在哈希操作中，相当核心的一个处理动作就是 “哈希冲突” 的解决。而在 Go map 中采用的就是 &ldquo;链地址法 &quot; 去解决哈希冲突，又称 &ldquo;拉链法&rdquo;。其主要做法是数组 + 链表的数据结构，其溢出节点的存储内存都是动态申请的，因此相对更灵活。而每一个元素都是一个链表。如下图：</p>
<p><img src="http://wx4.sinaimg.cn/large/006fVPCvly1g1dw2b8t0ej30e60cy747.jpg" alt="image"></p>
<h3 id="桶溢出桶">桶/溢出桶</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
    <span class="o">...</span>
	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
<span class="p">}</span>
</code></pre></div><p>在上章节中，我们介绍了 Go map 中的桶和溢出桶的概念，在其桶中只能存储 8 个键值对元素。当超过 8 个时，将会使用溢出桶进行存储或进行扩容</p>
<p>你可能会有疑问，hint 大于 8 又会怎么样？答案很明显，性能问题，其时间复杂度改变（也就是执行效率出现问题）</p>
<h2 id="前言">前言</h2>
<p>概要复习的差不多后，接下来我们将一同研讨 Go map 的另外三个核心行为：赋值、扩容、迁移。正式开始我们的研讨之旅吧 ：）</p>
<h2 id="赋值">赋值</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int32</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
<span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;EDDYCJY&#34;</span>
</code></pre></div><h3 id="函数原型">函数原型</h3>
<p>在 map 的赋值动作中，依旧是针对 32/64 位、string、pointer 类型有不同的转换处理，总的函数原型如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="kd">func</span> <span class="nf">mapaccess1_fast32</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint32</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="kd">func</span> <span class="nf">mapaccess2_fast32</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">mapassign_fast32</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint32</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="kd">func</span> <span class="nf">mapassign_fast32ptr</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>

<span class="kd">func</span> <span class="nf">mapaccess1_fast64</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="kd">func</span> <span class="nf">mapaccess2_fast64</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">mapassign_fast64</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="kd">func</span> <span class="nf">mapassign_fast64ptr</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="kd">func</span> <span class="nf">mapaccess1_faststr</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">ky</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="kd">func</span> <span class="nf">mapaccess2_faststr</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">ky</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">mapassign_faststr</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="o">...</span>
</code></pre></div><p>接下来我们将分成几个部分去看看底层在赋值的时候，都做了些什么处理？</p>
<h3 id="源码">源码</h3>
<h4 id="第一阶段校验和初始化">第一阶段：校验和初始化</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;assignment to entry in nil map&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map writes&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">alg</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">alg</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">alg</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>

	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">hashWriting</span>

	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">)</span> <span class="c1">// newarray(t.bucket, 1)
</span><span class="c1"></span>	<span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>判断 hmap 是否已经初始化（是否为 nil）</li>
<li>判断是否并发读写 map，若是则抛出异常</li>
<li>根据 key 的不同类型调用不同的 hash 方法计算得出 hash 值</li>
<li>设置 flags 标志位，表示有一个 goroutine 正在写入数据。因为 <code>alg.hash</code> 有可能出现 <code>panic</code> 导致异常</li>
<li>判断 buckets 是否为 nil，若是则调用 <code>newobject</code> 根据当前 bucket 大小进行分配（例如：上章节提到的 <code>makemap_small</code> 方法，就在初始化时没有初始 buckets，那么它在第一次赋值时就会对 buckets 分配）</li>
</ul>
<h4 id="第二阶段寻找可插入位和更新既有值">第二阶段：寻找可插入位和更新既有值</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="nx">again</span><span class="p">:</span>
	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">)</span> <span class="o">+</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">inserti</span> <span class="o">*</span><span class="kt">uint8</span>
	<span class="kd">var</span> <span class="nx">insertk</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="kd">var</span> <span class="nx">val</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">empty</span> <span class="o">&amp;&amp;</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
					<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
					<span class="nx">val</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">indirectkey</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">alg</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// already have a mapping for key. Update it.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">needkeyupdate</span> <span class="p">{</span>
				<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">val</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
			<span class="k">goto</span> <span class="nx">done</span>
		<span class="p">}</span>
		<span class="nx">ovf</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ovf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">b</span> <span class="p">=</span> <span class="nx">ovf</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">again</span> <span class="c1">// Growing the table invalidates everything, so try again
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="o">...</span>
</code></pre></div><ul>
<li>根据低八位计算得到 bucket 的内存地址，并判断是否正在扩容，若正在扩容中则先迁移再接着处理</li>
<li>计算并得到 bucket 的 bmap 指针地址，计算 key hash 高八位用于查找 Key</li>
<li>迭代 buckets 中的每一个 bucket（共 8 个），对比 <code>bucket.tophash</code> 与 top（高八位）是否一致</li>
<li>若不一致，判断是否为空槽。若是空槽（有两种情况，第一种是<strong>没有插入过</strong>。第二种是<strong>插入后被删除</strong>），则把该位置标识为可插入 tophash 位置。注意，这里就是第一个可以插入数据的地方</li>
<li>若 key 与当前 k 不匹配则跳过。但若是匹配（也就是原本已经存在），则进行更新。最后跳出并返回 value 的内存地址</li>
<li>判断是否迭代完毕，若是则结束迭代 buckets 并更新当前桶位置</li>
<li>若满足三个条件：触发最大 <code>LoadFactor</code> 、存在过多溢出桶 <code>overflow buckets</code>、没有正在进行扩容。就会进行扩容动作（以确保后续的动作）</li>
</ul>
<p>总的来讲，这一块逻辑做了两件大事，第一是<strong>寻找空位，将位置其记录在案，用于后续的插入动作</strong>。第二是<strong>判断 Key 是否已经存在哈希表中，存在则进行更新</strong>。而若是第二种场景，更新完毕后就会进行收尾动作，第一种将继续执行下述的代码</p>
<h4 id="第三阶段申请新的插入位和插入新值">第三阶段：申请新的插入位和插入新值</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="o">...</span>
	<span class="k">if</span> <span class="nx">inserti</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">newb</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
		<span class="nx">inserti</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newb</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">insertk</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newb</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
		<span class="nx">val</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">insertk</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">indirectkey</span> <span class="p">{</span>
		<span class="nx">kmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">insertk</span><span class="p">)</span> <span class="p">=</span> <span class="nx">kmem</span>
		<span class="nx">insertk</span> <span class="p">=</span> <span class="nx">kmem</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">indirectvalue</span> <span class="p">{</span>
		<span class="nx">vmem</span> <span class="o">:=</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">val</span><span class="p">)</span> <span class="p">=</span> <span class="nx">vmem</span>
	<span class="p">}</span>
	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">insertk</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="o">*</span><span class="nx">inserti</span> <span class="p">=</span> <span class="nx">top</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>

<span class="nx">done</span><span class="p">:</span>
	<span class="o">...</span>
	<span class="k">return</span> <span class="nx">val</span>

</code></pre></div><p>经过前面迭代寻找动作，若没有找到可插入的位置，意味着当前的所有桶都满了，将重新分配一个新溢出桶用于插入动作。最后再在上一步申请的新插入位置，存储键值对，返回该值的内存地址</p>
<h4 id="第四阶段写入">第四阶段：写入</h4>
<p>但是这里又疑惑了？最后为什么是返回内存地址。这是因为隐藏的最后一步写入动作（将值拷贝到指定内存区域）是通过底层汇编配合来完成的，在 runtime 中只完成了绝大部分的动作</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int32</span><span class="p">]</span><span class="kt">int32</span><span class="p">)</span>
	<span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">6666666</span>
<span class="p">}</span>
</code></pre></div><p>对应的汇编部分：</p>
<pre><code>...
0x0099 00153 (test.go:6)	CALL	runtime.mapassign_fast32(SB)
0x009e 00158 (test.go:6)	PCDATA	$2, $2
0x009e 00158 (test.go:6)	MOVQ	24(SP), AX
0x00a3 00163 (test.go:6)	PCDATA	$2, $0
0x00a3 00163 (test.go:6)	MOVL	$6666666, (AX)
</code></pre><p>这里分为了几个部位，主要是调用 <code>mapassign</code> 函数和拿到值存放的内存地址，再将 6666666 这个值存放进该内存地址中。另外我们看到 <code>PCDATA</code> 指令，主要是包含一些垃圾回收的信息，由编译器产生</p>
<h3 id="小结">小结</h3>
<p>通过前面几个阶段的分析，我们可梳理出一些要点。例如：</p>
<ul>
<li>不同类型对应哈希函数不一样</li>
<li>高八位用于定位 bucket</li>
<li>低八位用于定位 key，快速试错后再进行完整对比</li>
<li>buckets/overflow buckets 遍历</li>
<li>可插入位的处理</li>
<li>最终写入动作与底层汇编的交互</li>
</ul>
<h2 id="扩容">扩容</h2>
<p>在所有动作中，扩容规则是大家较关注的点，也是赋值里非常重要的一环。因此咱们将这节拉出来，对这块细节进行研讨</p>
<h3 id="什么时候扩容">什么时候扩容</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">))</span> <span class="p">{</span>
	<span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
	<span class="k">goto</span> <span class="nx">again</span>
<span class="p">}</span>
</code></pre></div><p>在特定条件的情况下且当前没有正在进行扩容动作（以判断 <code>hmap.oldbuckets != nil</code> 为基准）。哈希表在赋值、删除的动作下会触发扩容行为，条件如下：</p>
<ul>
<li>触发 <code>load factor</code> 的最大值，负载因子已达到当前界限</li>
<li>溢出桶 <code>overflow buckets</code> 过多</li>
</ul>
<h3 id="什么时候受影响">什么时候受影响</h3>
<p>那么什么情况下会对这两个 “值” 有影响呢？如下：</p>
<ol>
<li>负载因子 <code>load factor</code>，用途是评估哈希表当前的时间复杂度，其与哈希表当前包含的键值对数、桶数量等相关。如果负载因子越大，则说明空间使用率越高，但产生哈希冲突的可能性更高。而负载因子越小，说明空间使用率低，产生哈希冲突的可能性更低</li>
<li>溢出桶 <code>overflow buckets</code> 的判定与 buckets 总数和 overflow buckets 总数相关联</li>
</ol>
<h3 id="因子关系">因子关系</h3>
<table>
<thead>
<tr>
<th>loadFactor</th>
<th>%overflow</th>
<th>bytes/entry</th>
<th>hitprobe</th>
<th>missprobe</th>
</tr>
</thead>
<tbody>
<tr>
<td>4.00</td>
<td>2.13</td>
<td>20.77</td>
<td>3.00</td>
<td>4.00</td>
</tr>
<tr>
<td>4.50</td>
<td>4.05</td>
<td>17.30</td>
<td>3.25</td>
<td>4.50</td>
</tr>
<tr>
<td>5.00</td>
<td>6.85</td>
<td>14.77</td>
<td>3.50</td>
<td>5.00</td>
</tr>
<tr>
<td>5.50</td>
<td>10.55</td>
<td>12.94</td>
<td>3.75</td>
<td>5.50</td>
</tr>
<tr>
<td>6.00</td>
<td>15.27</td>
<td>11.67</td>
<td>4.00</td>
<td>6.00</td>
</tr>
<tr>
<td>6.50</td>
<td>20.90</td>
<td>10.79</td>
<td>4.25</td>
<td>6.50</td>
</tr>
<tr>
<td>7.00</td>
<td>27.14</td>
<td>10.15</td>
<td>4.50</td>
<td>7.00</td>
</tr>
</tbody>
</table>
<ul>
<li>loadFactor：负载因子</li>
<li>%overflow：溢出率，具有溢出桶 <code>overflow buckets</code> 的桶的百分比</li>
<li>bytes/entry：每个键值对所的字节数开销</li>
<li>hitprobe：查找存在的 key 时，平均需要检索的条目数量</li>
<li>missprobe：查找不存在的 key 时，平均需要检索的条目数量</li>
</ul>
<p>这一组数据能够体现出不同的负载因子会给哈希表的动作带来怎么样的影响。而在上一章节我们有提到默认的负载因子是 6.5 (loadFactorNum/loadFactorDen)，可以看出来是经过测试后取出的一个比较合理的因子。能够较好的影响哈希表的扩容动作的时机</p>
<h3 id="源码剖析">源码剖析</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">bigger</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">bigger</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">sameSizeGrow</span>
	<span class="p">}</span>
	<span class="nx">oldbuckets</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
	<span class="nx">newbuckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">:=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="o">+</span><span class="nx">bigger</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="o">...</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span> <span class="p">=</span> <span class="nx">oldbuckets</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">=</span> <span class="nx">newbuckets</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;oldoverflow is not nil&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
	<span class="p">}</span>

	<span class="c1">// the actual copying of the hash table data is done incrementally
</span><span class="c1"></span>	<span class="c1">// by growWork() and evacuate().
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="第一阶段确定扩容容量规则">第一阶段：确定扩容容量规则</h4>
<p>在上小节有讲到扩容的依据有两种，在 <code>hashGrow</code> 开头就进行了划分。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="p">!</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">bigger</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">sameSizeGrow</span>
<span class="p">}</span>
</code></pre></div><p>若不是负载因子 <code>load factor</code> 超过当前界限，也就是属于溢出桶 <code>overflow buckets</code> 过多的情况。因此本次扩容规则将是 <code>sameSizeGrow</code>，即是<strong>不改变大小的扩容动作</strong>。那要是前者的情况呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">bigger</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">...</span>
<span class="nx">newbuckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">:=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="o">+</span><span class="nx">bigger</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</code></pre></div><p>结合代码分析可得出，若是负载因子 <code>load factor</code> 达到当前界限，将会动态扩容<strong>当前大小的两倍</strong>作为其新容量大小</p>
<h4 id="第二阶段初始化交换新旧-桶溢出桶">第二阶段：初始化、交换新旧 桶/溢出桶</h4>
<p>主要是针对扩容的相关数据<strong>前置处理</strong>，涉及 buckets/oldbuckets、overflow/oldoverflow 之类与存储相关的字段</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="nx">oldbuckets</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span>
<span class="nx">newbuckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">:=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="o">+</span><span class="nx">bigger</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

<span class="nx">flags</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">iterator</span> <span class="p">|</span> <span class="nx">oldIterator</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">iterator</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
	<span class="nx">flags</span> <span class="o">|=</span> <span class="nx">oldIterator</span>
<span class="p">}</span>

<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">+=</span> <span class="nx">bigger</span>
<span class="o">...</span>
<span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span> <span class="p">=</span> <span class="mi">0</span>

<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">oldoverflow</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
<span class="p">}</span>
</code></pre></div><p>这里注意到这段代码： <code>newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)</code>。第一反应是扩容的时候就马上申请并初始化内存了吗？假设涉及大量的内存分配，那挺耗费性能的&hellip;</p>
<p>然而并不，内部只会先进行预分配，当使用的时候才会真正的去初始化</p>
<h4 id="第三阶段扩容">第三阶段：扩容</h4>
<p>在源码中，发现第三阶段的流转并没有显式展示。这是因为流转由底层去做控制了。但通过分析代码和注释，可得知由第三阶段涉及 <code>growWork</code> 和 <code>evacuate</code> 方法。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nf">oldbucketmask</span><span class="p">())</span>

	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在该方法中，主要是两个 <code>evacuate</code> 函数的调用。他们在调用上又分别有什么区别呢？如下：</p>
<ul>
<li>evacuate(t, h, bucket&amp;h.oldbucketmask()): 将 oldbucket 中的元素迁移 rehash 到扩容后的新 bucket</li>
<li>evacuate(t, h, h.nevacuate): 如果当前正在进行扩容，则再进行多一次迁移</li>
</ul>
<p>另外，在执行扩容动作的时候，可以发现都是以 bucket/oldbucket 为单位的，而不是传统的 buckets/oldbuckets。再结合代码分析，可得知在 Go map 中<strong>扩容是采取增量扩容的方式，并非一步到位</strong></p>
<h5 id="为什么是增量扩容">为什么是增量扩容？</h5>
<p>如果是全量扩容的话，那问题就来了。假设当前 hmap 的容量比较大，直接全量扩容的话，就会导致扩容要花费大量的时间和内存，导致系统卡顿，最直观的表现就是慢。显然，不能这么做</p>
<p>而增量扩容，就可以解决这个问题。它通过每一次的 map 操作行为去分摊总的一次性动作。因此有了 buckets/oldbuckets 的设计，它是逐步完成的，并且会在扩容完毕后才进行清空</p>
<h3 id="小结-1">小结</h3>
<p>通过前面三个阶段的分析，可以得知扩容的大致过程。我们阶段性总结一下。主要如下：</p>
<ul>
<li>根据需扩容的原因不同（overLoadFactor/tooManyOverflowBuckets），分为两类容量规则方向，为等量扩容（不改变原有大小）或双倍扩容</li>
<li>新申请的扩容空间（newbuckets/newoverflow）都是预分配，等真正使用的时候才会初始化</li>
<li>扩容完毕后（预分配），不会马上就进行迁移。而是采取<strong>增量扩容</strong>的方式，当有访问到具体 bukcet 时，才会逐渐的进行迁移（将 oldbucket 迁移到 bucket）</li>
</ul>
<p>这时候又想到，既然迁移是逐步进行的。那如果在途中又要扩容了，怎么办？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">again</span><span class="p">:</span>
	<span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
    <span class="o">...</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="o">||</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">noverflow</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">hashGrow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">again</span>
	<span class="p">}</span>
</code></pre></div><p>在这里注意到 <code>goto again</code> 语句，结合上下文可得若正在进行扩容，就会不断地进行迁移。待迁移完毕后才会开始进行下一次的扩容动作</p>
<h2 id="迁移">迁移</h2>
<p>在扩容的完整闭环中，包含着迁移的动作，又称 “搬迁”。因此我们继续深入研究 <code>evacuate</code> 函数。接下来一起打开迁移世界的大门。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">evacDst</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">i</span> <span class="kt">int</span>
	<span class="nx">k</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
</code></pre></div><p><code>evacDst</code> 是迁移中的基础数据结构，其包含如下字段：</p>
<ul>
<li>b: 当前目标桶</li>
<li>i: 当前目标桶存储的键值对数量</li>
<li>k: 指向当前 key 的内存地址</li>
<li>v: 指向当前 value 的内存地址</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">oldbucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="nx">newbit</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">noldbuckets</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">xy</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="nx">evacDst</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">v</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>

		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">y</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">y</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">oldbucket</span><span class="o">+</span><span class="nx">newbit</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
			<span class="nx">y</span><span class="p">.</span><span class="nx">k</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">y</span><span class="p">.</span><span class="nx">v</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">...</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">oldIterator</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindNoPointers</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">,</span> <span class="nx">oldbucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">))</span>
			<span class="nx">ptr</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">dataOffset</span><span class="p">)</span>
			<span class="nx">n</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)</span> <span class="o">-</span> <span class="nx">dataOffset</span>
			<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">oldbucket</span> <span class="o">==</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span> <span class="p">{</span>
		<span class="nf">advanceEvacuationMark</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">newbit</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>计算并得到 oldbucket 的 bmap 指针地址</li>
<li>计算 hmap 在增长之前的桶数量</li>
<li>判断当前的迁移（搬迁）状态，以便流转后续的操作。若没有正在进行迁移 <code>!evacuated(b)</code> ，则根据扩容的规则的不同，当规则为等量扩容 <code>sameSizeGrow</code> 时，只使用一个 <code>evacDst</code> 桶用于分流。而为双倍扩容时，就会使用两个 <code>evacDst</code> 进行分流操作</li>
<li>当分流完毕后，需要迁移的数据都会通过 <code>typedmemmove</code> 函数迁移到指定的目标桶上</li>
<li>若当前不存在 flags 使用标志、使用 oldbucket 迭代器、bucket 不为指针类型。则取消链接溢出桶、清除键值</li>
<li>在最后 <code>advanceEvacuationMark</code> 函数中会对迁移进度 <code>hmap.nevacuate</code> 进行累积计数，并调用 <code>bucketEvacuated</code> 对旧桶 oldbuckets 进行不断的迁移。直至全部迁移完毕。那么也就表示扩容完毕了，会对 <code>hmap.oldbuckets</code> 和 <code>h.extra.oldoverflow</code> 进行清空</li>
</ul>
<p>总的来讲，就是计算得到所需数据的位置。再根据当前的迁移状态、扩容规则进行数据分流迁移。结束后进行清理，促进 GC 的回收</p>
<h2 id="总结">总结</h2>
<p>在本章节我们主要研讨了 Go map 的几个核心动作，分别是：“赋值、扩容、迁移” 。而通过本次的阅读，我们能够更进一步的认识到一些要点，例如：</p>
<ul>
<li>赋值的时候会触发扩容吗？</li>
<li>负载因子是什么？过高会带来什么问题？它的变动会对哈希表操作带来什么影响吗？</li>
<li>溢出桶越多会带来什么问题？</li>
<li>是否要扩容的基准条件是什么？</li>
<li>扩容的容量规则是怎么样的？</li>
<li>扩容的步骤是怎么样的？涉及到了哪些数据结构？</li>
<li>扩容是一次性扩容还是增量扩容？</li>
<li>正在扩容的时候又要扩容怎么办？</li>
<li>扩容时的迁移分流动作是怎么样的？</li>
<li>在扩容动作中，底层汇编承担了什么角色？做了什么事？</li>
<li>在 buckets/overflow buckets 中寻找时，是如何 “快速” 定位值的？低八位、高八位的用途？</li>
<li>空槽有可能出现在任意位置吗？假设已经没有空槽了，但是又有新值要插入，底层会怎么处理</li>
</ul>
<p>最后希望你通过本文的阅读，能更清楚地了解到 Go map 是怎么样运作的 ：）</p>
]]></content>
		</item>
		
		<item>
			<title>深入理解 Go map：初始化和访问元素</title>
			<link>https://eddycjy.com/posts/go/map/2019-03-05-map-access/</link>
			<pubDate>Tue, 05 Mar 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/map/2019-03-05-map-access/</guid>
			<description>从本文开始咱们一起探索 Go map 里面的奥妙吧，看看它的内在是怎么构成的，又分别有什么值得留意的地方？
第一篇将探讨初始化和访问元素相关板块，咱们带着疑问去学习，例如：
 初始化的时候会马上分配内存吗？ 底层数据是如何存储的？ 底层是如何使用 key 去寻找数据的？ 底层是用什么方式解决哈希冲突的？ 数据类型那么多，底层又是怎么处理的呢？  &amp;hellip;
数据结构 首先我们一起看看 Go map 的基础数据结构，先有一个大致的印象
hmap type hmap struct { count int flags uint8 B uint8 noverflow uint16 hash0 uint32 buckets unsafe.Pointer oldbuckets unsafe.Pointer nevacuate uintptr extra *mapextra } type mapextra struct { overflow *[]*bmap oldoverflow *[]*bmap nextOverflow *bmap }  count：map 的大小，也就是 len() 的值。代指 map 中的键值对个数 flags：状态标识，主要是 goroutine 写入和扩容机制的相关状态控制。并发读写的判断条件之一就是该值 B：桶，最大可容纳的元素数量，值为 负载因子（默认 6.5） * 2 ^ B，是 2 的指数 noverflow：溢出桶的数量 hash0：哈希因子 buckets：保存当前桶数据的指针地址（指向一段连续的内存地址，主要存储键值对数据） oldbuckets，保存旧桶的指针地址 nevacuate：迁移进度 extra：原有 buckets 满载后，会发生扩容动作，在 Go 的机制中使用了增量扩容，如下为细项：  overflow 为 hmap.</description>
			<content type="html"><![CDATA[<p>从本文开始咱们一起探索 Go map 里面的奥妙吧，看看它的内在是怎么构成的，又分别有什么值得留意的地方？</p>
<p>第一篇将探讨<strong>初始化和访问元素</strong>相关板块，咱们带着疑问去学习，例如：</p>
<ul>
<li>初始化的时候会马上分配内存吗？</li>
<li>底层数据是如何存储的？</li>
<li>底层是如何使用 key 去寻找数据的？</li>
<li>底层是用什么方式解决哈希冲突的？</li>
<li>数据类型那么多，底层又是怎么处理的呢？</li>
</ul>
<p>&hellip;</p>
<h2 id="数据结构">数据结构</h2>
<p>首先我们一起看看 Go map 的基础数据结构，先有一个大致的印象</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLgjH.png" alt="image"></p>
<h3 id="hmap">hmap</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">count</span>     <span class="kt">int</span>
	<span class="nx">flags</span>     <span class="kt">uint8</span>
	<span class="nx">B</span>         <span class="kt">uint8</span>
	<span class="nx">noverflow</span> <span class="kt">uint16</span>
	<span class="nx">hash0</span>     <span class="kt">uint32</span>
	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span>
	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>
	<span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>count：map 的大小，也就是 len() 的值。代指 map 中的键值对个数</li>
<li>flags：状态标识，主要是 goroutine 写入和扩容机制的相关状态控制。并发读写的判断条件之一就是该值</li>
<li>B：桶，最大可容纳的元素数量，值为 <strong>负载因子（默认 6.5） * 2 ^ B</strong>，是 2 的指数</li>
<li>noverflow：溢出桶的数量</li>
<li>hash0：哈希因子</li>
<li>buckets：保存当前桶数据的指针地址（指向一段连续的内存地址，主要存储键值对数据）</li>
<li>oldbuckets，保存旧桶的指针地址</li>
<li>nevacuate：迁移进度</li>
<li>extra：原有 buckets 满载后，会发生扩容动作，在 Go 的机制中使用了增量扩容，如下为细项：
<ul>
<li><code>overflow</code> 为 <code>hmap.buckets</code> （当前）溢出桶的指针地址</li>
<li><code>oldoverflow</code> 为 <code>hmap.oldbuckets</code> （旧）溢出桶的指针地址</li>
<li><code>nextOverflow</code> 为空闲溢出桶的指针地址</li>
</ul>
</li>
</ul>
<p>在这里我们要注意几点，如下：</p>
<ol>
<li>如果 keys 和 values 都不包含指针并且允许内联的情况下。会将 bucket 标识为不包含指针，使用 extra 存储溢出桶就可以避免 GC 扫描整个 map，节省不必要的开销</li>
<li>在前面有提到，Go 用了增量扩容。而 <code>buckets</code> 和 <code>oldbuckets</code> 也是与扩容相关的载体，一般情况下只使用 <code>buckets</code>，<code>oldbuckets</code> 是为空的。但如果正在扩容的话，<code>oldbuckets</code> 便不为空，<code>buckets</code> 的大小也会改变</li>
<li>当 <code>hint</code> 大于 8 时，就会使用 <code>*mapextra</code> 做溢出桶。若小于 8，则存储在 buckets 桶中</li>
</ol>
<h3 id="bmap">bmap</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLz5V.png" alt="image"></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">bucketCntBits</span> <span class="p">=</span> <span class="mi">3</span>
<span class="nx">bucketCnt</span>     <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">bucketCntBits</span>
<span class="o">...</span>
<span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>tophash：key 的 hash 值高 8 位</li>
<li>keys：8 个 key</li>
<li>values：8 个 value</li>
<li>overflow：下一个溢出桶的指针地址（当 hash 冲突发生时）</li>
</ul>
<p>实际 bmap 就是 buckets 中的 bucket，一个 bucket 最多存储 8 个键值对</p>
<h4 id="tophash">tophash</h4>
<p>tophash 是个长度为 8 的数组，代指桶最大可容纳的键值对为 8。</p>
<p>存储每个元素 hash 值的高 8 位，如果 <code>tophash [0] &lt;minTopHash</code>，则 <code>tophash [0]</code> 表示为迁移进度</p>
<h4 id="keys-和-values">keys 和 values</h4>
<p>在这里我们留意到，存储 k 和 v 的载体并不是用 <code>k/v/k/v/k/v/k/v</code> 的模式，而是 <code>k/k/k/k/v/v/v/v</code> 的形式去存储。这是为什么呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">map</span><span class="p">[</span><span class="kt">int64</span><span class="p">]</span><span class="kt">int8</span>
</code></pre></div><p>在这个例子中，如果按照 <code>k/v/k/v/k/v/k/v</code> 的形式存放的话，虽然每个键值对的值都只占用 1 个字节。但是却需要 7 个填充字节来补齐内存空间。最终就会造成大量的内存 “浪费”</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3dOK2D.png" alt="image"></p>
<p>但是如果以 <code>k/k/k/k/v/v/v/v</code> 的形式存放的话，就能够解决因对齐所 &ldquo;浪费&rdquo; 的内存空间</p>
<p>因此这部分的拆分主要是考虑到内存对齐的问题，虽然相对会复杂一点，但依然值得如此设计</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3dODqs.png" alt="image"></p>
<h4 id="overflow">overflow</h4>
<p>可能会有同学疑惑为什么会有溢出桶这个东西？实际上在不存在哈希冲突的情况下，去掉溢出桶，也就是只需要桶、哈希因子、哈希算法。也能实现一个简单的 hash table。但是哈希冲突（碰撞）是不可避免的&hellip;</p>
<p>而在 Go map 中当 <code>hmap.buckets</code> 满了后，就会使用溢出桶接着存储。我们结合分析可确定 Go 采用的是数组 + 链地址法解决哈希冲突</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3dO7Ix.png" alt="image"></p>
<h2 id="初始化">初始化</h2>
<h3 id="用法">用法</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int32</span><span class="p">]</span><span class="kt">int32</span><span class="p">)</span>
</code></pre></div><h3 id="函数原型">函数原型</h3>
<p>通过阅读源码可得知，初始化方法有好几种。函数原型如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makemap_small</span><span class="p">()</span> <span class="o">*</span><span class="nx">hmap</span>
<span class="kd">func</span> <span class="nf">makemap64</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span>
<span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span>
</code></pre></div><ul>
<li>makemap_small：当 <code>hint</code> 小于 8 时，会调用 <code>makemap_small</code> 来初始化 hmap。主要差异在于是否会马上初始化 hash table</li>
<li>makemap64：当 <code>hint</code> 类型为 int64 时的特殊转换及校验处理，后续实质调用 <code>makemap</code></li>
<li>makemap：实现了标准的 map 初始化动作</li>
</ul>
<h3 id="源码">源码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">hint</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">hint</span> <span class="p">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="nf">maxSliceCap</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">hint</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>

	<span class="nx">B</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">hint</span><span class="p">,</span> <span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">B</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span>

	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>根据传入的 <code>bucket</code> 类型，获取其类型能够申请的最大容量大小。并对其长度 <code>make(map[k]v, hint)</code> 进行边界值检验</li>
<li>初始化 hmap</li>
<li>初始化哈希因子</li>
<li>根据传入的 <code>hint</code>，计算一个可以放下 <code>hint</code> 个元素的桶 <code>B</code> 的最小值</li>
<li>分配并初始化 hash table。如果 <code>B</code> 为 0 将在后续懒惰分配桶，大于 0 则会马上进行分配</li>
<li>返回初始化完毕的 hmap</li>
</ul>
<p>在这里可以注意到，（当 <code>hint</code> 大于等于 8 ）第一次初始化 map 时，就会通过调用 <code>makeBucketArray</code> 对 buckets 进行分配。因此我们常常会说，在初始化时指定一个适当大小的容量。能够提升性能。</p>
<p>若该容量过少，而新增的键值对又很多。就会导致频繁的分配 buckets，进行扩容迁移等 rehash 动作。最终结果就是性能直接的下降（敲黑板）</p>
<p>而当 <code>hint</code> 小于 8 时，这种问题<strong>相对</strong>就不会凸显的太明显，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makemap_small</span><span class="p">()</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>
</code></pre></div><h3 id="图示">图示</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3dOLRO.png" alt="image"></p>
<h2 id="访问">访问</h2>
<h3 id="用法-1">用法</h3>
<pre><code>v := m[i]
v, ok := m[i]
</code></pre><h3 id="函数原型-1">函数原型</h3>
<p>在实现 map 元素访问上有好几种方法，主要是包含针对 32/64 位、string 类型的特殊处理，总的函数原型如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="nf">mapaccess2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>

<span class="nf">mapaccessK</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span>

<span class="nf">mapaccess1_fat</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">zero</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="nf">mapaccess2_fat</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">zero</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>

<span class="nf">mapaccess1_fast32</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint32</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="nf">mapaccess2_fast32</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
<span class="nf">mapassign_fast32</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint32</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="nf">mapassign_fast32ptr</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>

<span class="nf">mapaccess1_fast64</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint64</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="o">...</span>

<span class="nf">mapaccess1_faststr</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">ky</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="o">...</span>
</code></pre></div><ul>
<li>mapaccess1：返回 <code>h[key]</code> 的指针地址，如果键不在 <code>map</code> 中，将返回对应类型的零值</li>
<li>mapaccess2：返回 <code>h[key]</code> 的指针地址，如果键不在 <code>map</code> 中，将返回零值和布尔值用于判断</li>
</ul>
<h3 id="源码-1">源码</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapaccess1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">h</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">h</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">hashWriting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;concurrent map read and map write&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">alg</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">alg</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">alg</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span><span class="p">))</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
	<span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">oldbuckets</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">sameSizeGrow</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// There used to be half as many buckets; mask down one more power of two.
</span><span class="c1"></span>			<span class="nx">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
		<span class="p">}</span>
		<span class="nx">oldb</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="p">(</span><span class="nx">hash</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">evacuated</span><span class="p">(</span><span class="nx">oldb</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nx">oldb</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">top</span> <span class="o">:=</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">b</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">bucketCnt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">top</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">indirectkey</span> <span class="p">{</span>
				<span class="nx">k</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">alg</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">v</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">indirectvalue</span> <span class="p">{</span>
					<span class="nx">v</span> <span class="p">=</span> <span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">v</span><span class="p">))</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="nx">v</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zeroVal</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>判断 map 是否为 nil，长度是否为 0。若是则返回零值</li>
<li>判断当前是否并发读写 map，若是则抛出异常</li>
<li>根据 key 的不同类型调用不同的 hash 方法计算得出 hash 值</li>
<li>确定 key 在哪一个 bucket 中，并得到其位置</li>
<li>判断是否正在发生扩容（h.oldbuckets 是否为 nil），若正在扩容，则到老的 buckets 中查找（因为 buckets 中可能还没有值，搬迁未完成），若该 bucket 已经搬迁完毕。则到 buckets 中继续查找</li>
<li>计算 hash 的 tophash 值（高八位）</li>
<li>根据计算出来的 tophash，依次循环对比 buckets 的 tophash 值（快速试错）</li>
<li>如果 tophash 匹配成功，则计算 key 的所在位置，正式完整的对比两个 key 是否一致</li>
<li>若查找成功并返回，若不存在，则返回零值</li>
</ul>
<p>在上述步骤三中，提到了根据不同的类型计算出 hash 值，另外会计算出 hash 值的高八位和低八位。低八位会作为 bucket index，作用是用于找到 key 所在的 bucket。而高八位会存储在 bmap tophash 中</p>
<p>其主要作用是在上述步骤七中进行迭代快速定位。这样子可以提高性能，而不是一开始就直接用 key 进行一致性对比</p>
<h3 id="图示-1">图示</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3dOOzD.png" alt="image"></p>
<h2 id="总结">总结</h2>
<p>在本章节，我们介绍了 map 类型的以下知识点：</p>
<ul>
<li>map 的基础数据结构</li>
<li>初始化 map</li>
<li>访问 map</li>
</ul>
<p>从阅读源码中，得知 Go 本身<strong>对于一些不同大小、不同类型的属性，包括哈希方法都有编写特定方法</strong>去运行。总的来说，这块的设计隐含较多的思路，有不少点值得细细品尝 :)</p>
<p>注：本文基于 Go 1.11.5</p>
]]></content>
		</item>
		
		<item>
			<title>for-loop 与 json.Unmarshal 性能分析概要</title>
			<link>https://eddycjy.com/posts/go/talk/2019-02-17-for-loop-json-unmarshal/</link>
			<pubDate>Sun, 17 Feb 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2019-02-17-for-loop-json-unmarshal/</guid>
			<description>在项目中，常常会遇到循环交换赋值的数据处理场景，尤其是 RPC，数据交互格式要转为 Protobuf，赋值是无法避免的。一般会有如下几种做法：
 for for range json.Marshal/Unmarshal  这时候又面临 “选择困难症”，用哪个好？又想代码量少，又担心性能有没有影响啊&amp;hellip;
为了弄清楚这个疑惑，接下来将分别编写三种使用场景。来简单看看它们的性能情况，看看谁更 “好”
功能代码 ... type Person struct { Name string `json:&amp;#34;name&amp;#34;` Age int `json:&amp;#34;age&amp;#34;` Avatar string `json:&amp;#34;avatar&amp;#34;` Type string `json:&amp;#34;type&amp;#34;` } type AgainPerson struct { Name string `json:&amp;#34;name&amp;#34;` Age int `json:&amp;#34;age&amp;#34;` Avatar string `json:&amp;#34;avatar&amp;#34;` Type string `json:&amp;#34;type&amp;#34;` } const MAX = 10000 func InitPerson() []Person { var persons []Person for i := 0; i &amp;lt; MAX; i++ { persons = append(persons, Person{ Name: &amp;#34;EDDYCJY&amp;#34;, Age: i, Avatar: &amp;#34;https://github.</description>
			<content type="html"><![CDATA[<p>在项目中，常常会遇到循环交换赋值的数据处理场景，尤其是 RPC，数据交互格式要转为 Protobuf，赋值是无法避免的。一般会有如下几种做法：</p>
<ul>
<li>for</li>
<li>for range</li>
<li>json.Marshal/Unmarshal</li>
</ul>
<p>这时候又面临 “选择困难症”，用哪个好？又想代码量少，又担心性能有没有影响啊&hellip;</p>
<p>为了弄清楚这个疑惑，接下来将分别编写三种使用场景。来简单看看它们的性能情况，看看谁更 “好”</p>
<h2 id="功能代码">功能代码</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>   <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
	<span class="nx">Age</span>    <span class="kt">int</span>    <span class="s">`json:&#34;age&#34;`</span>
	<span class="nx">Avatar</span> <span class="kt">string</span> <span class="s">`json:&#34;avatar&#34;`</span>
	<span class="nx">Type</span>   <span class="kt">string</span> <span class="s">`json:&#34;type&#34;`</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">AgainPerson</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>   <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
	<span class="nx">Age</span>    <span class="kt">int</span>    <span class="s">`json:&#34;age&#34;`</span>
	<span class="nx">Avatar</span> <span class="kt">string</span> <span class="s">`json:&#34;avatar&#34;`</span>
	<span class="nx">Type</span>   <span class="kt">string</span> <span class="s">`json:&#34;type&#34;`</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">MAX</span> <span class="p">=</span> <span class="mi">10000</span>

<span class="kd">func</span> <span class="nf">InitPerson</span><span class="p">()</span> <span class="p">[]</span><span class="nx">Person</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">persons</span> <span class="p">[]</span><span class="nx">Person</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">MAX</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">persons</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">persons</span><span class="p">,</span> <span class="nx">Person</span><span class="p">{</span>
			<span class="nx">Name</span><span class="p">:</span>   <span class="s">&#34;EDDYCJY&#34;</span><span class="p">,</span>
			<span class="nx">Age</span><span class="p">:</span>    <span class="nx">i</span><span class="p">,</span>
			<span class="nx">Avatar</span><span class="p">:</span> <span class="s">&#34;https://github.com/EDDYCJY&#34;</span><span class="p">,</span>
			<span class="nx">Type</span><span class="p">:</span>   <span class="s">&#34;Person&#34;</span><span class="p">,</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">persons</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ForStruct</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="nx">Person</span><span class="p">,</span> <span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ForRangeStruct</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="nx">Person</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">p</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">JsonToStruct</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">againPerson</span> <span class="p">[]</span><span class="nx">AgainPerson</span><span class="p">)</span> <span class="p">([]</span><span class="nx">AgainPerson</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">againPerson</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">againPerson</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">JsonIteratorToStruct</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">againPerson</span> <span class="p">[]</span><span class="nx">AgainPerson</span><span class="p">)</span> <span class="p">([]</span><span class="nx">AgainPerson</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">jsonIter</span> <span class="p">=</span> <span class="nx">jsoniter</span><span class="p">.</span><span class="nx">ConfigCompatibleWithStandardLibrary</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">jsonIter</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">againPerson</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">againPerson</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><h2 id="测试代码">测试代码</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="kd">func</span> <span class="nf">BenchmarkForStruct</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">person</span> <span class="o">:=</span> <span class="nf">InitPerson</span><span class="p">()</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">ForStruct</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkForRangeStruct</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">person</span> <span class="o">:=</span> <span class="nf">InitPerson</span><span class="p">()</span>

	<span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">ForRangeStruct</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkJsonToStruct</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">person</span> <span class="p">=</span> <span class="nf">InitPerson</span><span class="p">()</span>
		<span class="nx">againPersons</span> <span class="p">[]</span><span class="nx">AgainPerson</span>
	<span class="p">)</span>
	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;json.Marshal err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">JsonToStruct</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">againPersons</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkJsonIteratorToStruct</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">person</span> <span class="p">=</span> <span class="nf">InitPerson</span><span class="p">()</span>
		<span class="nx">againPersons</span> <span class="p">[]</span><span class="nx">AgainPerson</span>
	<span class="p">)</span>
	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;json.Marshal err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">b</span><span class="p">.</span><span class="nf">ResetTimer</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">JsonIteratorToStruct</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">againPersons</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="测试结果">测试结果</h2>
<pre><code>BenchmarkForStruct-4              	  500000	      3289 ns/op	       0 B/op	       0 allocs/op
BenchmarkForRangeStruct-4         	  200000	      9178 ns/op	       0 B/op	       0 allocs/op
BenchmarkJsonToStruct-4           	     100	  19173117 ns/op	 2618509 B/op	   40036 allocs/op
BenchmarkJsonIteratorToStruct-4   	     300	   4116491 ns/op	 3694017 B/op	   30047 allocs/op
</code></pre><p>从测试结果来看，性能排名为：for &lt; for range &lt; json-iterator &lt; encoding/json。接下来我们看看是什么原因导致了这样子的排名？</p>
<h2 id="性能对比">性能对比</h2>
<p><img src="https://s2.ax1x.com/2020/02/27/3wuywR.png" alt="image"></p>
<h3 id="for-loop">for-loop</h3>
<p>在测试结果中，<code>for range</code> 在性能上相较 <code>for</code> 差。这是为什么呢？在这里我们可以参见 <code>for range</code> 的 <a href="https://github.com/gcc-mirror/gcc/blob/master/gcc/go/gofrontend/statements.cc">实现</a>，伪实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">for_temp</span> <span class="o">:=</span> <span class="k">range</span>
<span class="nx">len_temp</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">for_temp</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">index_temp</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index_temp</span> <span class="p">&lt;</span> <span class="nx">len_temp</span><span class="p">;</span> <span class="nx">index_temp</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">value_temp</span> <span class="p">=</span> <span class="nx">for_temp</span><span class="p">[</span><span class="nx">index_temp</span><span class="p">]</span>
    <span class="nx">index</span> <span class="p">=</span> <span class="nx">index_temp</span>
    <span class="nx">value</span> <span class="p">=</span> <span class="nx">value_temp</span>
    <span class="nx">original</span> <span class="nx">body</span>
<span class="p">}</span>
</code></pre></div><p>通过分析伪实现，可得知 <code>for range</code> 相较 <code>for</code> 多做了如下事项</p>
<h4 id="expression">Expression</h4>
<pre><code>RangeClause = [ ExpressionList &quot;=&quot; | IdentifierList &quot;:=&quot; ] &quot;range&quot; Expression .
</code></pre><p>在循环开始之前会对范围表达式进行求值，多做了 “解” 表达式的动作，得到了最终的范围值</p>
<h4 id="copy">Copy</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="nx">value_temp</span> <span class="p">=</span> <span class="nx">for_temp</span><span class="p">[</span><span class="nx">index_temp</span><span class="p">]</span>
<span class="nx">index</span> <span class="p">=</span> <span class="nx">index_temp</span>
<span class="nx">value</span> <span class="p">=</span> <span class="nx">value_temp</span>
<span class="o">...</span>
</code></pre></div><p>从伪实现上可以得出，<code>for range</code> 始终使用<strong>值拷贝</strong>的方式来生成循环变量。通俗来讲，就是在每次循环时，都会对循环变量重新分配</p>
<h4 id="小结">小结</h4>
<p>通过上述的分析，可得知其比 <code>for</code> 慢的原因是 <code>for range</code> 有额外的性能开销，主要为<strong>值拷贝的动作</strong>导致的性能下降。这是它慢的原因</p>
<p>那么其实在 <code>for range</code> 中，我们可以使用 <code>_</code> 和 <code>T[i]</code> 也能达到和 <code>for</code> 差不多的性能。但这可能不是 <code>for range</code> 的设计本意了</p>
<h3 id="jsonmarshalunmarshal">json.Marshal/Unmarshal</h3>
<h4 id="encodingjson">encoding/json</h4>
<p>json 互转是在三种方案中最慢的，这是为什么呢？</p>
<p>众所皆知，官方的 <code>encoding/json</code> 标准库，是通过大量反射来实现的。那么 “慢”，也是必然的。可参见下述代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="kd">func</span> <span class="nf">newTypeEncoder</span><span class="p">(</span><span class="nx">t</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">allowAddr</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">encoderFunc</span> <span class="p">{</span>
    <span class="o">...</span>
	<span class="k">switch</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Bool</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">boolEncoder</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int16</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int64</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">intEncoder</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint16</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint64</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uintptr</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">uintEncoder</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Float32</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">float32Encoder</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Float64</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">float64Encoder</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">stringEncoder</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Interface</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">interfaceEncoder</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Struct</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">newStructEncoder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Map</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">newMapEncoder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">newSliceEncoder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Array</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">newArrayEncoder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">newPtrEncoder</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">unsupportedTypeEncoder</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>既然官方的标准库存在一定的 “问题”，那么有没有其他解决方法呢？目前在社区里，大多为两类方案。如下：</p>
<ul>
<li>预编译生成代码（提前确定类型），可以解决运行时的反射带来的性能开销。缺点是增加了预生成的步骤</li>
<li>优化序列化的逻辑，性能达到最大化</li>
</ul>
<p>接下来的实验，我们用第二种方案的库来测试，看看有没有改变。另外也推荐大家了解如下项目：</p>
<ul>
<li><a href="https://github.com/json-iterator/go">json-iterator/go</a></li>
<li><a href="https://github.com/mailru/easyjson">mailru/easyjson</a></li>
<li><a href="https://github.com/pquerna/ffjson">pquerna/ffjson</a></li>
</ul>
<h4 id="json-iteratorgo">json-iterator/go</h4>
<p>目前社区较常用的是 json-iterator/go，我们在测试代码中用到了它</p>
<p>它的用法与标准库 100% 兼容，并且性能有较大提升。我们一起粗略的看下是怎么做到的，如下：</p>
<h5 id="reflect2">reflect2</h5>
<p>利用 <a href="https://github.com/modern-go/reflect2">modern-go/reflect2</a> 减少运行时调度开销</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="kd">type</span> <span class="nx">StructDescriptor</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Type</span>   <span class="nx">reflect2</span><span class="p">.</span><span class="nx">Type</span>
	<span class="nx">Fields</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Binding</span>
<span class="p">}</span>

<span class="o">...</span>
<span class="kd">type</span> <span class="nx">Binding</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">levels</span>    <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">Field</span>     <span class="nx">reflect2</span><span class="p">.</span><span class="nx">StructField</span>
	<span class="nx">FromNames</span> <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">ToNames</span>   <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">Encoder</span>   <span class="nx">ValEncoder</span>
	<span class="nx">Decoder</span>   <span class="nx">ValDecoder</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Extension</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">UpdateStructDescriptor</span><span class="p">(</span><span class="nx">structDescriptor</span> <span class="o">*</span><span class="nx">StructDescriptor</span><span class="p">)</span>
	<span class="nf">CreateMapKeyDecoder</span><span class="p">(</span><span class="nx">typ</span> <span class="nx">reflect2</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span> <span class="nx">ValDecoder</span>
	<span class="nf">CreateMapKeyEncoder</span><span class="p">(</span><span class="nx">typ</span> <span class="nx">reflect2</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span> <span class="nx">ValEncoder</span>
	<span class="nf">CreateDecoder</span><span class="p">(</span><span class="nx">typ</span> <span class="nx">reflect2</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span> <span class="nx">ValDecoder</span>
	<span class="nf">CreateEncoder</span><span class="p">(</span><span class="nx">typ</span> <span class="nx">reflect2</span><span class="p">.</span><span class="nx">Type</span><span class="p">)</span> <span class="nx">ValEncoder</span>
	<span class="nf">DecorateDecoder</span><span class="p">(</span><span class="nx">typ</span> <span class="nx">reflect2</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">decoder</span> <span class="nx">ValDecoder</span><span class="p">)</span> <span class="nx">ValDecoder</span>
	<span class="nf">DecorateEncoder</span><span class="p">(</span><span class="nx">typ</span> <span class="nx">reflect2</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">encoder</span> <span class="nx">ValEncoder</span><span class="p">)</span> <span class="nx">ValEncoder</span>
<span class="p">}</span>
</code></pre></div><h5 id="struct-encoderdecoder-cache">struct Encoder/Decoder Cache</h5>
<p>类型为 struct 时，只需要反射一次 Name 和 Type，会缓存 struct Encoder 和 Decoder</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">typeDecoders</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">ValDecoder</span><span class="p">{}</span>
<span class="kd">var</span> <span class="nx">fieldDecoders</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">ValDecoder</span><span class="p">{}</span>
<span class="kd">var</span> <span class="nx">typeEncoders</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">ValEncoder</span><span class="p">{}</span>
<span class="kd">var</span> <span class="nx">fieldEncoders</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">ValEncoder</span><span class="p">{}</span>
<span class="kd">var</span> <span class="nx">extensions</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">Extension</span><span class="p">{}</span>

<span class="o">...</span><span class="p">.</span>

<span class="nx">fieldNames</span> <span class="o">:=</span> <span class="nf">calcFieldNames</span><span class="p">(</span><span class="nx">field</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">tagParts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">tag</span><span class="p">)</span>
<span class="nx">fieldCacheKey</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s/%s&#34;</span><span class="p">,</span> <span class="nx">typ</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span> <span class="nx">field</span><span class="p">.</span><span class="nf">Name</span><span class="p">())</span>
<span class="nx">decoder</span> <span class="o">:=</span> <span class="nx">fieldDecoders</span><span class="p">[</span><span class="nx">fieldCacheKey</span><span class="p">]</span>
<span class="k">if</span> <span class="nx">decoder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">decoder</span> <span class="p">=</span> <span class="nf">decoderOfType</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">field</span><span class="p">.</span><span class="nf">Name</span><span class="p">()),</span> <span class="nx">field</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span>
<span class="p">}</span>
<span class="nx">encoder</span> <span class="o">:=</span> <span class="nx">fieldEncoders</span><span class="p">[</span><span class="nx">fieldCacheKey</span><span class="p">]</span>
<span class="k">if</span> <span class="nx">encoder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nx">encoder</span> <span class="p">=</span> <span class="nf">encoderOfType</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">field</span><span class="p">.</span><span class="nf">Name</span><span class="p">()),</span> <span class="nx">field</span><span class="p">.</span><span class="nf">Type</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><h5 id="文本解析优化">文本解析优化</h5>
<h4 id="小结-1">小结</h4>
<p>相较于官方标准库，第三方库 <code>json-iterator/go</code> 在运行时上做的更好。这是它快的原因</p>
<p>有个需要注意的点，在 Go1.10 后 <code>map</code> 类型与标准库的已经没有太大的性能差异。但是，例如 <code>struct</code> 类型等仍然有较大的性能提高</p>
<h2 id="总结">总结</h2>
<p>在本文中，我们首先进行了性能测试，再分析了不同方案，得知为什么了快慢的原因。那么最终在选择方案时，可以根据不同的应用场景去抉择：</p>
<ul>
<li>对性能开销有较高要求：选用 <code>for</code>，开销最小</li>
<li>中规中矩：选用 <code>for range</code>，大对象慎用</li>
<li>量小、占用小、数量可控：选用 <code>json.Marshal/Unmarshal</code> 的方案也可以。其<strong>重复代码</strong>少，但开销最大</li>
</ul>
<p>在绝大多数场景中，使用哪种并没有太大的影响。但作为工程师你应当清楚其利弊。以上就是不同的方案<strong>分析概要</strong>，希望对你有所帮助 :)</p>
]]></content>
		</item>
		
		<item>
			<title>来，控制一下 goroutine 的并发数量</title>
			<link>https://eddycjy.com/posts/go/talk/2019-01-20-control-goroutine/</link>
			<pubDate>Sun, 20 Jan 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2019-01-20-control-goroutine/</guid>
			<description>问题 func main() { userCount := math.MaxInt64 for i := 0; i &amp;lt; userCount; i++ { go func(i int) { // 做一些各种各样的业务逻辑处理 	fmt.Printf(&amp;#34;go func: %d\n&amp;#34;, i) time.Sleep(time.Second) }(i) } } 在这里，假设 userCount 是一个外部传入的参数（不可预测，有可能值非常大），有人会全部丢进去循环。想着全部都并发 goroutine 去同时做某一件事。觉得这样子会效率会更高，对不对！
那么，你觉得这里有没有什么问题？
噩梦般的开始 当然，在特定场景下，问题可大了。因为在本文被丢进去同时并发的可是一个极端值。我们可以一起观察下图的指标分析，看看情况有多 “崩溃”。下图是上述代码的表现：
输出结果 ... go func: 5839 go func: 5840 go func: 5841 go func: 5842 go func: 5915 go func: 5524 go func: 5916 go func: 8209 go func: 8264 signal: killed 如果你自己执行过代码，在 “输出结果” 上你会遇到如下问题：</description>
			<content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/27/3wnOsJ.jpg" alt="image"></p>
<h2 id="问题">问题</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">userCount</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt64</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">userCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		    <span class="c1">// 做一些各种各样的业务逻辑处理
</span><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;go func: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这里，假设 <code>userCount</code> 是一个外部传入的参数（不可预测，有可能值非常大），有人会全部丢进去循环。想着全部都并发 goroutine 去同时做某一件事。觉得这样子会效率会更高，对不对！</p>
<p>那么，你觉得这里有没有什么问题？</p>
<h2 id="噩梦般的开始">噩梦般的开始</h2>
<p>当然，在<strong>特定场景下</strong>，问题可大了。因为在本文被丢进去同时并发的可是一个极端值。我们可以一起观察下图的指标分析，看看情况有多 “崩溃”。下图是上述代码的表现：</p>
<h3 id="输出结果">输出结果</h3>
<pre><code>...
go func: 5839
go func: 5840
go func: 5841
go func: 5842
go func: 5915
go func: 5524
go func: 5916
go func: 8209
go func: 8264
signal: killed
</code></pre><p>如果你自己执行过代码，在 “输出结果” 上你会遇到如下问题：</p>
<ul>
<li>系统资源占用率不断上涨</li>
<li>输出一定数量后：控制台就不再刷新输出最新的值了</li>
<li>信号量：signal: killed</li>
</ul>
<h3 id="系统负载">系统负载</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3wnxd1.jpg" alt="image"></p>
<h3 id="cpu">CPU</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3wuKW8.jpg" alt="image"></p>
<p>短时间内系统负载暴增</p>
<h3 id="虚拟内存">虚拟内存</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3wu1yQ.jpg" alt="image"></p>
<p>短时间内占用的虚拟内存暴增</p>
<h3 id="top">top</h3>
<pre><code>PID    COMMAND      %CPU  TIME     #TH   #WQ  #PORT MEM    PURG   CMPRS  PGRP  PPID  STATE    BOOSTS
...
73414  test         100.2 01:59.50 9/1   0    18    6801M+ 0B     114G+  73403 73403 running  *0[1]
</code></pre><h3 id="小结">小结</h3>
<p>如果仔细看过监控工具的示意图，就可以知道其实我间隔的执行了两次，能看到系统间的使用率幅度非常大。当进程被杀掉后，整体又恢复为正常值</p>
<p>在这里，我们回到主题，就是在<strong>不控制并发的 goroutine 数量</strong> 会发生什么问题？大致如下：</p>
<ul>
<li>CPU 使用率浮动上涨</li>
<li>Memory 占用不断上涨。也可以看看 CMPRS，它表示进程的压缩数据的字节数。已经到达 114G+ 了</li>
<li>主进程崩溃（被杀掉了）</li>
</ul>
<p>简单来说，“崩溃” 的原因就是对系统资源的占用过大。常见的比如：打开文件数（too many files open）、内存占用等等</p>
<h3 id="危害">危害</h3>
<p>对该台服务器产生非常大的影响，影响自身及相关联的应用。很有可能导致不可用或响应缓慢，另外启动了复数 “失控” 的 goroutine，导致程序流转混乱</p>
<h2 id="解决方案">解决方案</h2>
<p>在前面花了大量篇幅，渲染了在存在大量并发 goroutine 数量时，不控制的话会出现 “严重” 的问题，接下来一起思考下解决方案。如下：</p>
<ol>
<li>控制/限制 goroutine 同时并发运行的数量</li>
<li>改变应用程序的逻辑写法（避免大规模的使用系统资源和等待）</li>
<li><del>调整服务的硬件配置、最大打开数、内存等阈值</del></li>
</ol>
<h2 id="控制-goroutine-并发数量">控制 goroutine 并发数量</h2>
<p>接下来正式的开始解决这个问题，希望你认真阅读的同时加以思考，因为这个问题在实际项目中真的是太常见了！</p>
<p>问题已经抛出来了，你需要做的是<strong>想想有什么办法</strong>解决这个问题。建议你自行思考一下技术方案。再接着往下看 :-)</p>
<h3 id="尝试-chan">尝试 chan</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">userCount</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">userCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kc">true</span>
		<span class="k">go</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">//time.Sleep(time.Second)
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;go func: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="o">&lt;-</span> <span class="nx">ch</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>go func: 1
go func: 2
go func: 3
go func: 4
go func: 5
go func: 6
go func: 7
go func: 8
go func: 0
</code></pre><p>嗯，我们似乎很好的控制了 2 个 2 个的 “顺序” 执行多个 goroutine。但是，问题出现了。你仔细数一下输出结果，才 9 个值？</p>
<p>这明显就不对。原因出在当主协程结束时，子协程也是会被终止掉的。因此剩余的 goroutine 没来及把值输出，就被送上路了（不信你把 <code>time.Sleep</code> 打开看看，看看输出数量）</p>
<h3 id="尝试-sync">尝试 sync</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="kd">var</span> <span class="nx">wg</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">userCount</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">userCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;go func: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>嗯，单纯的使用 <code>sync.WaitGroup</code> 也不行。没有控制到同时并发的 goroutine 数量（代指达不到本文所要求的目标）</p>
<h4 id="小结-1">小结</h4>
<p>单纯<strong>简单</strong>使用 channel 或 sync 都有明显缺陷，不行。我们再看看组件配合能不能实现</p>
<h3 id="尝试-chan--sync">尝试 chan + sync</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="kd">var</span> <span class="nx">wg</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">userCount</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">userCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>

	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kc">true</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;go func: %d, time: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="o">&lt;-</span><span class="nx">ch</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>go func: 9, time: 1547911938
go func: 1, time: 1547911938
go func: 6, time: 1547911939
go func: 7, time: 1547911939
go func: 8, time: 1547911940
go func: 0, time: 1547911940
go func: 3, time: 1547911941
go func: 2, time: 1547911941
go func: 4, time: 1547911942
go func: 5, time: 1547911942
</code></pre><p>从输出结果来看，确实实现了控制 goroutine 以 2 个 2 个的数量去执行我们的 “业务逻辑”，当然结果集也理所应当的是乱序输出</p>
<h3 id="方案一简单-semaphore">方案一：简单 Semaphore</h3>
<p>在确立了简单使用 chan + sync 的方案是可行后，我们重新将流转逻辑封装为 <a href="https://github.com/EDDYCJY/gsema">gsema</a>，主程序变成如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/gsema&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">sema</span> <span class="p">=</span> <span class="nx">gsema</span><span class="p">.</span><span class="nf">NewSemaphore</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">userCount</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">userCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">sema</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">sema</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="nx">sema</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;go func: %d, time: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="分析方案">分析方案</h3>
<p>在上述代码中，程序执行流程如下：</p>
<ul>
<li>设置允许的并发数目为 3 个</li>
<li>循环 10 次，每次启动一个 goroutine 来执行任务</li>
<li>每一个 goroutine 在内部利用 <code>sema</code> 进行调控是否阻塞</li>
<li>按允许并发数逐渐释出 goroutine，最后结束任务</li>
</ul>
<p>看上去人模人样，没什么严重问题。但却有一个 “大” 坑，认真看到第二点 “每次启动一个 goroutine” 这句话。这里<strong>有点问题</strong>，提前产生那么多的 goroutine 会不会有什么问题，接下来一起分析下利弊，如下：</p>
<h4 id="利">利</h4>
<ul>
<li>适合<strong>量不大、复杂度低</strong>的使用场景
<ul>
<li>几百几千个、几十万个也是可以接受的（看具体业务场景）</li>
<li>实际业务逻辑在运行前就已经被阻塞等待了（因为并发数受限），基本实际业务逻辑损耗的性能比 goroutine 本身大</li>
<li>goroutine 本身很轻便，仅损耗极少许的内存空间和调度。这种等待响应的情况都是躺好了，等待任务唤醒</li>
</ul>
</li>
<li>Semaphore 操作复杂度低且流转简单，容易控制</li>
</ul>
<h4 id="弊">弊</h4>
<ul>
<li>不适合<strong>量很大、复杂度高</strong>的使用场景
<ul>
<li>有几百万、几千万个 goroutine 的话，就浪费了大量调度 goroutine 和内存空间。恰好你的服务器也接受不了的话</li>
</ul>
</li>
<li>Semaphore 操作复杂度提高，要管理更多的状态</li>
</ul>
<h3 id="小结-2">小结</h3>
<ul>
<li>基于什么业务场景，就用什么方案去做事</li>
<li>有足够的时间，允许你去追求更优秀、极致的方案（用第三方库也行）</li>
</ul>
<p>用哪种方案，我认为主要基于以上两点去思考，都是 OK 的。没有对错，只有当前业务场景能不能接受，这个预先启动的 goroutine 数量你的系统是否能够接受</p>
<p>当然了，常见/简单的 Go 应用采用这类技术方案，基本就能解决问题了。因为像本文第一节 “问题” 如此超巨大数量的情况，情况很少。其并不存在那些 “特殊性”。因此用这个方案基本 OK</p>
<h2 id="灵活控制-goroutine-并发数量">灵活控制 goroutine 并发数量</h2>
<p>小手一紧。隔壁老王发现了新的问题。“方案一” 中，在<strong>输入输出一体</strong>的情况下，在常见的业务场景中确实可以</p>
<p>但，这次新的业务场景比较特殊，要控制输入的数量，以此达到<strong>改变允许并发运行 goroutine 的数量</strong>。我们仔细想想，要做出如下改变：</p>
<ul>
<li>输入/输出要抽离，才可以分别控制</li>
<li>输入/输出要可变，理所应当在 for-loop 中（可设置数值的地方）</li>
<li>允许改变 goroutine 并发数量，但它也必须有一个<strong>最大值</strong>（因为允许改变是相对）</li>
</ul>
<h3 id="方案二灵活-chan--sync">方案二：灵活 chan + sync</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">userCount</span> <span class="o">:=</span> <span class="mi">10</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">userCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">d</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;go func: %d, time: %d\n&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>
				<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">2</span>
		<span class="c1">//time.Sleep(time.Second)
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>...
go func: 1, time: 1547950567
go func: 3, time: 1547950567
go func: 1, time: 1547950567
go func: 2, time: 1547950567
go func: 2, time: 1547950567
go func: 3, time: 1547950567
go func: 1, time: 1547950568
go func: 2, time: 1547950568
go func: 3, time: 1547950568
go func: 1, time: 1547950568
go func: 3, time: 1547950569
go func: 2, time: 1547950569
</code></pre><p>在 “方案二” 中，我们可以随时随地的根据新的业务需求，做如下事情：</p>
<ul>
<li>变更 channel 的输入数量</li>
<li>能够根据特殊情况，变更 channel 的循环值</li>
<li>变更最大允许并发的 goroutine 数量</li>
</ul>
<p>总的来说，就是可控空间都尽量放开了，是不是更加灵活了呢 :-)</p>
<h3 id="方案三第三方库">方案三：第三方库</h3>
<ul>
<li><a href="https://github.com/go-playground/pool">go-playground/pool</a></li>
<li><a href="https://github.com/nozzle/throttler">nozzle/throttler</a></li>
<li><a href="https://github.com/Jeffail/tunny">Jeffail/tunny</a></li>
<li><a href="https://github.com/panjf2000/ants">panjf2000/ants</a></li>
</ul>
<p>比较成熟的第三方库也不少，基本都是以生成和管理 goroutine 为目标的池工具。我简单列了几个，具体建议大家阅读下源码或者多找找，原理相似</p>
<h2 id="总结">总结</h2>
<p>在本文的开头，我花了大力气（极端数量），告诉你<strong>同时并发过多的 goroutine 数量会导致系统占用资源不断上涨。最终该服务崩盘的极端情况</strong>。为的是希望你今后避免这种问题，给你留下深刻的印象</p>
<p>接下来我们以 “控制 goroutine 并发数量” 为主题，展开了一番分析。分别给出了三种方案。在我看来，各具优缺点，我建议你<strong>挑选合适自身场景的技术方案</strong>就可以了</p>
<p>因为，有不同类型的技术方案也能解决这个问题，千人千面。本文推荐的是较常见的解决方案，也欢迎大家在评论区继续补充 :-)</p>
]]></content>
		</item>
		
		<item>
			<title>Go Slice 最大容量大小是怎么来的</title>
			<link>https://eddycjy.com/posts/go/slice/2019-01-06-why-slice-max/</link>
			<pubDate>Sun, 06 Jan 2019 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/slice/2019-01-06-why-slice-max/</guid>
			<description>前言 在《深入理解 Go Slice》中，我们提到了 “根据其类型大小去获取能够申请的最大容量大小” 的处理逻辑。今天我们将更深入地去探究一下，底层到底做了什么东西，涉及什么知识点？
Go Slice 对应代码如下：
func makeslice(et *_type, len, cap int) slice { maxElements := maxSliceCap(et.size) if len &amp;lt; 0 || uintptr(len) &amp;gt; maxElements { ... } if cap &amp;lt; len || uintptr(cap) &amp;gt; maxElements { ... } p := mallocgc(et.size*uintptr(cap), et, true) return slice{p, len, cap} } 根据想要追寻的逻辑，定位到了 maxSliceCap 方法，它会根据当前类型的大小获取到了所允许的最大容量大小来进行阈值判断，也就是安全检查。这是浅层的了解，我们继续追下去看看还做了些什么？
maxSliceCap func maxSliceCap(elemsize uintptr) uintptr { if elemsize &amp;lt; uintptr(len(maxElems)) { return maxElems[elemsize] } return maxAlloc / elemsize } maxElems var maxElems = [.</description>
			<content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/27/3wnHRU.png" alt="image"></p>
<h2 id="前言">前言</h2>
<p>在《深入理解 Go Slice》中，我们提到了 “根据其类型大小去获取能够申请的最大容量大小” 的处理逻辑。今天我们将更深入地去探究一下，底层到底做了什么东西，涉及什么知识点？</p>
<p>Go Slice 对应代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
	<span class="nx">maxElements</span> <span class="o">:=</span> <span class="nf">maxSliceCap</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">len</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxElements</span> <span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">len</span> <span class="o">||</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxElements</span> <span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span>

	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">),</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>根据想要追寻的逻辑，定位到了 <code>maxSliceCap</code> 方法，它会根据<strong>当前类型的大小获取到了所允许的最大容量大小</strong>来进行阈值判断，也就是安全检查。这是浅层的了解，我们继续追下去看看还做了些什么？</p>
<h2 id="maxslicecap">maxSliceCap</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maxSliceCap</span><span class="p">(</span><span class="nx">elemsize</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">elemsize</span> <span class="p">&lt;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">maxElems</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">maxElems</span><span class="p">[</span><span class="nx">elemsize</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="nx">elemsize</span>
<span class="p">}</span>
</code></pre></div><h2 id="maxelems">maxElems</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">maxElems</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">uintptr</span><span class="p">{</span>
	<span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>
	<span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">7</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span>
	<span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">9</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">11</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">12</span><span class="p">,</span>
	<span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">13</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">14</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">15</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">16</span><span class="p">,</span>
	<span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">17</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">18</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">19</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">20</span><span class="p">,</span>
	<span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">21</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">22</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">23</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">24</span><span class="p">,</span>
	<span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">25</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">26</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">27</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">28</span><span class="p">,</span>
	<span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">29</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">30</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">31</span><span class="p">,</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="mi">32</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p><code>maxElems</code> 是包含一些预定义的切片最大容量值的查找表，索引是切片元素的类型大小。而值看起来 “奇奇怪怪” 不大眼熟，都是些什么呢。主要是以下三个核心点：</p>
<ul>
<li>^uintptr(0)</li>
<li>maxAlloc</li>
<li>maxAlloc / typeSize</li>
</ul>
<h3 id="uintptr0">^uintptr(0)</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;uintptr: %v\n&#34;</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;^uintptr: %v\n&#34;</span><span class="p">,</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>2019/01/05 17:51:52 uintptr: 0
2019/01/05 17:51:52 ^uintptr: 18446744073709551615
</code></pre><p>我们留意一下输出结果，比较神奇。取反之后为什么是 18446744073709551615 呢？</p>
<h3 id="uintptr-是什么">uintptr 是什么</h3>
<p>在分析之前，我们要知道 uintptr 的本质（真面目），也就是它的类型是什么，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="kt">uintptr</span> <span class="kt">uintptr</span>
</code></pre></div><p>uintptr 的类型是自定义类型，接着找它的真面目，如下：</p>
<pre><code>#ifdef _64BIT
typedef	uint64		uintptr;
#else
typedef	uint32		uintptr;
#endif
</code></pre><p>通过对以上代码的分析，可得出以下结论：</p>
<ul>
<li>在 32 位系统下，uintptr 为 uint32 类型，占用大小为 4 个字节</li>
<li>在 64 位系统下，uintptr 为 uint64 类型，占用大小为 8 个字节</li>
</ul>
<h3 id="uintptr-做了什么事">^uintptr 做了什么事</h3>
<p>^ 位运算符的作用是<strong>按位异或</strong>，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(^</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(^</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>2019/01/05 20:44:49 -2
2019/01/05 20:44:49 18446744073709551615
</code></pre><p>接下来我们分析一下，这两段代码都做了什么事情呢</p>
<h4 id="1">^1</h4>
<p>二进制：0001</p>
<p>按位取反：1110</p>
<p>该数为有符号整数，最高位为符号位。低三位为表示数值。按位取反后为 1110，根据先前的说明，最高位为 1，因此表示为 -。取反后 110 对应十进制 -2</p>
<h4 id="uint640">^uint64(0)</h4>
<p>二进制：0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</p>
<p>按位取反：1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111</p>
<p>该数为无符号整数，该位取反后得到十进制值为：18446744073709551615</p>
<p>这个值是不是看起来很眼熟呢？没错，就是 <code>^uintptr(0)</code> 的值。也印证了其底层数据类型为 uint64 的事实 （本机为 64 位）。同时它又代表如下：</p>
<ul>
<li>math.MaxUint64</li>
<li>2 的 64 次方减 1</li>
</ul>
<h3 id="maxalloc">maxAlloc</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">GoarchMips</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">const</span> <span class="nx">GoarchMipsle</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">const</span> <span class="nx">GoarchWasm</span> <span class="p">=</span> <span class="mi">0</span>

<span class="o">...</span>

<span class="nx">_64bit</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

<span class="nx">heapAddrBits</span> <span class="p">=</span> <span class="p">(</span><span class="nx">_64bit</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">sys</span><span class="p">.</span><span class="nx">GoarchWasm</span><span class="p">))</span><span class="o">*</span><span class="mi">48</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">_64bit</span><span class="o">+</span><span class="nx">sys</span><span class="p">.</span><span class="nx">GoarchWasm</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">GoarchMips</span><span class="o">+</span><span class="nx">sys</span><span class="p">.</span><span class="nx">GoarchMipsle</span><span class="p">))</span>

<span class="nx">maxAlloc</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">heapAddrBits</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">_64bit</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span>
</code></pre></div><p><code>maxAlloc</code> 是<strong>允许用户分配的最大虚拟内存空间</strong>。在 64 位，理论上可分配最大 <code>1 &lt;&lt; heapAddrBits</code> 字节。在 32 位，最大可分配小于 <code>1 &lt;&lt; 32</code> 字节</p>
<p>在本文，仅需了解它承载的是什么就好了。具体的在以后内存管理的文章再讲述</p>
<p>注：该变量在 go 10.1 为 <code>_MaxMem</code>，go 11.4 已改为 <code>maxAlloc</code>。相关的 <code>heapAddrBits</code> 计算方式也有所改变</p>
<h3 id="maxalloc--typesize">maxAlloc / typeSize</h3>
<p>我们再次回顾 <code>maxSliceCap</code> 的逻辑代码，这次重点放在控制逻辑，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// func makeslice
</span><span class="c1"></span><span class="nx">maxElements</span> <span class="o">:=</span> <span class="nf">maxSliceCap</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>

<span class="o">...</span>

<span class="c1">// func maxSliceCap
</span><span class="c1"></span><span class="k">if</span> <span class="nx">elemsize</span> <span class="p">&lt;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">maxElems</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">maxElems</span><span class="p">[</span><span class="nx">elemsize</span><span class="p">]</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nx">maxAlloc</span> <span class="o">/</span> <span class="nx">elemsize</span>
</code></pre></div><p>通过这段代码和 Slice 上下文逻辑，可得知在想得到该类型的最大容量大小时。会根据对应的类型大小去查找表查找索引（索引为类型大小，摆放顺序是有考虑原因的）。“迫不得已的情况下” 才会手动的计算它的值，最终计算得到的内存字节大小都为该类型大小的整数倍</p>
<p>查找表的设置，更像是一个优化逻辑。减少常用的计算开销 :)</p>
<h2 id="总结">总结</h2>
<p>通过本文的分析，可得出 Slice 所允许申请的最大容量大小，与当前<strong>值类型</strong>和当前<strong>平台位数</strong>有直接关系</p>
<h2 id="最后">最后</h2>
<p>本文与<a href="https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2018-12-15-%E6%9C%89%E7%82%B9%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8D%B4%E5%8F%88%E4%B8%80%E4%BA%AE%E7%9A%84Go-unsafe-Pointer.md">《有点不安全却又一亮的 Go unsafe.Pointer》</a>一同属于<a href="https://github.com/EDDYCJY/blog/blob/master/golang/pkg/2018-12-11-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go-Slice.md">《深入理解 Go Slice》</a>的关联章节。如果你在阅读源码时，对这些片段有疑惑。记得想尽办法深究下去，搞懂它</p>
<p>短短的一句话其实蕴含着不少知识点，希望这篇文章恰恰好可以帮你解惑</p>
<p>注：本文 Go 代码基于版本 11.4</p>
]]></content>
		</item>
		
		<item>
			<title>在 Go 中恰到好处的内存对齐</title>
			<link>https://eddycjy.com/posts/go/talk/2018-12-26-go-memory-align/</link>
			<pubDate>Wed, 26 Dec 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2018-12-26-go-memory-align/</guid>
			<description>问题 type Part1 struct { a bool b int32 c int8 d int64 e byte } 在开始之前，希望你计算一下 Part1 共占用的大小是多少呢？
func main() { fmt.Printf(&amp;#34;bool size: %d\n&amp;#34;, unsafe.Sizeof(bool(true))) fmt.Printf(&amp;#34;int32 size: %d\n&amp;#34;, unsafe.Sizeof(int32(0))) fmt.Printf(&amp;#34;int8 size: %d\n&amp;#34;, unsafe.Sizeof(int8(0))) fmt.Printf(&amp;#34;int64 size: %d\n&amp;#34;, unsafe.Sizeof(int64(0))) fmt.Printf(&amp;#34;byte size: %d\n&amp;#34;, unsafe.Sizeof(byte(0))) fmt.Printf(&amp;#34;string size: %d\n&amp;#34;, unsafe.Sizeof(&amp;#34;EDDYCJY&amp;#34;)) } 输出结果：
bool size: 1 int32 size: 4 int8 size: 1 int64 size: 8 byte size: 1 string size: 16 这么一算，Part1 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病</description>
			<content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/27/3wuT0A.png" alt="image"></p>
<h2 id="问题">问题</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Part1</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="kt">bool</span>
	<span class="nx">b</span> <span class="kt">int32</span>
	<span class="nx">c</span> <span class="kt">int8</span>
	<span class="nx">d</span> <span class="kt">int64</span>
	<span class="nx">e</span> <span class="kt">byte</span>
<span class="p">}</span>
</code></pre></div><p>在开始之前，希望你计算一下 <code>Part1</code> 共占用的大小是多少呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;bool size: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="kc">true</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;int32 size: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;int8 size: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nb">int8</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;int64 size: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;byte size: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nb">byte</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;string size: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="s">&#34;EDDYCJY&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>bool size: 1
int32 size: 4
int8 size: 1
int64 size: 8
byte size: 1
string size: 16
</code></pre><p>这么一算，<code>Part1</code> 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病</p>
<p>真实情况是怎么样的呢？我们实际调用看看，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Part1</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="kt">bool</span>
	<span class="nx">b</span> <span class="kt">int32</span>
	<span class="nx">c</span> <span class="kt">int8</span>
	<span class="nx">d</span> <span class="kt">int64</span>
	<span class="nx">e</span> <span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">part1</span> <span class="o">:=</span> <span class="nx">Part1</span><span class="p">{}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;part1 size: %d, align: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">part1</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Alignof</span><span class="p">(</span><span class="nx">part1</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>part1 size: 32, align: 8
</code></pre><p>最终输出为占用 32 个字节。这与前面所预期的结果完全不一样。这充分地说明了先前的计算方式是错误的。为什么呢？</p>
<p>在这里要提到 “内存对齐” 这一概念，才能够用正确的姿势去计算，接下来我们详细的讲讲它是什么</p>
<h2 id="内存对齐">内存对齐</h2>
<p>有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wuLff.png" alt="image"></p>
<p>上图表示一个坑一个萝卜的内存读取方式。但实际上 CPU 并不会以一个一个字节去读取和写入内存。相反 CPU 读取内存是<strong>一块一块读取</strong>的，块的大小可以为 2、4、6、8、16 字节等大小。块大小我们称其为<strong>内存访问粒度</strong>。如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wKSmj.png" alt="image"></p>
<p>在样例中，假设访问粒度为 4。 CPU 是以每 4 个字节大小的访问粒度去读取和写入内存的。这才是正确的姿势</p>
<h3 id="为什么要关心对齐">为什么要关心对齐</h3>
<ul>
<li>你正在编写的代码在性能（CPU、Memory）方面有一定的要求</li>
<li>你正在处理向量方面的指令</li>
<li>某些硬件平台（ARM）体系不支持未对齐的内存访问</li>
</ul>
<p>另外作为一个工程师，你也很有必要学习这块知识点哦 :)</p>
<h3 id="为什么要做对齐">为什么要做对齐</h3>
<ul>
<li>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</li>
<li>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/27/3wKApT.png" alt="image"></p>
<p>在上图中，假设从 Index 1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。因此 CPU 会做一些额外的处理工作。如下：</p>
<ol>
<li>CPU <strong>首次</strong>读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0</li>
<li>CPU <strong>再次</strong>读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节</li>
<li>合并 1-4 字节的数据</li>
<li>合并后放入寄存器</li>
</ol>
<p>从上述流程可得出，不做 “内存对齐” 是一件有点 &ldquo;麻烦&rdquo; 的事。因为它会增加许多耗费时间的动作</p>
<p>而假设做了内存对齐，从 Index 0 开始读取 4 个字节，只需要读取一次，也不需要额外的运算。这显然高效很多，是标准的<strong>空间换时间</strong>做法</p>
<h3 id="默认系数">默认系数</h3>
<p>在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 <code>#pragma pack(n)</code> 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：</p>
<ul>
<li>32 位：4</li>
<li>64 位：8</li>
</ul>
<p>另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。因此本文的值不是唯一的，调试的时候需按本机的实际情况考虑</p>
<h3 id="成员对齐">成员对齐</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;bool align: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Alignof</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="kc">true</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;int32 align: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Alignof</span><span class="p">(</span><span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;int8 align: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Alignof</span><span class="p">(</span><span class="nb">int8</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;int64 align: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Alignof</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;byte align: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Alignof</span><span class="p">(</span><span class="nb">byte</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;string align: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Alignof</span><span class="p">(</span><span class="s">&#34;EDDYCJY&#34;</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;map align: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Alignof</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{}))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>bool align: 1
int32 align: 4
int8 align: 1
int64 align: 8
byte align: 1
string align: 8
map align: 8
</code></pre><p>在 Go 中可以调用 <code>unsafe.Alignof</code> 来返回相应类型的对齐系数。通过观察输出结果，可得知基本都是 <code>2^n</code>，最大也不会超过 8。这是因为我手提（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p>
<h3 id="整体对齐">整体对齐</h3>
<p>在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p>
<h3 id="对齐规则">对齐规则</h3>
<ul>
<li>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>当前成员变量类型的长度</strong>（<code>unsafe.Sizeof</code>），取<strong>最小值作为当前类型的对齐值</strong>。其偏移量必须为对齐值的整数倍</li>
<li>结构体本身，对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>结构体的所有成员变量类型中的最大长度</strong>，取<strong>最大数的最小整数倍</strong>作为对齐值</li>
<li>结合以上两点，可得知若<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</li>
</ul>
<h2 id="分析流程">分析流程</h2>
<p>接下来我们一起分析一下，“它” 到底经历了些什么，影响了 “预期” 结果</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>bool</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>8</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>9</td>
<td>7</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td>e</td>
<td>byte</td>
<td>24</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>25</td>
<td>7</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>32</td>
</tr>
</tbody>
</table>
<h3 id="成员对齐-1">成员对齐</h3>
<ul>
<li>第一个成员 a
<ul>
<li>类型为 bool</li>
<li>大小/对齐值为 1 字节</li>
<li>初始地址，偏移量为 0。占用了第 1 位</li>
</ul>
</li>
<li>第二个成员 b
<ul>
<li>类型为 int32</li>
<li>大小/对齐值为 4 字节</li>
<li>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb</li>
</ul>
</li>
<li>第三个成员 c
<ul>
<li>类型为 int8</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c&hellip;</li>
</ul>
</li>
<li>第四个成员 d
<ul>
<li>类型为 int64</li>
<li>大小/对齐值为 8 字节</li>
<li>根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd</li>
</ul>
</li>
<li>第五个成员 e
<ul>
<li>类型为 byte</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e&hellip;</li>
</ul>
</li>
</ul>
<h3 id="整体对齐-1">整体对齐</h3>
<p>在每个成员变量进行对齐后，根据规则 2，整个结构体本身也要进行字节对齐，因为可发现它可能并不是 <code>2^n</code>，不是偶数倍。显然不符合对齐的规则</p>
<p>根据规则 2，可得出对齐值为 8。现在的偏移量为 25，不是 8 的整倍数。因此确定偏移量为 32。对结构体进行对齐</p>
<h3 id="结果">结果</h3>
<p>Part1 内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</p>
<h3 id="小结">小结</h3>
<p>通过本节的分析，可得知先前的 “推算” 为什么错误？</p>
<p>是因为实际内存管理并非 “一个萝卜一个坑” 的思想。而是一块一块。通过空间换时间（效率）的思想来完成这块读取、写入。另外也需要兼顾不同平台的内存操作情况</p>
<h2 id="巧妙的结构体">巧妙的结构体</h2>
<p>在上一小节，可得知根据成员变量的类型不同，其结构体的内存会产生对齐等动作。那假设字段顺序不同，会不会有什么变化呢？我们一起来试试吧 :-)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Part1</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="kt">bool</span>
	<span class="nx">b</span> <span class="kt">int32</span>
	<span class="nx">c</span> <span class="kt">int8</span>
	<span class="nx">d</span> <span class="kt">int64</span>
	<span class="nx">e</span> <span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Part2</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="kt">byte</span>
	<span class="nx">c</span> <span class="kt">int8</span>
	<span class="nx">a</span> <span class="kt">bool</span>
	<span class="nx">b</span> <span class="kt">int32</span>
	<span class="nx">d</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">part1</span> <span class="o">:=</span> <span class="nx">Part1</span><span class="p">{}</span>
	<span class="nx">part2</span> <span class="o">:=</span> <span class="nx">Part2</span><span class="p">{}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;part1 size: %d, align: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">part1</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Alignof</span><span class="p">(</span><span class="nx">part1</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;part2 size: %d, align: %d\n&#34;</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">part2</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Alignof</span><span class="p">(</span><span class="nx">part2</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>part1 size: 32, align: 8
part2 size: 16, align: 8
</code></pre><p>通过结果可以惊喜的发现，只是 “简单” 对成员变量的字段顺序进行改变，就改变了结构体占用大小</p>
<p>接下来我们一起剖析一下 <code>Part2</code>，看看它的内部到底和上一位之间有什么区别，才导致了这样的结果？</p>
<h3 id="分析流程-1">分析流程</h3>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>e</td>
<td>byte</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>bool</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>16</td>
</tr>
</tbody>
</table>
<h4 id="成员对齐-2">成员对齐</h4>
<ul>
<li>第一个成员 e
<ul>
<li>类型为 byte</li>
<li>大小/对齐值为 1 字节</li>
<li>初始地址，偏移量为 0。占用了第 1 位</li>
</ul>
</li>
<li>第二个成员 c
<ul>
<li>类型为 int8</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 2。不需要额外对齐</li>
</ul>
</li>
<li>第三个成员 a
<ul>
<li>类型为 bool</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 3。不需要额外对齐</li>
</ul>
</li>
<li>第四个成员 b
<ul>
<li>类型为 int32</li>
<li>大小/对齐值为 4 字节</li>
<li>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此第 3 位为 Padding。而当前数值从第 4 位开始填充，到第 8 位。如下：ecax|bbbb</li>
</ul>
</li>
<li>第五个成员 d
<ul>
<li>类型为 int64</li>
<li>大小/对齐值为 8 字节</li>
<li>根据规则 1，其偏移量必须为 8 的整数倍。当前偏移量为 8。不需要额外对齐，从 9-16 位填充 8 个字节。如下：ecax|bbbb|dddd|dddd</li>
</ul>
</li>
</ul>
<h4 id="整体对齐-2">整体对齐</h4>
<p>符合规则 2，不需要额外对齐</p>
<h4 id="结果-1">结果</h4>
<p>Part2 内存布局：ecax|bbbb|dddd|dddd</p>
<h2 id="总结">总结</h2>
<p>通过对比 <code>Part1</code> 和 <code>Part2</code> 的内存布局，你会发现两者有很大的不同。如下：</p>
<ul>
<li>
<p>Part1：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</p>
</li>
<li>
<p>Part2：ecax|bbbb|dddd|dddd</p>
</li>
</ul>
<p>仔细一看，<code>Part1</code> 存在许多 Padding。显然它占据了不少空间，那么 Padding 是怎么出现的呢？</p>
<p>通过本文的介绍，可得知是由于不同类型导致需要进行字节对齐，以此保证内存的访问边界</p>
<p>那么也不难理解，为什么<strong>调整结构体内成员变量的字段顺序</strong>就能达到缩小结构体占用大小的疑问了，是因为巧妙地减少了 Padding 的存在。让它们更 “紧凑” 了。这一点对于加深 Go 的内存布局印象和大对象的优化非常有帮</p>
<p>当然了，没什么特殊问题，你可以不关注这一块。但你要知道这块知识点 😄</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Data structure alignment</a></li>
<li><a href="https://www.ibm.com/developerworks/library/pa-dalign/">Data alignment</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>有点不安全却又一亮的 Go unsafe.Pointer</title>
			<link>https://eddycjy.com/posts/go/pkg/2018-12-15-unsafe/</link>
			<pubDate>Sat, 15 Dec 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/pkg/2018-12-15-unsafe/</guid>
			<description>在上一篇文章《深入理解 Go Slice》中，大家会发现其底层数据结构使用了 unsafe.Pointer。因此想着再介绍一下其关联知识
前言 在大家学习 Go 的时候，肯定都学过 “Go 的指针是不支持指针运算和转换” 这个知识点。为什么呢？
首先，Go 是一门静态语言，所有的变量都必须为标量类型。不同的类型不能够进行赋值、计算等跨类型的操作。那么指针也对应着相对的类型，也在 Compile 的静态类型检查的范围内。同时静态语言，也称为强类型。也就是一旦定义了，就不能再改变它
错误示例 func main(){ num := 5 numPointer := &amp;amp;num flnum := (*float32)(numPointer) fmt.Println(flnum) } 输出结果：
# command-line-arguments ...: cannot convert numPointer (type *int) to type *float32 在示例中，我们创建了一个 num 变量，值为 5，类型为 int。取了其对于的指针地址后，试图强制转换为 *float32，结果失败&amp;hellip;
unsafe 针对刚刚的 “错误示例”，我们可以采用今天的男主角 unsafe 标准库来解决。它是一个神奇的包，在官方的诠释中，有如下概述：
 围绕 Go 程序内存安全及类型的操作 很可能会是不可移植的 不受 Go 1 兼容性指南的保护  简单来讲就是，不怎么推荐你使用。因为它是 unsafe（不安全的），但是在特殊的场景下，使用了它。可以打破 Go 的类型和内存安全机制，让你获得眼前一亮的惊喜效果 😄
Pointer 为了解决这个问题，需要用到 unsafe.Pointer。它表示任意类型且可寻址的指针值，可以在不同的指针类型之间进行转换（类似 C 语言的 void * 的用途）</description>
			<content type="html"><![CDATA[<p>在上一篇文章《深入理解 Go Slice》中，大家会发现其底层数据结构使用了 <code>unsafe.Pointer</code>。因此想着再介绍一下其关联知识</p>
<h2 id="前言">前言</h2>
<p>在大家学习 Go 的时候，肯定都学过 “Go 的指针是不支持指针运算和转换” 这个知识点。为什么呢？</p>
<p>首先，Go 是一门静态语言，所有的变量都必须为标量类型。不同的类型不能够进行赋值、计算等跨类型的操作。那么指针也对应着相对的类型，也在 Compile 的静态类型检查的范围内。同时静态语言，也称为强类型。也就是一旦定义了，就不能再改变它</p>
<h2 id="错误示例">错误示例</h2>
<pre><code>func main(){
	num := 5
	numPointer := &amp;num

	flnum := (*float32)(numPointer)
	fmt.Println(flnum)
}
</code></pre><p>输出结果：</p>
<pre><code># command-line-arguments
...: cannot convert numPointer (type *int) to type *float32
</code></pre><p>在示例中，我们创建了一个 <code>num</code> 变量，值为 5，类型为 <code>int</code>。取了其对于的指针地址后，试图强制转换为 <code>*float32</code>，结果失败&hellip;</p>
<h2 id="unsafe">unsafe</h2>
<p>针对刚刚的 “错误示例”，我们可以采用今天的男主角 <code>unsafe</code> 标准库来解决。它是一个神奇的包，在官方的诠释中，有如下概述：</p>
<ul>
<li>围绕 Go 程序内存安全及类型的操作</li>
<li>很可能会是不可移植的</li>
<li>不受 Go 1 兼容性指南的保护</li>
</ul>
<p>简单来讲就是，不怎么推荐你使用。因为它是 unsafe（不安全的），但是在特殊的场景下，使用了它。可以打破 Go 的类型和内存安全机制，让你获得眼前一亮的惊喜效果 😄</p>
<h3 id="pointer">Pointer</h3>
<p>为了解决这个问题，需要用到 <code>unsafe.Pointer</code>。它表示任意类型且可寻址的指针值，可以在不同的指针类型之间进行转换（类似 C 语言的 void * 的用途）</p>
<p>其包含四种核心操作：</p>
<ul>
<li>任何类型的指针值都可以转换为 Pointer</li>
<li>Pointer 可以转换为任何类型的指针值</li>
<li>uintptr 可以转换为 Pointer</li>
<li>Pointer 可以转换为 uintptr</li>
</ul>
<p>在这一部分，重点看第一点、第二点。你再想想怎么修改 “错误示例” 让它运行起来？</p>
<pre><code>func main(){
	num := 5
	numPointer := &amp;num

	flnum := (*float32)(unsafe.Pointer(numPointer))
	fmt.Println(flnum)
}
</code></pre><p>输出结果：</p>
<pre><code>0xc4200140b0
</code></pre><p>在上述代码中，我们小加改动。通过 <code>unsafe.Pointer</code> 的特性对该指针变量进行了修改，就可以完成任意类型（*T）的指针转换</p>
<p>需要注意的是，这时还无法对变量进行操作或访问。因为不知道该指针地址指向的东西具体是什么类型。不知道是什么类型，又如何进行解析呢。无法解析也就自然无法对其变更了</p>
<h3 id="offsetof">Offsetof</h3>
<p>在上小节中，我们对普通的指针变量进行了修改。那么它是否能做更复杂一点的事呢？</p>
<pre><code>type Num struct{
	i string
	j int64
}

func main(){
	n := Num{i: &quot;EDDYCJY&quot;, j: 1}
	nPointer := unsafe.Pointer(&amp;n)

	niPointer := (*string)(unsafe.Pointer(nPointer))
	*niPointer = &quot;煎鱼&quot;

	njPointer := (*int64)(unsafe.Pointer(uintptr(nPointer) + unsafe.Offsetof(n.j)))
	*njPointer = 2

	fmt.Printf(&quot;n.i: %s, n.j: %d&quot;, n.i, n.j)
}

</code></pre><p>输出结果：</p>
<pre><code>n.i: 煎鱼, n.j: 2
</code></pre><p>在剖析这段代码做了什么事之前，我们需要了解结构体的一些基本概念：</p>
<ul>
<li>结构体的成员变量在内存存储上是一段连续的内存</li>
<li>结构体的初始地址就是第一个成员变量的内存地址</li>
<li>基于结构体的成员地址去计算偏移量。就能够得出其他成员变量的内存地址</li>
</ul>
<p>再回来看看上述代码，得出执行流程：</p>
<ul>
<li>
<p>修改 <code>n.i</code> 值：<code>i</code> 为第一个成员变量。因此不需要进行偏移量计算，直接取出指针后转换为 <code>Pointer</code>，再强制转换为字符串类型的指针值即可</p>
</li>
<li>
<p>修改 <code>n.j</code> 值：<code>j</code> 为第二个成员变量。需要进行偏移量计算，才可以对其内存地址进行修改。在进行了偏移运算后，当前地址已经指向第二个成员变量。接着重复转换赋值即可</p>
</li>
</ul>
<p>需要注意的是，这里使用了如下方法（来完成偏移计算的目标）：</p>
<p>1、uintptr：<code>uintptr</code> 是 Go 的内置类型。返回无符号整数，可存储一个完整的地址。后续常用于指针运算</p>
<pre><code>type uintptr uintptr
</code></pre><p>2、unsafe.Offsetof：返回成员变量 x 在结构体当中的偏移量。更具体的讲，就是返回结构体初始位置到 x 之间的字节数。需要注意的是入参 <code>ArbitraryType</code> 表示任意类型，并非定义的 <code>int</code>。它实际作用是一个占位符</p>
<pre><code>func Offsetof(x ArbitraryType) uintptr
</code></pre><p>在这一部分，其实就是巧用了 <code>Pointer</code> 的第三、第四点特性。这时候就已经可以对变量进行操作了 😄</p>
<h3 id="错误示例-1">错误示例</h3>
<pre><code>func main(){
	n := Num{i: &quot;EDDYCJY&quot;, j: 1}
	nPointer := unsafe.Pointer(&amp;n)
    ...

	ptr := uintptr(nPointer)
	njPointer := (*int64)(unsafe.Pointer(ptr + unsafe.Offsetof(n.j)))
	...
}
</code></pre><p>这里存在一个问题，<code>uintptr</code> 类型是不能存储在临时变量中的。因为从 GC 的角度来看，<code>uintptr</code> 类型的临时变量只是一个无符号整数，并不知道它是一个指针地址</p>
<p>因此当满足一定条件后，<code>ptr</code> 这个临时变量是可能被垃圾回收掉的，那么接下来的内存操作，岂不成迷？</p>
<h2 id="总结">总结</h2>
<p>简洁回顾两个知识点。第一是 <code>unsafe.Pointer</code> 可以让你的变量在不同的指针类型转来转去，也就是表示为任意可寻址的指针类型。第二是 <code>uintptr</code> 常用于与 <code>unsafe.Pointer</code> 打配合，用于做指针运算，巧妙地很</p>
<p>最后还是那句，没有特殊必要的话。是不建议使用 <code>unsafe</code> 标准库，它并不安全。虽然它常常能让你眼前一亮 👌</p>
]]></content>
		</item>
		
		<item>
			<title>深入理解 Go Slice</title>
			<link>https://eddycjy.com/posts/go/slice/2018-12-11-slice/</link>
			<pubDate>Tue, 11 Dec 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/slice/2018-12-11-slice/</guid>
			<description>是什么 在 Go 中，Slice（切片）是抽象在 Array（数组）之上的特殊类型。为了更好地了解 Slice，第一步需要先对 Array 进行理解。深刻了解 Slice 与 Array 之间的区别后，就能更好的对其底层一番摸索 😄
用法 Array func main() { nums := [3]int{} nums[0] = 1 n := nums[0] n = 2 fmt.Printf(&amp;#34;nums: %v\n&amp;#34;, nums) fmt.Printf(&amp;#34;n: %d\n&amp;#34;, n) } 我们可得知在 Go 中，数组类型需要指定长度和元素类型。在上述代码中，可得知 [3]int{} 表示 3 个整数的数组，并进行了初始化。底层数据存储为一段连续的内存空间，通过固定的索引值（下标）进行检索
数组在声明后，其元素的初始值（也就是零值）为 0。并且该变量可以直接使用，不需要特殊操作
同时数组的长度是固定的，它的长度是类型的一部分，因此 [3]int 和 [4]int 在类型上是不同的，不能称为 “一个东西”
输出结果 nums: [1 0 0] n: 2 Slice func main() { nums := [3]int{} nums[0] = 1 dnums := nums[:] fmt.</description>
			<content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2020/02/27/3dXSeA.png" alt="image"></p>
<h2 id="是什么">是什么</h2>
<p>在 Go 中，Slice（切片）是抽象在 Array（数组）之上的特殊类型。为了更好地了解 Slice，第一步需要先对 Array 进行理解。深刻了解 Slice 与 Array 之间的区别后，就能更好的对其底层一番摸索 😄</p>
<h2 id="用法">用法</h2>
<h3 id="array">Array</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">n</span> <span class="p">=</span> <span class="mi">2</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;nums: %v\n&#34;</span><span class="p">,</span> <span class="nx">nums</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;n: %d\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们可得知在 Go 中，数组类型需要指定长度和元素类型。在上述代码中，可得知 <code>[3]int{}</code> 表示 3 个整数的数组，并进行了初始化。底层数据存储为一段连续的内存空间，通过固定的索引值（下标）进行检索</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3dXASS.png" alt="image"></p>
<p>数组在声明后，其元素的初始值（也就是零值）为 0。并且该变量可以直接使用，不需要特殊操作</p>
<p>同时数组的长度是固定的，它的长度是类型的一部分，因此 <code>[3]int</code> 和 <code>[4]int</code> 在类型上是不同的，不能称为 “一个东西”</p>
<h4 id="输出结果">输出结果</h4>
<pre><code>nums: [1 0 0]
n: 2
</code></pre><h3 id="slice">Slice</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="nx">dnums</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[:]</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;dnums: %v&#34;</span><span class="p">,</span> <span class="nx">dnums</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Slice 是对 Array 的抽象，类型为 <code>[]T</code>。在上述代码中，<code>dnums</code> 变量通过 <code>nums[:]</code> 进行赋值。需要注意的是，Slice 和 Array 不一样，它不需要指定长度。也更加的灵活，能够自动扩容</p>
<h2 id="数据结构">数据结构</h2>
<p><img src="https://s2.ax1x.com/2020/02/27/3wmr3F.png" alt="image"></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">len</span>   <span class="kt">int</span>
	<span class="nx">cap</span>   <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>Slice 的底层数据结构共分为三部分，如下：</p>
<ul>
<li>array：指向所引用的数组指针（<code>unsafe.Pointer</code> 可以表示任何可寻址的值的指针）</li>
<li>len：长度，当前引用切片的元素个数</li>
<li>cap：容量，当前引用切片的容量（底层数组的元素总数）</li>
</ul>
<p>在实际使用中，cap 一定是大于或等于 len 的。否则会导致 panic</p>
<h3 id="示例">示例</h3>
<p>为了更好的理解，我们回顾上小节的代码便于演示，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="nx">dnums</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[:]</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;dnums: %v&#34;</span><span class="p">,</span> <span class="nx">dnums</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><img src="https://s2.ax1x.com/2020/02/27/3wmoge.png" alt="image"></p>
<p>在代码中，可观察到 <code>dnums := nums[:]</code>，这段代码确定了 Slice 的 Pointer 指向数组，且 len 和 cap 都为数组的基础属性。与图示表达一致</p>
<h3 id="lencap-不同">len、cap 不同</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="nx">dnums</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;dnums: %v, len: %d, cap: %d&#34;</span><span class="p">,</span> <span class="nx">dnums</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dnums</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">dnums</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p><img src="https://s2.ax1x.com/2020/02/27/3wmxC8.png" alt="image"></p>
<h4 id="输出结果-1">输出结果</h4>
<pre><code>dnums: [1 0], len: 2, cap: 3
</code></pre><p>显然，在这里指定了 <code>Slice[0:2]</code>，因此 len 为所引用元素的个数，cap 为所引用的数组元素总个数。与期待一致 😄</p>
<h2 id="创建">创建</h2>
<p>Slice 的创建有两种方式，如下：</p>
<ul>
<li><code>var []T</code> 或 <code>[]T{}</code></li>
<li><code>func make（[] T，len，cap）[] T</code></li>
</ul>
<p>可以留意 make 函数，我们都知道 Slice 需要指向一个 Array。那 make 是怎么做的呢？</p>
<p>它会在调用 make 的时候，分配一个数组并返回引用该数组的 Slice</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
	<span class="nx">maxElements</span> <span class="o">:=</span> <span class="nf">maxSliceCap</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">len</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxElements</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;makeslice: len out of range&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">len</span> <span class="o">||</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxElements</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;makeslice: cap out of range&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">),</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">p</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>根据传入的 Slice 类型，获取其类型能够申请的最大容量大小</li>
<li>判断 len 是否合规，检查是否在 0 &lt; x &lt; maxElements 范围内</li>
<li>判断 cap 是否合规，检查是否在 len &lt; x &lt; maxElements 范围内</li>
<li>申请 Slice 所需的内存空间对象。若为大型对象（大于 32 KB）则直接从堆中分配</li>
<li>返回申请成功的 Slice 内存地址和相关属性（默认返回申请到的内存起始地址）</li>
</ul>
<h2 id="扩容">扩容</h2>
<p>当使用 Slice 时，若存储的元素不断增长（例如通过 append）。当条件满足扩容的策略时，将会触发自动扩容</p>
<p>那么分别是什么规则呢？让我们一起看看源码是怎么说的 😄</p>
<h3 id="zerobase">zerobase</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;growslice: cap out of range&#34;</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nx">slice</span><span class="p">{</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">zerobase</span><span class="p">),</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">}</span>
	<span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>当 Slice size 为 0 时，若将要扩容的容量比原本的容量小，则抛出异常（也就是不支持缩容操作）。否则，将重新生成一个新的 Slice 返回，其 Pointer 指向一个 0 byte 地址（不会保留老的 Array 指向）</p>
<h3 id="扩容---计算策略">扩容 - 计算策略</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span>
	<span class="nx">doublecap</span> <span class="o">:=</span> <span class="nx">newcap</span> <span class="o">+</span> <span class="nx">newcap</span>
	<span class="k">if</span> <span class="nx">cap</span> <span class="p">&gt;</span> <span class="nx">doublecap</span> <span class="p">{</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">1024</span> <span class="p">{</span>
			<span class="nx">newcap</span> <span class="p">=</span> <span class="nx">doublecap</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="mi">0</span> <span class="p">&lt;</span> <span class="nx">newcap</span> <span class="o">&amp;&amp;</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="nx">cap</span> <span class="p">{</span>
				<span class="nx">newcap</span> <span class="o">+=</span> <span class="nx">newcap</span> <span class="o">/</span> <span class="mi">4</span>
			<span class="p">}</span>
			<span class="o">...</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>若 Slice cap 大于 doublecap，则扩容后容量大小为 新 Slice 的容量（超了基准值，我就只给你需要的容量大小）</li>
<li>若 Slice len 小于 1024 个，在扩容时，增长因子为 1（也就是 3 个变 6 个）</li>
<li>若 Slice len 大于 1024 个，在扩容时，增长因子为 0.25（原本容量的四分之一）</li>
</ul>
<p>注：也就是小于 1024 个时，增长 2 倍。大于 1024 个时，增长 1.25 倍</p>
<h3 id="扩容---内存策略">扩容 - 内存策略</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="kd">var</span> <span class="nx">overflow</span> <span class="kt">bool</span>
	<span class="kd">var</span> <span class="nx">lenmem</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">,</span> <span class="nx">capmem</span> <span class="kt">uintptr</span>
	<span class="kd">const</span> <span class="nx">ptrSize</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">((</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="kc">nil</span><span class="p">))</span>
	<span class="k">switch</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
		<span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span>
		<span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span>
		<span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>
		<span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">_MaxMem</span>
		<span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>
	    <span class="o">...</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span> <span class="o">||</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">capmem</span> <span class="p">&gt;</span> <span class="nx">_MaxMem</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">errorString</span><span class="p">(</span><span class="s">&#34;growslice: cap out of range&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="k">if</span> <span class="nx">et</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindNoPointers</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">capmem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nf">memmove</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">lenmem</span><span class="p">)</span>
		<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">),</span> <span class="nx">capmem</span><span class="o">-</span><span class="nx">newlenmem</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">capmem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">memmove</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">lenmem</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">lenmem</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
				<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">et</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span> <span class="nf">add</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">i</span><span class="p">))</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>1、获取老 Slice 长度和计算假定扩容后的新 Slice 元素长度、容量大小以及指针地址（用于后续操作内存的一系列操作）</p>
<p>2、确定新 Slice 容量大于老 Sice，并且新容量内存小于指定的最大内存、没有溢出。否则抛出异常</p>
<p>3、若元素类型为 <code>kindNoPointers</code>，也就是<strong>非指针</strong>类型。则在老 Slice 后继续扩容</p>
<ul>
<li>第一步：根据先前计算的 <code>capmem</code>，在老 Slice cap 后继续申请内存空间，其后用于扩容</li>
<li>第二步：将 old.array 上的 n 个 bytes（根据 lenmem）拷贝到新的内存空间上</li>
<li>第三步：新内存空间（p）加上新 Slice cap 的容量地址。最终得到完整的新 Slice cap 内存地址 <code>add(p, newlenmem)</code> （ptr）</li>
<li>第四步：从 ptr 开始重新初始化 n 个 bytes（capmem-newlenmem）</li>
</ul>
<p>注：那么问题来了，为什么要重新初始化这块内存呢？这是因为 ptr 是未初始化的内存（例如：可重用的内存，一般用于新的内存分配），其可能包含 “垃圾”。因此在这里应当进行 “清理”。便于后面实际使用（扩容）</p>
<p>4、不满足 3 的情况下，重新申请并初始化一块内存给新 Slice 用于存储 Array</p>
<p>5、检测当前是否正在执行 GC，也就是当前是否启用 Write Barrier（写屏障），若<strong>启用</strong>则通过 <code>typedmemmove</code> 方法，利用指针运算<strong>循环拷贝</strong>。否则通过 <code>memmove</code> 方法采取<strong>整体拷贝</strong>的方式将 lenmem 个字节从 old.array 拷贝到 ptr，以此达到更高的效率</p>
<p>注：一般会在 GC 标记阶段启用 Write Barrier，并且 Write Barrier 只针对指针启用。那么在第 5 点中，你就不难理解为什么会有两种截然不同的处理方式了</p>
<h4 id="小结">小结</h4>
<p>这里需要注意的是，扩容时的内存管理的选择项，如下：</p>
<ul>
<li>翻新扩展：当前元素为 <code>kindNoPointers</code>，将在老 Slice cap 的地址后继续申请空间用于扩容</li>
<li>举家搬迁：重新申请一块内存地址，整体迁移并扩容</li>
</ul>
<h3 id="两个小-陷阱">两个小 “陷阱”</h3>
<h4 id="一同根">一、同根</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;nums: %v , len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nx">nums</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>

	<span class="nx">dnums</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
	<span class="nx">dnums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">5</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;nums: %v ,len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nx">nums</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;dnums: %v, len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nx">dnums</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dnums</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">dnums</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>nums: [1 0 0] , len: 3, cap: 3
nums: [5 0 0] ,len: 3, cap: 3
dnums: [5 0], len: 2, cap: 3
</code></pre><p>在<strong>未扩容前</strong>，Slice array 指向所引用的 Array。因此在 Slice 上的变更。会直接修改到原始 Array 上（两者所引用的是同一个）</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wnibn.png" alt="image"></p>
<h4 id="二时过境迁">二、时过境迁</h4>
<p>随着 Slice 不断 append，内在的元素越来越多，终于触发了扩容。如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;nums: %v , len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nx">nums</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>

	<span class="nx">dnums</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
	<span class="nx">dnums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">dnums</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">dnums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;nums: %v ,len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nx">nums</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;dnums: %v, len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nx">dnums</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dnums</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">dnums</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>nums: [1 0 0] , len: 3, cap: 3
nums: [1 0 0] ,len: 3, cap: 3
dnums: [1 1 2 3], len: 4, cap: 6
</code></pre><p>往 Slice append 元素时，若满足扩容策略，也就是假设插入后，原本数组的容量就超过最大值了</p>
<p>这时候内部就会重新申请一块内存空间，将原本的元素<strong>拷贝</strong>一份到新的内存空间上。此时其与原本的数组就没有任何关联关系了，<strong>再进行修改值也不会变动到原始数组</strong>。这是需要注意的</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3wnAU0.png" alt="image"></p>
<h2 id="复制">复制</h2>
<h3 id="原型">原型</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">copy</span><span class="err">（</span><span class="nx">dst</span><span class="err">，</span><span class="nx">src</span> <span class="p">[]</span> <span class="nx">T</span><span class="err">）</span><span class="kt">int</span>
</code></pre></div><p>copy 函数将数据从<strong>源 Slice</strong>复制到<strong>目标 Slice</strong>。它返回复制的元素数。</p>
<h3 id="示例-1">示例</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">dst</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">src</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;dst: %v, n: %d&#34;</span><span class="p">,</span> <span class="nx">dst</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>copy 函数支持在不同长度的 Slice 之间进行复制，若出现长度不一致，在复制时会按照最少的 Slice 元素个数进行复制</p>
<p>那么在源码中是如何完成复制这一个行为的呢？我们来一起看看源码的实现，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">slicecopy</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">fm</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">width</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">len</span>
	<span class="k">if</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">n</span>
	<span class="p">}</span>

	<span class="o">...</span>

	<span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">*</span> <span class="nx">width</span>
	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">)</span> <span class="c1">// known to be a byte pointer
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nf">memmove</span><span class="p">(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>若源 Slice 或目标 Slice 存在长度为 0 的情况，则直接返回 0（因为压根不需要执行复制行为）</li>
<li>通过对比两个 Slice，获取最小的 Slice 长度。便于后续操作</li>
<li>若 Slice 只有一个元素，则直接利用指针的特性进行转换</li>
<li>若 Slice 大于一个元素，则从 <code>fm.array</code> 复制 <code>size</code> 个字节到 <code>to.array</code> 的地址处（会覆盖原有的值）</li>
</ul>
<h2 id="奇特的初始化">&ldquo;奇特&quot;的初始化</h2>
<p>在 Slice 中流传着两个传说，分别是 Empty 和 Nil Slice，接下来让我们看看它们的小区别 🤓</p>
<h3 id="empty">Empty</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nx">renums</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;nums: %v, len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nx">nums</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;renums: %v, len: %d, cap: %d\n&#34;</span><span class="p">,</span> <span class="nx">renums</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">renums</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">renums</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>nums: [], len: 0, cap: 0
renums: [], len: 0, cap: 0
</code></pre><h3 id="nil">Nil</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<pre><code>nums: [], len: 0, cap: 0
</code></pre><h3 id="想一想">想一想</h3>
<p>乍一看，Empty Slice 和 Nil Slice 好像一模一样？不管是 len，还是 cap 都为 0。好像没区别？我们再看看如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">renums</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">nums</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;nums is nil.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">renums</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;renums is nil.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>你觉得输出结果是什么呢？你可能已经想到了，最终的输出结果：</p>
<pre><code>nums is nil.
</code></pre><h4 id="为什么">为什么</h4>
<h5 id="empty-1">Empty</h5>
<p><img src="https://s2.ax1x.com/2020/02/27/3wncRS.png" alt="image"></p>
<h5 id="nil-1">Nil</h5>
<p><img src="https://s2.ax1x.com/2020/02/27/3wn5aq.png" alt="image"></p>
<p>从图示中可以看出来，两者有本质上的区别。其底层数组的指向指针是不一样的，Nil Slice 指向的是 nil，Empty Slice 指向的是实际存在的空数组地址</p>
<p>你可以认为，Nil Slice 代指不存在的 Slice，Empty Slice 代指空集合。两者所代表的意义是完全不同的</p>
<h2 id="总结">总结</h2>
<p>通过本文，可得知 Go Slice 相当灵活。不需要你手动扩容，也不需要你关注加多少减多少。对 Array 是动态引用，是 Go 类型的一个极大的补充，也因此在应用中使用的更多、更便捷</p>
<p>虽然有个别要注意的 “坑”，但其实是合理的。你觉得呢？😄</p>
]]></content>
		</item>
		
		<item>
			<title>fmt 标准库 --- Print* 是怎么样输出的？</title>
			<link>https://eddycjy.com/posts/go/pkg/2018-12-04-fmt/</link>
			<pubDate>Tue, 04 Dec 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/pkg/2018-12-04-fmt/</guid>
			<description>前言 package main import ( &amp;quot;fmt&amp;quot; ) func main() { fmt.Println(&amp;quot;Hello World!&amp;quot;) } 标准开场见多了，那内部标准库又是怎么输出这段英文的呢？今天一起来围观下源码吧 🤭
原型 func Print(a ...interface{}) (n int, err error) { return Fprint(os.Stdout, a...) } func Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...) } func Printf(format string, a ...interface{}) (n int, err error) { return Fprintf(os.Stdout, format, a...) }  Print：使用默认格式说明符打印格式并写入标准输出。当两者都不是字符串时，在操作数之间添加空格 Println：同上，不同的地方是始终在操作数之间添加空格，并附加换行符 Printf：根据格式说明符进行格式化并写入标准输出  以上三类就是最常见的格式化 I/O 的方法，我们将基于此去进行拆解描述
执行流程 案例一：Print 在这里我们使用 Print 方法做一个分析，便于后面的加深理解 😄
func Print(a .</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<pre><code>package main

import (
	&quot;fmt&quot;
)

func main() {
	fmt.Println(&quot;Hello World!&quot;)
}
</code></pre><p>标准开场见多了，那内部标准库又是怎么输出这段英文的呢？今天一起来围观下源码吧 🤭</p>
<h2 id="原型">原型</h2>
<pre><code>func Print(a ...interface{}) (n int, err error) {
	return Fprint(os.Stdout, a...)
}

func Println(a ...interface{}) (n int, err error) {
	return Fprintln(os.Stdout, a...)
}

func Printf(format string, a ...interface{}) (n int, err error) {
	return Fprintf(os.Stdout, format, a...)
}
</code></pre><ul>
<li>Print：使用默认格式说明符打印格式并写入标准输出。当两者都不是字符串时，在操作数之间添加空格</li>
<li>Println：同上，不同的地方是始终在操作数之间添加空格，并附加换行符</li>
<li>Printf：根据格式说明符进行格式化并写入标准输出</li>
</ul>
<p>以上三类就是最常见的格式化 I/O 的方法，我们将基于此去进行拆解描述</p>
<h2 id="执行流程">执行流程</h2>
<h3 id="案例一print">案例一：Print</h3>
<p>在这里我们使用 <code>Print</code> 方法做一个分析，便于后面的加深理解 😄</p>
<pre><code>func Print(a ...interface{}) (n int, err error) {
	return Fprint(os.Stdout, a...)
}
</code></pre><p><code>Print</code> 使用默认格式说明符打印格式并写入标准输出。另外当两者都为非空字符串时将插入一个空格</p>
<h4 id="原型-1">原型</h4>
<pre><code>func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrint(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
</code></pre><p>该函数一共有两个形参：</p>
<ul>
<li>w：输出流，只要实现 io.Writer 就可以（抽象）为流的写入</li>
<li>a：任意类型的多个值</li>
</ul>
<h4 id="分析主干流程">分析主干流程</h4>
<p>1、 p := newPrinter(): 申请一个临时对象池（sync.Pool）</p>
<pre><code>var ppFree = sync.Pool{
	New: func() interface{} { return new(pp) },
}

func newPrinter() *pp {
	p := ppFree.Get().(*pp)
	p.panicking = false
	p.erroring = false
	p.fmt.init(&amp;p.buf)
	return p
}
</code></pre><ul>
<li>ppFree.Get()：基于 sync.Pool 实现 *pp 的临时对象池，每次获取一定会返回一个新的 pp 对象用于接下来的处理</li>
<li>*pp.panicking：用于解决无限递归的 panic、recover 问题，会根据该参数在 catchPanic 及时掐断</li>
<li>*pp.erroring：用于表示正在处理错误无效的 verb 标识符，主要作用是防止调用 handleMethods 方法</li>
<li>*pp.fmt.init(&amp;p.buf)：初始化 fmt 配置，会设置 buf 并且清空 fmtFlags 标志位</li>
</ul>
<p>2、 p.doPrint(a): 执行约定的格式化动作（参数间增加一个空格、最后一个参数增加换行符）</p>
<pre><code>func (p *pp) doPrint(a []interface{}) {
	prevString := false
	for argNum, arg := range a {
	    true &amp;&amp; false
		isString := arg != nil &amp;&amp; reflect.TypeOf(arg).Kind() == reflect.String
		// Add a space between two non-string arguments.
		if argNum &gt; 0 &amp;&amp; !isString &amp;&amp; !prevString {
			p.buf.WriteByte(' ')
		}
		p.printArg(arg, 'v')
		prevString = isString
	}
}
</code></pre><p>可以看到底层通过判断该入参，<strong>同时</strong>满足以下条件就会添加分隔符（空格）：</p>
<ul>
<li>当前入参为多个参数（例如：Slice）</li>
<li>当前入参不为 nil 且不为字符串（通过反射确定）</li>
<li>当前入参不为首项或上一个入参不为字符串</li>
</ul>
<p>而在 <code>Print</code> 方法中，不需要指定格式符。实际上在该方法内直接指定为 <code>v</code>。也就是默认格式的值</p>
<pre><code>p.printArg(arg, 'v')
</code></pre><ol start="3">
<li>
<p>w.Write(p.buf): 写入标准输出（io.Writer）</p>
</li>
<li>
<p>*pp.free(): 释放已缓存的内容。在使用完临时对象后，会将 buf、arg、value 清空再重新存放到 ppFree 中。以便于后面再取出重用（利用 sync.Pool 的临时对象特性）</p>
</li>
</ol>
<h3 id="案例二printf">案例二：Printf</h3>
<h4 id="标识符">标识符</h4>
<h5 id="verbs">Verbs</h5>
<pre><code>%v	the value in a default format
	when printing structs, the plus flag (%+v) adds field names
%#v	a Go-syntax representation of the value
%T	a Go-syntax representation of the type of the value
%%	a literal percent sign; consumes no value
%t	the word true or false
</code></pre><h5 id="flags">Flags</h5>
<pre><code>+	always print a sign for numeric values;
	guarantee ASCII-only output for %q (%+q)
-	pad with spaces on the right rather than the left (left-justify the field)
#	alternate format: add leading 0 for octal (%#o), 0x for hex (%#x);
	0X for hex (%#X); suppress 0x for %p (%#p);
	for %q, print a raw (backquoted) string if strconv.CanBackquote
	returns true;
	always print a decimal point for %e, %E, %f, %F, %g and %G;
	do not remove trailing zeros for %g and %G;
	write e.g. U+0078 'x' if the character is printable for %U (%#U).
' '	(space) leave a space for elided sign in numbers (% d);
	put spaces between bytes printing strings or slices in hex (% x, % X)
0	pad with leading zeros rather than spaces;
	for numbers, this moves the padding after the sign
</code></pre><p>详细建议参见 <a href="https://golang.org/pkg/fmt/#hdr-Printing">Godoc</a></p>
<h4 id="原型-2">原型</h4>
<pre><code>func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrintf(format, a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
</code></pre><p>与 Print 相比，最大的不同就是 doPrintf 方法了。在这里我们来详细看看其代码，如下：</p>
<pre><code>func (p *pp) doPrintf(format string, a []interface{}) {
	end := len(format)
	argNum := 0         // we process one argument per non-trivial format
	afterIndex := false // previous item in format was an index like [3].
	p.reordered = false
formatLoop:
	for i := 0; i &lt; end; {
		p.goodArgNum = true
		lasti := i
		for i &lt; end &amp;&amp; format[i] != '%' {
			i++
		}
		if i &gt; lasti {
			p.buf.WriteString(format[lasti:i])
		}
		if i &gt;= end {
			// done processing format string
			break
		}

		// Process one verb
		i++

		// Do we have flags?
		p.fmt.clearflags()
	simpleFormat:
		for ; i &lt; end; i++ {
			c := format[i]
			switch c {
			case '#':   //'#'、'0'、'+'、'-'、' '
				...
			default:
				if 'a' &lt;= c &amp;&amp; c &lt;= 'z' &amp;&amp; argNum &lt; len(a) {
					...
					p.printArg(a[argNum], rune(c))
					argNum++
					i++
					continue formatLoop
				}
				
				break simpleFormat
			}
		}

		// Do we have an explicit argument index?
		argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))

		// Do we have width?
		if i &lt; end &amp;&amp; format[i] == '*' {
			...
		}

		// Do we have precision?
		if i+1 &lt; end &amp;&amp; format[i] == '.' {
			...
		}

		if !afterIndex {
			argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))
		}

		if i &gt;= end {
			p.buf.WriteString(noVerbString)
			break
		}

		...

		switch {
		case verb == '%': // Percent does not absorb operands and ignores f.wid and f.prec.
			p.buf.WriteByte('%')
		case !p.goodArgNum:
			p.badArgNum(verb)
		case argNum &gt;= len(a): // No argument left over to print for the current verb.
			p.missingArg(verb)
		case verb == 'v':
			...
			fallthrough
		default:
			p.printArg(a[argNum], verb)
			argNum++
		}
	}

	if !p.reordered &amp;&amp; argNum &lt; len(a) {
		...
	}
}
</code></pre><h4 id="分析主干流程-1">分析主干流程</h4>
<ol>
<li>写入 % 之前的字符内容</li>
<li>如果所有标志位处理完毕（到达字符尾部），则跳出处理逻辑</li>
<li>（往后移）跳过 % ，开始处理其他 verb 标志位</li>
<li>清空（重新初始化） fmt 配置</li>
<li>处理一些基础的 verb 标识符（simpleFormat）。如：'#'、&lsquo;0&rsquo;、&lsquo;+&rsquo;、'-'、&rsquo; ' 以及<strong>简单的 verbs 标识符（不包含精度、宽度和参数索引）。需要注意的是，若当前字符为简单 verb 标识符。则直接进行处理。完成后会直接后移到下一个字符</strong>。其余标志位则变更 fmt 配置项，便于后续处理</li>
<li>处理参数索引（argument index）</li>
<li>处理参数宽度（width）</li>
<li>处理参数精度（precision）</li>
<li>% 之后若不存在 verbs 标识符则返回 <code>noVerbString</code>。值为 %!(NOVERB)</li>
<li>处理特殊 verbs 标识符（如：'%%'、'%#v&rsquo;、'%+v&rsquo;）、错误情况（如：参数索引指定错误、参数集个数与 verbs 标识符数量不匹配）或进行格式化参数集</li>
<li>常规流程处理完毕</li>
</ol>
<p>在特殊情况下，若提供的参数集比 verb 标识符多。fmt 将会贪婪检查下去，将多出的参数集以特定的格式输出，如下：</p>
<pre><code>fmt.Printf(&quot;%d&quot;, 1, 2, 3)
// 1%!(EXTRA int=2, int=3)
</code></pre><ul>
<li>约定前缀额外标志：%!(EXTRA</li>
<li>当前参数的类型</li>
<li>约定格式符：=</li>
<li>当前参数的值（默认以 %v 格式化）</li>
<li>约定格式符：)</li>
</ul>
<p>值得注意的是，当指定了参数索引或实际处理的参数小于入参的参数集时，就不会进行贪婪匹配来展示</p>
<h3 id="案例三println">案例三：Println</h3>
<h4 id="原型-3">原型</h4>
<pre><code>func Fprintln(w io.Writer, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrintln(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
</code></pre><p>在这个方法中，最大的区别就是 doPrintln，我们一起来看看，如下：</p>
<pre><code>func (p *pp) doPrintln(a []interface{}) {
	for argNum, arg := range a {
		if argNum &gt; 0 {
			p.buf.WriteByte(' ')
		}
		p.printArg(arg, 'v')
	}
	p.buf.WriteByte('\n')
}
</code></pre><h4 id="分析主干流程-2">分析主干流程</h4>
<ul>
<li>循环入参的参数集，并以空格分隔</li>
<li>格式化当前参数，默认以 <code>%v</code> 对参数进行格式化</li>
<li>在结尾添加 <code>\n</code> 字符</li>
</ul>
<h2 id="如何格式化参数">如何格式化参数</h2>
<p>在上例的执行流程分析中，可以看到格式化参数这一步是在 <code>p.printArg(arg, verb)</code> 执行的，我们一起来看看它都做了些什么？</p>
<pre><code>func (p *pp) printArg(arg interface{}, verb rune) {
	p.arg = arg
	p.value = reflect.Value{}

	if arg == nil {
		switch verb {
		case 'T', 'v':
			p.fmt.padString(nilAngleString)
		default:
			p.badVerb(verb)
		}
		return
	}

	switch verb {
	case 'T':
		p.fmt.fmt_s(reflect.TypeOf(arg).String())
		return
	case 'p':
		p.fmtPointer(reflect.ValueOf(arg), 'p')
		return
	}

	// Some types can be done without reflection.
	switch f := arg.(type) {
	case bool:
		p.fmtBool(f, verb)
	case float32:
		p.fmtFloat(float64(f), 32, verb)
	...
	case reflect.Value:
		if f.IsValid() &amp;&amp; f.CanInterface() {
			p.arg = f.Interface()
			if p.handleMethods(verb) {
				return
			}
		}
		p.printValue(f, verb, 0)
	default:
		if !p.handleMethods(verb) {
			p.printValue(reflect.ValueOf(f), verb, 0)
		}
	}
}
</code></pre><p>在小节代码中可以看见，fmt 本身对不同的类型做了不同的处理。这样子就避免了通过反射确定。相对的提高了性能</p>
<p>其中有两个特殊的方法，分别是 <code>handleMethods</code> 和 <code>badVerb</code>，接下来分别来看看他们的作用是什么</p>
<p>1、badVerb</p>
<p>它主要用于格式化并处理错误的行为。我们可以一起来看看，代码如下：</p>
<pre><code>func (p *pp) badVerb(verb rune) {
	p.erroring = true
	p.buf.WriteString(percentBangString)
	p.buf.WriteRune(verb)
	p.buf.WriteByte('(')
	switch {
	case p.arg != nil:
		p.buf.WriteString(reflect.TypeOf(p.arg).String())
		p.buf.WriteByte('=')
		p.printArg(p.arg, 'v')
	...
	default:
		p.buf.WriteString(nilAngleString)
	}
	p.buf.WriteByte(')')
	p.erroring = false
}
</code></pre><p>在处理错误格式化时，我们可以对比以下例子：</p>
<pre><code>fmt.Printf(&quot;%s&quot;, []int64{1, 2, 3})
// [%!s(int64=1) %!s(int64=2) %!s(int64=3)]%
</code></pre><p>在 badVerb 中可以看到错误字符串的处理主要分为以下部分：</p>
<ul>
<li>约定前缀错误标志：%!</li>
<li>当前的格式化操作符</li>
<li>约定格式符：(</li>
<li>当前参数的类型</li>
<li>约定格式符：=</li>
<li>当前参数的值（默认以 %v 格式化）</li>
<li>约定格式符：)</li>
</ul>
<p>2、handleMethods</p>
<pre><code>func (p *pp) handleMethods(verb rune) (handled bool) {
	if p.erroring {
		return
	}
	// Is it a Formatter?
	if formatter, ok := p.arg.(Formatter); ok {
		handled = true
		defer p.catchPanic(p.arg, verb)
		formatter.Format(p, verb)
		return
	}

	// If we're doing Go syntax and the argument knows how to supply it, take care of it now.
	...
	
	return false
}
</code></pre><p>这个方法比较特殊，一般在自定义结构体和未知情况下进行调用。主要流程是：</p>
<ul>
<li>若当前参数为错误 verb 标识符，则直接返回</li>
<li>判断是否实现了 Formatter</li>
<li>实现，则利用自定义 Formatter 格式化参数</li>
<li>未实现，则最大程度的利用 Go syntax 默认规则去格式化参数</li>
</ul>
<h2 id="拓展">拓展</h2>
<p>在 fmt 标准库中可以通过自定义结构体来实现方法的自定义，大致如下几种</p>
<h3 id="fmtstate">fmt.State</h3>
<pre><code>type State interface {
	Write(b []byte) (n int, err error)

	Width() (wid int, ok bool)

	Precision() (prec int, ok bool)

	Flag(c int) bool
}
</code></pre><p>State 用于获取标志位的状态值，涉及如下：</p>
<ul>
<li>Write：将格式化完毕的字符写入缓冲区中，等待下一步处理</li>
<li>Width：返回宽度信息和是否被设置</li>
<li>Precision：返回精度信息和是否被设置</li>
<li>Flag：返回特殊标志符（'#'、&lsquo;0&rsquo;、&lsquo;+&rsquo;、'-'、&rsquo; &lsquo;）是否被设置</li>
</ul>
<h3 id="fmtformatter">fmt.Formatter</h3>
<pre><code>type Formatter interface {
	Format(f State, c rune)
}
</code></pre><p>Formatter 用于实现<strong>自定义格式化方法</strong>。可通过在自定义结构体中实现 Format 方法来实现这个目的</p>
<p>另外，可以通过 f 获取到当前标识符的宽度、精度等状态值。c 为 verb 标识符，可以得到其动作是什么</p>
<h3 id="fmtstringer">fmt.Stringer</h3>
<pre><code>type Stringer interface {
	String() string
}
</code></pre><p>当该对象为 String、Array、Slice 等类型时，将会调用 <code>String()</code> 方法对类字符串进行格式化</p>
<h3 id="fmtgostringer">fmt.GoStringer</h3>
<pre><code>type GoStringer interface {
	GoString() string
}
</code></pre><p>当格式化特定 verb 标识符（%v）时，将调用 <code>GoString()</code> 方法对其进行格式化</p>
<h2 id="总结">总结</h2>
<p>通过本文对 fmt 标准库的分析，可以发现它有以下特点：</p>
<ul>
<li>在拓展性方面，可以自定义格式化方法等</li>
<li>在完整度方面，尽可能的贪婪匹配，输出参数集</li>
<li>在性能方面，每种不同的参数类型，都实现了不同的格式化处理操作</li>
<li>在性能方面，尽可能的最短匹配，格式化参数集</li>
</ul>
<p>总的来说，fmt 标准库有许多值得推敲的细节，希望你能够在本文学到 😄</p>
]]></content>
		</item>
		
		<item>
			<title>使用 Gomock 进行单元测试</title>
			<link>https://eddycjy.com/posts/go/talk/2018-11-25-gomock/</link>
			<pubDate>Sun, 25 Nov 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2018-11-25-gomock/</guid>
			<description>在实际项目中，需要进行单元测试的时候。却往往发现有一大堆依赖项。这时候就是 Gomock 大显身手的时候了
Gomock 是 Go 语言的一个 mock 框架，官方的那种 🤪
安装 $ go get -u github.com/golang/mock/gomock $ go install github.com/golang/mock/mockgen   第一步：我们将安装 gomock 第三方库和 mock 代码的生成工具 mockgen。而后者可以大大的节省我们的工作量。只需要了解其使用方式就可以
  第二步：输入 mockgen 验证代码生成工具是否安装正确。若无法正常响应，请检查 bin 目录下是否包含该二进制文件
  用法 在 mockgen 命令中，支持两种生成模式：
 source：从源文件生成 mock 接口（通过 -source 启用）  mockgen -source=foo.go [other options] reflect：通过使用反射程序来生成 mock 接口。它通过传递两个非标志参数来启用：导入路径和逗号分隔的接口列表  mockgen database/sql/driver Conn,Driver 从本质上来讲，两种方式生成的 mock 代码并没有什么区别。因此选择合适的就可以了
写测试用例 在本文将模拟一个简单 Demo 来编写测试用例，熟悉整体的测试流程
步骤  想清楚整体逻辑 定义想要（模拟）依赖项的 interface（接口） 使用 mockgen 命令对所需 mock 的 interface 生成 mock 文件 编写单元测试的逻辑，在测试中使用 mock 进行单元测试的验证  目录 ├── mock ├── person │ └── male.</description>
			<content type="html"><![CDATA[<p>在实际项目中，需要进行单元测试的时候。却往往发现有一大堆依赖项。这时候就是 <a href="https://github.com/golang/mock">Gomock</a> 大显身手的时候了</p>
<p>Gomock 是 Go 语言的一个 mock 框架，官方的那种 🤪</p>
<h2 id="安装">安装</h2>
<pre><code>$ go get -u github.com/golang/mock/gomock
$ go install github.com/golang/mock/mockgen
</code></pre><ol>
<li>
<p>第一步：我们将安装 gomock 第三方库和 mock 代码的生成工具 mockgen。而后者可以大大的节省我们的工作量。只需要了解其使用方式就可以</p>
</li>
<li>
<p>第二步：输入 <code>mockgen</code> 验证代码生成工具是否安装正确。若无法正常响应，请检查 <code>bin</code> 目录下是否包含该二进制文件</p>
</li>
</ol>
<h3 id="用法">用法</h3>
<p>在 <code>mockgen</code> 命令中，支持两种生成模式：</p>
<ol>
<li>source：从源文件生成 mock 接口（通过 -source 启用）</li>
</ol>
<pre><code>mockgen -source=foo.go [other options]
</code></pre><ol start="2">
<li>reflect：通过使用反射程序来生成 mock 接口。它通过传递两个非标志参数来启用：导入路径和逗号分隔的接口列表</li>
</ol>
<pre><code>mockgen database/sql/driver Conn,Driver
</code></pre><p>从本质上来讲，两种方式生成的 mock 代码并没有什么区别。因此选择合适的就可以了</p>
<h2 id="写测试用例">写测试用例</h2>
<p>在本文将模拟一个简单 Demo 来编写测试用例，熟悉整体的测试流程</p>
<h3 id="步骤">步骤</h3>
<ol>
<li>想清楚整体逻辑</li>
<li>定义想要（模拟）依赖项的 interface（接口）</li>
<li>使用 <code>mockgen</code> 命令对所需 mock 的 interface 生成 mock 文件</li>
<li>编写单元测试的逻辑，在测试中使用 mock</li>
<li>进行单元测试的验证</li>
</ol>
<h3 id="目录">目录</h3>
<pre><code>├── mock
├── person
│   └── male.go
└── user
    ├── user.go
    └── user_test.go
</code></pre><h3 id="编写">编写</h3>
<h4 id="interface-方法">interface 方法</h4>
<p>打开 person/male.go 文件，写入以下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">person</span>

<span class="kd">type</span> <span class="nx">Male</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Get</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><h4 id="调用方法">调用方法</h4>
<p>打开 user/user.go 文件，写入以下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">user</span>

<span class="kn">import</span> <span class="s">&#34;github.com/EDDYCJY/mockd/person&#34;</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Person</span> <span class="nx">person</span><span class="p">.</span><span class="nx">Male</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewUser</span><span class="p">(</span><span class="nx">p</span> <span class="nx">person</span><span class="p">.</span><span class="nx">Male</span><span class="p">)</span> <span class="o">*</span><span class="nx">User</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span><span class="nx">Person</span><span class="p">:</span> <span class="nx">p</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">User</span><span class="p">)</span> <span class="nf">GetUserInfo</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">u</span><span class="p">.</span><span class="nx">Person</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="生成-mock-文件">生成 mock 文件</h4>
<p>回到 <code>mockd/</code> 的根目录下，执行以下命令</p>
<pre><code>$ mockgen -source=./person/male.go -destination=./mock/male_mock.go -package=mock
</code></pre><p>在执行完毕后，可以发现 <code>mock/</code> 目录下多出了 male_mock.go 文件，这就是 mock 文件。那么命令中的指令又分别有什么用呢？如下：</p>
<ul>
<li>-source：设置需要模拟（mock）的接口文件</li>
<li>-destination：设置 mock 文件输出的地方，若不设置则打印到标准输出中</li>
<li>-package：设置 mock 文件的包名，若不设置则为 <code>mock_</code> 前缀加上文件名（如本文的包名会为 mock_person）</li>
</ul>
<p>想了解更多的指令符，可参见 <a href="https://github.com/golang/mock#running-mockgen">官方文档</a></p>
<h5 id="输出的-mock-文件">输出的 mock 文件</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Code generated by MockGen. DO NOT EDIT.
</span><span class="c1">// Source: ./person/male.go
</span><span class="c1"></span>
<span class="c1">// Package mock is a generated GoMock package.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">mock</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">gomock</span> <span class="s">&#34;github.com/golang/mock/gomock&#34;</span>
	<span class="nx">reflect</span> <span class="s">&#34;reflect&#34;</span>
<span class="p">)</span>

<span class="c1">// MockMale is a mock of Male interface
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MockMale</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ctrl</span>     <span class="o">*</span><span class="nx">gomock</span><span class="p">.</span><span class="nx">Controller</span>
	<span class="nx">recorder</span> <span class="o">*</span><span class="nx">MockMaleMockRecorder</span>
<span class="p">}</span>

<span class="c1">// MockMaleMockRecorder is the mock recorder for MockMale
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MockMaleMockRecorder</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mock</span> <span class="o">*</span><span class="nx">MockMale</span>
<span class="p">}</span>

<span class="c1">// NewMockMale creates a new mock instance
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewMockMale</span><span class="p">(</span><span class="nx">ctrl</span> <span class="o">*</span><span class="nx">gomock</span><span class="p">.</span><span class="nx">Controller</span><span class="p">)</span> <span class="o">*</span><span class="nx">MockMale</span> <span class="p">{</span>
	<span class="nx">mock</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MockMale</span><span class="p">{</span><span class="nx">ctrl</span><span class="p">:</span> <span class="nx">ctrl</span><span class="p">}</span>
	<span class="nx">mock</span><span class="p">.</span><span class="nx">recorder</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">MockMaleMockRecorder</span><span class="p">{</span><span class="nx">mock</span><span class="p">}</span>
	<span class="k">return</span> <span class="nx">mock</span>
<span class="p">}</span>

<span class="c1">// EXPECT returns an object that allows the caller to indicate expected use
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MockMale</span><span class="p">)</span> <span class="nf">EXPECT</span><span class="p">()</span> <span class="o">*</span><span class="nx">MockMaleMockRecorder</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">recorder</span>
<span class="p">}</span>

<span class="c1">// Get mocks base method
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MockMale</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ctrl</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;Get&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
	<span class="nx">ret0</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">].(</span><span class="kt">error</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret0</span>
<span class="p">}</span>

<span class="c1">// Get indicates an expected call of Get
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">mr</span> <span class="o">*</span><span class="nx">MockMaleMockRecorder</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">id</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">gomock</span><span class="p">.</span><span class="nx">Call</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">mr</span><span class="p">.</span><span class="nx">mock</span><span class="p">.</span><span class="nx">ctrl</span><span class="p">.</span><span class="nf">RecordCallWithMethodType</span><span class="p">(</span><span class="nx">mr</span><span class="p">.</span><span class="nx">mock</span><span class="p">,</span> <span class="s">&#34;Get&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">((</span><span class="o">*</span><span class="nx">MockMale</span><span class="p">)(</span><span class="kc">nil</span><span class="p">).</span><span class="nx">Get</span><span class="p">),</span> <span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="测试用例">测试用例</h4>
<p>打开 user/user_test.go 文件，写入以下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">user</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;testing&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/mockd/mock&#34;</span>

	<span class="s">&#34;github.com/golang/mock/gomock&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">TestUser_GetUserInfo</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ctl</span> <span class="o">:=</span> <span class="nx">gomock</span><span class="p">.</span><span class="nf">NewController</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">ctl</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span>

	<span class="kd">var</span> <span class="nx">id</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">mockMale</span> <span class="o">:=</span> <span class="nx">mock</span><span class="p">.</span><span class="nf">NewMockMale</span><span class="p">(</span><span class="nx">ctl</span><span class="p">)</span>
	<span class="nx">gomock</span><span class="p">.</span><span class="nf">InOrder</span><span class="p">(</span>
		<span class="nx">mockMale</span><span class="p">.</span><span class="nf">EXPECT</span><span class="p">().</span><span class="nf">Get</span><span class="p">(</span><span class="nx">id</span><span class="p">).</span><span class="nf">Return</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span>
	<span class="p">)</span>

	<span class="nx">user</span> <span class="o">:=</span> <span class="nf">NewUser</span><span class="p">(</span><span class="nx">mockMale</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">user</span><span class="p">.</span><span class="nf">GetUserInfo</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;user.GetUserInfo err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ol>
<li>
<p>gomock.NewController：返回 <code>gomock.Controller</code>，它代表 mock 生态系统中的顶级控件。定义了 mock 对象的范围、生命周期和期待值。另外它在多个 goroutine 中是安全的</p>
</li>
<li>
<p>mock.NewMockMale：创建一个新的 mock 实例</p>
</li>
<li>
<p>gomock.InOrder：声明给定的调用应按顺序进行（是对 gomock.After 的二次封装）</p>
</li>
<li>
<p>mockMale.EXPECT().Get(id).Return(nil)：这里有三个步骤，<code>EXPECT()</code>返回一个允许调用者设置<strong>期望</strong>和<strong>返回值</strong>的对象。<code>Get(id)</code> 是设置入参并调用 mock 实例中的方法。<code>Return(nil)</code> 是设置先前调用的方法出参。简单来说，就是设置入参并调用，最后设置返回值</p>
</li>
<li>
<p>NewUser(mockMale)：创建 User 实例，值得注意的是，在这里<strong>注入了 mock 对象</strong>，因此实际在随后的 <code>user.GetUserInfo(id)</code> 调用（入参：id 为 1）中。它调用的是我们事先模拟好的 mock 方法</p>
</li>
<li>
<p>ctl.Finish()：进行 mock 用例的期望值断言，一般会使用 <code>defer</code> 延迟执行，以防止我们忘记这一操作</p>
</li>
</ol>
<h3 id="测试">测试</h3>
<p>回到 <code>mockd/</code> 的根目录下，执行以下命令</p>
<pre><code>$ go test ./user
ok  	github.com/EDDYCJY/mockd/user
</code></pre><p>看到这样的结果，就大功告成啦！你可以自己调整一下 <code>Return()</code> 的返回值，以此得到不一样的测试结果哦 😄</p>
<h2 id="查看测试情况">查看测试情况</h2>
<h3 id="测试覆盖率">测试覆盖率</h3>
<pre><code>$ go test -cover ./user
ok  	github.com/EDDYCJY/mockd/user	(cached)	coverage: 100.0% of statements
</code></pre><p>可通过设置 <code>-cover</code> 标志符来开启覆盖率的统计，展示内容为 <code>coverage: 100.0%</code>。</p>
<h3 id="可视化界面">可视化界面</h3>
<ol>
<li>生成测试覆盖率的 profile 文件</li>
</ol>
<pre><code>$ go test ./... -coverprofile=cover.out
</code></pre><ol start="2">
<li>利用 profile 文件生成可视化界面</li>
</ol>
<pre><code>$ go tool cover -html=cover.out
</code></pre><ol start="3">
<li>查看可视化界面，分析覆盖情况</li>
</ol>
<p><img src="https://s2.ax1x.com/2020/02/27/3wKu7R.jpg" alt="image"></p>
<h2 id="更多">更多</h2>
<h3 id="一常用-mock-方法">一、常用 mock 方法</h3>
<h4 id="调用方法-1">调用方法</h4>
<ul>
<li>Call.Do()：声明在匹配时要运行的操作</li>
<li>Call.DoAndReturn()：声明在匹配调用时要运行的操作，并且模拟返回该函数的返回值</li>
<li>Call.MaxTimes()：设置最大的调用次数为 n 次</li>
<li>Call.MinTimes()：设置最小的调用次数为 n 次</li>
<li>Call.AnyTimes()：允许调用次数为 0 次或更多次</li>
<li>Call.Times()：设置调用次数为 n 次</li>
</ul>
<h4 id="参数匹配">参数匹配</h4>
<ul>
<li>gomock.Any()：匹配任意值</li>
<li>gomock.Eq()：通过反射匹配到指定的类型值，而不需要手动设置</li>
<li>gomock.Nil()：返回 nil</li>
</ul>
<p>建议更多的方法可参见 <a href="https://godoc.org/github.com/golang/mock/gomock#pkg-index">官方文档</a></p>
<h3 id="二生成多个-mock-文件">二、生成多个 mock 文件</h3>
<p>你可能会想一条条命令生成 mock 文件，岂不得崩溃？</p>
<p>当然，官方提供了更方便的方式，我们可以利用 <code>go:generate</code> 来完成批量处理的功能</p>
<pre><code>go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
</code></pre><h4 id="修改-interface-方法">修改 interface 方法</h4>
<p>打开 person/male.go 文件，修改为以下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">person</span>

<span class="c1">//go:generate mockgen -destination=../mock/male_mock.go -package=mock github.com/EDDYCJY/mockd/person Male
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Male</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Get</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>我们关注到 <code>go:generate</code> 这条语句，可分为以下部分：</p>
<ol>
<li>声明 <code>//go:generate</code> （注意不要留空格）</li>
<li>使用 <code>mockgen</code> 命令</li>
<li>定义 <code>-destination</code></li>
<li>定义 <code>-package</code></li>
<li>定义 <code>source</code>，此处为 person 的包路径</li>
<li>定义 <code>interfaces</code>，此处为 <code>Male</code></li>
</ol>
<h4 id="重新生成-mock-文件">重新生成 mock 文件</h4>
<p>回到 <code>mockd/</code> 的根目录下，执行以下命令</p>
<pre><code>$ go generate ./...
</code></pre><p>再检查 <code>mock/</code> 发现也已经正确生成了，在多个文件时是不是很方便呢 🤩</p>
<h2 id="总结">总结</h2>
<p>在单元测试这一环，gomock 给我们提供了极大的便利。能够 mock 掉许许多多的依赖项</p>
<p>其中还有很多的使用方式和功能。你可以 mark 住后详细阅读下官方文档，记忆会更深刻</p>
]]></content>
		</item>
		
		<item>
			<title>「连载十」分布式链路追踪 gRPC &#43; Opentracing &#43; Zipkin</title>
			<link>https://eddycjy.com/posts/go/grpc/2018-10-20-zipkin/</link>
			<pubDate>Sat, 20 Oct 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc/2018-10-20-zipkin/</guid>
			<description>在实际应用中，你做了那么多 Server 端，写了 N 个 RPC 方法。想看看方法的指标，却无处下手？
本文将通过 gRPC + Opentracing + Zipkin 搭建一个分布式链路追踪系统来实现查看整个系统的链路、性能等指标。
Opentracing 是什么 OpenTracing 通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现
不过 OpenTracing 并不是标准。因为 CNCF 不是官方标准机构，但是它的目标是致力为分布式追踪创建更标准的 API 和工具
名词解释 Trace 一个 trace 代表了一个事务或者流程在（分布式）系统中的执行过程
Span 一个 span 代表在分布式系统中完成的单个工作单元。也包含其他 span 的 “引用”，这允许将多个 spans 组合成一个完整的 Trace
每个 span 根据 OpenTracing 规范封装以下内容：
 操作名称 开始时间和结束时间 key:value span Tags key:value span Logs SpanContext  Tags Span tags（跨度标签）可以理解为用户自定义的 Span 注释。便于查询、过滤和理解跟踪数据
Logs Span logs（跨度日志）可以记录 Span 内特定时间或事件的日志信息。主要用于捕获特定 Span 的日志信息以及应用程序本身的其他调试或信息输出
SpanContext SpanContext 代表跨越进程边界，传递到子级 Span 的状态。常在追踪示意图中创建上下文时使用</description>
			<content type="html"><![CDATA[<p>在实际应用中，你做了那么多 Server 端，写了 N 个 RPC 方法。想看看方法的指标，却无处下手？</p>
<p>本文将通过 gRPC + Opentracing + Zipkin 搭建一个<strong>分布式链路追踪系统</strong>来实现查看整个系统的链路、性能等指标。</p>
<h2 id="opentracing">Opentracing</h2>
<h3 id="是什么">是什么</h3>
<p>OpenTracing 通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现</p>
<p>不过 OpenTracing 并不是标准。因为 CNCF 不是官方标准机构，但是它的目标是致力为分布式追踪创建更标准的 API 和工具</p>
<h3 id="名词解释">名词解释</h3>
<h4 id="trace">Trace</h4>
<p>一个 trace 代表了一个事务或者流程在（分布式）系统中的执行过程</p>
<h4 id="span">Span</h4>
<p>一个 span 代表在分布式系统中完成的单个工作单元。也包含其他 span 的 “引用”，这允许将多个 spans 组合成一个完整的 Trace</p>
<p>每个 span 根据 OpenTracing 规范封装以下内容：</p>
<ul>
<li>操作名称</li>
<li>开始时间和结束时间</li>
<li>key:value span Tags</li>
<li>key:value span Logs</li>
<li>SpanContext</li>
</ul>
<h4 id="tags">Tags</h4>
<p>Span tags（跨度标签）可以理解为用户自定义的 Span 注释。便于查询、过滤和理解跟踪数据</p>
<h4 id="logs">Logs</h4>
<p>Span logs（跨度日志）可以记录 Span 内特定时间或事件的日志信息。主要用于捕获特定 Span 的日志信息以及应用程序本身的其他调试或信息输出</p>
<h4 id="spancontext">SpanContext</h4>
<p>SpanContext 代表跨越进程边界，传递到子级 Span 的状态。常在追踪示意图中创建上下文时使用</p>
<h4 id="baggage-items">Baggage Items</h4>
<p>Baggage Items 可以理解为 trace 全局运行中额外传输的数据集合</p>
<h3 id="一个案例">一个案例</h3>
<p><img src="https://image.eddycjy.com/c7912244434f56f32be37ac66ad164ab.png" alt="image"></p>
<p>图中可以看到以下内容：</p>
<ul>
<li>执行时间的上下文</li>
<li>服务间的层次关系</li>
<li>服务间串行或并行调用链</li>
</ul>
<p>结合以上信息，在实际场景中我们可以通过整个系统的调用链的上下文、性能等指标信息，一下子就能够发现系统的痛点在哪儿</p>
<h2 id="zipkin">Zipkin</h2>
<p><img src="https://image.eddycjy.com/f82f883ce74801abfece12c775f45c6c.png" alt="image"></p>
<h3 id="是什么-1">是什么</h3>
<p>Zipkin 是分布式追踪系统。它的作用是收集解决微服务架构中的延迟问题所需的时序数据。它管理这些数据的收集和查找</p>
<p>Zipkin 的设计基于 <a href="http://research.google.com/pubs/pub36356.html">Google Dapper</a> 论文。</p>
<h3 id="运行">运行</h3>
<pre><code>docker run -d -p 9411:9411 openzipkin/zipkin
</code></pre><p>其他方法安装参见：https://github.com/openzipkin/zipkin</p>
<h3 id="验证">验证</h3>
<p>访问 http://127.0.0.1:9411/zipkin/ 检查 Zipkin 是否运行正常</p>
<p><img src="https://image.eddycjy.com/f22ea6012f6ce4adea9f29d36f1017c7.jpg" alt="image"></p>
<h2 id="grpc--opentracing--zipkin">gRPC + Opentracing + Zipkin</h2>
<p>在前面的小节中，我们做了以下准备工作：</p>
<ul>
<li>了解 Opentracing 是什么</li>
<li>搭建 Zipkin 提供分布式追踪系统的功能</li>
</ul>
<p>接下来实现 gRPC 通过 Opentracing 标准 API 对接 Zipkin，再通过 Zipkin 去查看数据</p>
<h3 id="目录结构">目录结构</h3>
<p>新建 simple_zipkin_client、simple_zipkin_server 目录，目录结构如下：</p>
<pre><code>go-grpc-example
├── LICENSE
├── README.md
├── client
│   ├── ...
│   ├── simple_zipkin_client
├── conf
├── pkg
├── proto
├── server
│   ├── ...
│   ├── simple_zipkin_server
└── vendor
</code></pre><h3 id="安装">安装</h3>
<pre><code>$ go get -u github.com/openzipkin/zipkin-go-opentracing
$ go get -u github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc
</code></pre><h3 id="grpc">gRPC</h3>
<h4 id="server">Server</h4>
<pre><code>package main

import (
	&quot;context&quot;
	&quot;log&quot;
	&quot;net&quot;

	&quot;github.com/grpc-ecosystem/go-grpc-middleware&quot;
	&quot;github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc&quot;
	zipkin &quot;github.com/openzipkin/zipkin-go-opentracing&quot;
	&quot;google.golang.org/grpc&quot;

	&quot;github.com/EDDYCJY/go-grpc-example/pkg/gtls&quot;
	pb &quot;github.com/EDDYCJY/go-grpc-example/proto&quot;
)

type SearchService struct{}

func (s *SearchService) Search(ctx context.Context, r *pb.SearchRequest) (*pb.SearchResponse, error) {
	return &amp;pb.SearchResponse{Response: r.GetRequest() + &quot; Server&quot;}, nil
}

const (
	PORT = &quot;9005&quot;

	SERVICE_NAME              = &quot;simple_zipkin_server&quot;
	ZIPKIN_HTTP_ENDPOINT      = &quot;http://127.0.0.1:9411/api/v1/spans&quot;
	ZIPKIN_RECORDER_HOST_PORT = &quot;127.0.0.1:9000&quot;
)

func main() {
	collector, err := zipkin.NewHTTPCollector(ZIPKIN_HTTP_ENDPOINT)
	if err != nil {
		log.Fatalf(&quot;zipkin.NewHTTPCollector err: %v&quot;, err)
	}

	recorder := zipkin.NewRecorder(collector, true, ZIPKIN_RECORDER_HOST_PORT, SERVICE_NAME)

	tracer, err := zipkin.NewTracer(
		recorder, zipkin.ClientServerSameSpan(false),
	)
	if err != nil {
		log.Fatalf(&quot;zipkin.NewTracer err: %v&quot;, err)
	}

	tlsServer := gtls.Server{
		CaFile:   &quot;../../conf/ca.pem&quot;,
		CertFile: &quot;../../conf/server/server.pem&quot;,
		KeyFile:  &quot;../../conf/server/server.key&quot;,
	}
	c, err := tlsServer.GetCredentialsByCA()
	if err != nil {
		log.Fatalf(&quot;GetTLSCredentialsByCA err: %v&quot;, err)
	}

	opts := []grpc.ServerOption{
		grpc.Creds(c),
		grpc_middleware.WithUnaryServerChain(
			otgrpc.OpenTracingServerInterceptor(tracer, otgrpc.LogPayloads()),
		),
	}
    ...
}
</code></pre><ul>
<li>zipkin.NewHTTPCollector：创建一个 Zipkin HTTP 后端收集器</li>
<li>zipkin.NewRecorder：创建一个基于 Zipkin 收集器的记录器</li>
<li>zipkin.NewTracer：创建一个 OpenTracing 跟踪器（兼容 Zipkin Tracer）</li>
<li>otgrpc.OpenTracingClientInterceptor：返回 grpc.UnaryServerInterceptor，不同点在于该拦截器会在 gRPC Metadata 中查找 OpenTracing SpanContext。如果找到则为该服务的 Span Context 的子节点</li>
<li>otgrpc.LogPayloads：设置并返回 Option。作用是让 OpenTracing 在双向方向上记录应用程序的有效载荷（payload）</li>
</ul>
<p>总的来讲，就是初始化 Zipkin，其又包含收集器、记录器、跟踪器。再利用拦截器在 Server 端实现 SpanContext、Payload 的双向读取和管理</p>
<h4 id="client">Client</h4>
<pre><code>func main() {
	// the same as zipkin server
	// ...
	conn, err := grpc.Dial(&quot;:&quot;+PORT, grpc.WithTransportCredentials(c),
		grpc.WithUnaryInterceptor(
			otgrpc.OpenTracingClientInterceptor(tracer, otgrpc.LogPayloads()),
		))
	...
}
</code></pre><ul>
<li>otgrpc.OpenTracingClientInterceptor：返回 grpc.UnaryClientInterceptor。该拦截器的核心功能在于：</li>
</ul>
<p>（1）OpenTracing SpanContext 注入 gRPC Metadata</p>
<p>（2）查看 context.Context 中的上下文关系，若存在父级 Span 则创建一个 ChildOf 引用，得到一个子 Span</p>
<p>其他方面，与 Server 端是一致的，先初始化 Zipkin，再增加 Client 端特需的拦截器。就可以完成基础工作啦</p>
<h3 id="验证-1">验证</h3>
<p>启动 Server.go，执行 Client.go。查看 http://127.0.0.1:9411/zipkin/ 的示意图：</p>
<p><img src="https://image.eddycjy.com/35c586cc15b28496d5c227e03cde7e67.jpg" alt="image"></p>
<p><img src="https://image.eddycjy.com/8c17c36d87764237e75b4d7c4739fdf4.jpg" alt="image"></p>
<h2 id="复杂点">复杂点</h2>
<p><img src="https://image.eddycjy.com/d33c339e872ceab76c906e2da1a450c3.jpg" alt="image"></p>
<p><img src="https://image.eddycjy.com/dc3fc3ec49276d3b56c0c2d22e6a5ad4.jpg" alt="image"></p>
<p>来，自己实践一下</p>
<h2 id="总结">总结</h2>
<p>在多服务下的架构下，串行、并行、服务套服务是一个非常常见的情况，用常规的方案往往很难发现问题在哪里（成本太大）。而这种情况就是<strong>分布式追踪系统</strong>大展拳脚的机会了</p>
<p>希望你通过本章节的介绍和学习，能够了解其概念和搭建且应用一个追踪系统。</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-grpc-example">go-grpc-example</a></li>
</ul>
<h3 id="资料">资料</h3>
<ul>
<li><a href="https://opentracing.io/">opentracing</a></li>
<li><a href="https://zipkin.io">zipkin</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载九」gRPC Deadlines</title>
			<link>https://eddycjy.com/posts/go/grpc/2018-10-16-deadlines/</link>
			<pubDate>Tue, 16 Oct 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc/2018-10-16-deadlines/</guid>
			<description>前言 在前面的章节中，已经介绍了 gRPC 的基本用法。那你想想，让它这么裸跑真的没问题吗？
那么，肯定是有问题了。今天将介绍 gRPC Deadlines 的用法，这一个必备技巧。内容也比较简单
Deadlines Deadlines 意指截止时间，在 gRPC 中强调 TL;DR（Too long, Don&amp;rsquo;t read）并建议始终设定截止日期，为什么呢？
为什么要设置 当未设置 Deadlines 时，将采用默认的 DEADLINE_EXCEEDED（这个时间非常大）
如果产生了阻塞等待，就会造成大量正在进行的请求都会被保留，并且所有请求都有可能达到最大超时
这会使服务面临资源耗尽的风险，例如内存，这会增加服务的延迟，或者在最坏的情况下可能导致整个进程崩溃
gRPC Client func main() { ... ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Duration(5 * time.Second))) defer cancel() client := pb.NewSearchServiceClient(conn) resp, err := client.Search(ctx, &amp;amp;pb.SearchRequest{ Request: &amp;quot;gRPC&amp;quot;, }) if err != nil { statusErr, ok := status.FromError(err) if ok { if statusErr.Code() == codes.DeadlineExceeded { log.Fatalln(&amp;quot;client.Search err: deadline&amp;quot;) } } log.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在前面的章节中，已经介绍了 gRPC 的基本用法。那你想想，让它这么裸跑真的没问题吗？</p>
<p>那么，肯定是有问题了。今天将介绍 gRPC Deadlines 的用法，这一个必备技巧。内容也比较简单</p>
<h2 id="deadlines">Deadlines</h2>
<p>Deadlines 意指截止时间，在 gRPC 中强调 TL;DR（Too long, Don&rsquo;t read）并建议<strong>始终设定截止日期</strong>，为什么呢？</p>
<h3 id="为什么要设置">为什么要设置</h3>
<p>当未设置 Deadlines 时，将采用默认的 DEADLINE_EXCEEDED（这个时间非常大）</p>
<p>如果产生了阻塞等待，就会造成大量正在进行的请求都会被保留，并且所有请求都有可能达到最大超时</p>
<p>这会使服务面临资源耗尽的风险，例如内存，这会增加服务的延迟，或者在最坏的情况下可能导致整个进程崩溃</p>
<h2 id="grpc">gRPC</h2>
<h3 id="client">Client</h3>
<pre><code>func main() {
    ...
	ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Duration(5 * time.Second)))
	defer cancel()

	client := pb.NewSearchServiceClient(conn)
	resp, err := client.Search(ctx, &amp;pb.SearchRequest{
		Request: &quot;gRPC&quot;,
	})
	if err != nil {
		statusErr, ok := status.FromError(err)
		if ok {
			if statusErr.Code() == codes.DeadlineExceeded {
				log.Fatalln(&quot;client.Search err: deadline&quot;)
			}
		}

		log.Fatalf(&quot;client.Search err: %v&quot;, err)
	}

	log.Printf(&quot;resp: %s&quot;, resp.GetResponse())
}
</code></pre><ul>
<li>context.WithDeadline：会返回最终上下文截止时间。第一个形参为父上下文，第二个形参为调整的截止时间。若父级时间早于子级时间，则以父级时间为准，否则以子级时间为最终截止时间</li>
</ul>
<pre><code>func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {
	if cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) {
		// The current deadline is already sooner than the new one.
		return WithCancel(parent)
	}
	c := &amp;timerCtx{
		cancelCtx: newCancelCtx(parent),
		deadline:  d,
	}
	propagateCancel(parent, c)
	dur := time.Until(d)
	if dur &lt;= 0 {
		c.cancel(true, DeadlineExceeded) // deadline has already passed
		return c, func() { c.cancel(true, Canceled) }
	}
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.err == nil {
		c.timer = time.AfterFunc(dur, func() {
			c.cancel(true, DeadlineExceeded)
		})
	}
	return c, func() { c.cancel(true, Canceled) }
}
</code></pre><ul>
<li>context.WithTimeout：很常见的另外一个方法，是便捷操作。实际上是对于 WithDeadline 的封装</li>
</ul>
<pre><code>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
	return WithDeadline(parent, time.Now().Add(timeout))
}
</code></pre><ul>
<li>status.FromError：返回 GRPCStatus 的具体错误码，若为非法，则直接返回 <code>codes.Unknown</code></li>
</ul>
<h3 id="server">Server</h3>
<pre><code>type SearchService struct{}

func (s *SearchService) Search(ctx context.Context, r *pb.SearchRequest) (*pb.SearchResponse, error) {
	for i := 0; i &lt; 5; i++  {
		if ctx.Err() == context.Canceled {
			return nil, status.Errorf(codes.Canceled, &quot;SearchService.Search canceled&quot;)
		}

		time.Sleep(1 * time.Second)
	}

	return &amp;pb.SearchResponse{Response: r.GetRequest() + &quot; Server&quot;}, nil
}

func main() {
	...
}
</code></pre><p>而在 Server 端，由于 Client 已经设置了截止时间。Server 势必要去检测它</p>
<p>否则如果 Client 已经结束掉了，Server 还傻傻的在那执行，这对资源是一种极大的浪费</p>
<p>因此在这里需要用 <code>ctx.Err() == context.Canceled</code> 进行判断，为了模拟场景我们加了循环和睡眠 🤔</p>
<h3 id="验证">验证</h3>
<p>重新启动 server.go 和 client.go，得到结果：</p>
<pre><code>$ go run client.go
2018/10/06 17:45:55 client.Search err: deadline
exit status 1
</code></pre><h2 id="总结">总结</h2>
<p>本章节比较简单，你需要知道以下知识点：</p>
<ul>
<li>怎么设置 Deadlines</li>
<li>为什么要设置 Deadlines</li>
</ul>
<p>你要清楚地明白到，gRPC Deadlines 是很重要的，否则这小小的功能点就会要了你生产的命 🤫</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-grpc-example">go-grpc-example</a></li>
</ul>
<h3 id="资料">资料</h3>
<ul>
<li><a href="https://grpc.io/blog/deadlines">gRPC and Deadlines</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载八」对 RPC 方法做自定义认证</title>
			<link>https://eddycjy.com/posts/go/grpc/2018-10-14-per-rpc-credentials/</link>
			<pubDate>Sun, 14 Oct 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc/2018-10-14-per-rpc-credentials/</guid>
			<description>前言 在前面的章节中，我们介绍了两种（证书算一种）可全局认证的方法：
 TLS 证书认证 基于 CA 的 TLS 证书认证 Unary and Stream interceptor  而在实际需求中，常常会对某些模块的 RPC 方法做特殊认证或校验。今天将会讲解、实现这块的功能点
课前知识 type PerRPCCredentials interface { GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) RequireTransportSecurity() bool } 在 gRPC 中默认定义了 PerRPCCredentials，它就是本章节的主角，是 gRPC 默认提供用于自定义认证的接口，它的作用是将所需的安全认证信息添加到每个 RPC 方法的上下文中。其包含 2 个方法：
 GetRequestMetadata：获取当前请求认证所需的元数据（metadata） RequireTransportSecurity：是否需要基于 TLS 认证进行安全传输  目录结构 新建 simple_token_server/server.go 和 simple_token_client/client.go，目录结构如下：
go-grpc-example ├── client │ ├── simple_client │ ├── simple_http_client │ ├── simple_token_client │ └── stream_client ├── conf ├── pkg ├── proto ├── server │ ├── simple_http_server │ ├── simple_server │ ├── simple_token_server │ └── stream_server └── vendor gRPC Client package main import ( &amp;quot;context&amp;quot; &amp;quot;log&amp;quot; &amp;quot;google.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在前面的章节中，我们介绍了两种（证书算一种）可全局认证的方法：</p>
<ol>
<li><a href="https://github.com/EDDYCJY/blog/blob/master/grpc/grpc-tls.md">TLS 证书认证</a></li>
<li><a href="https://github.com/EDDYCJY/blog/blob/master/grpc/ca-tls.md">基于 CA 的 TLS 证书认证</a></li>
<li><a href="https://github.com/EDDYCJY/blog/blob/master/grpc/interceptor.md">Unary and Stream interceptor</a></li>
</ol>
<p>而在实际需求中，常常会对某些模块的 RPC 方法做特殊认证或校验。今天将会讲解、实现这块的功能点</p>
<h2 id="课前知识">课前知识</h2>
<pre><code>type PerRPCCredentials interface {
    GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
    RequireTransportSecurity() bool
}
</code></pre><p>在 gRPC 中默认定义了 PerRPCCredentials，它就是本章节的主角，是 gRPC 默认提供用于自定义认证的接口，它的作用是将所需的安全认证信息添加到每个 RPC 方法的上下文中。其包含 2 个方法：</p>
<ul>
<li>GetRequestMetadata：获取当前请求认证所需的元数据（metadata）</li>
<li>RequireTransportSecurity：是否需要基于 TLS 认证进行安全传输</li>
</ul>
<h2 id="目录结构">目录结构</h2>
<p>新建 simple_token_server/server.go 和 simple_token_client/client.go，目录结构如下：</p>
<pre><code>go-grpc-example
├── client
│   ├── simple_client
│   ├── simple_http_client
│   ├── simple_token_client
│   └── stream_client
├── conf
├── pkg
├── proto
├── server
│   ├── simple_http_server
│   ├── simple_server
│   ├── simple_token_server
│   └── stream_server
└── vendor
</code></pre><h2 id="grpc">gRPC</h2>
<h3 id="client">Client</h3>
<pre><code>package main

import (
	&quot;context&quot;
	&quot;log&quot;

	&quot;google.golang.org/grpc&quot;

	&quot;github.com/EDDYCJY/go-grpc-example/pkg/gtls&quot;
	pb &quot;github.com/EDDYCJY/go-grpc-example/proto&quot;
)

const PORT = &quot;9004&quot;

type Auth struct {
	AppKey    string
	AppSecret string
}

func (a *Auth) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
	return map[string]string{&quot;app_key&quot;: a.AppKey, &quot;app_secret&quot;: a.AppSecret}, nil
}

func (a *Auth) RequireTransportSecurity() bool {
	return true
}

func main() {
	tlsClient := gtls.Client{
		ServerName: &quot;go-grpc-example&quot;,
		CertFile:   &quot;../../conf/server/server.pem&quot;,
	}
	c, err := tlsClient.GetTLSCredentials()
	if err != nil {
		log.Fatalf(&quot;tlsClient.GetTLSCredentials err: %v&quot;, err)
	}

	auth := Auth{
		AppKey:    &quot;eddycjy&quot;,
		AppSecret: &quot;20181005&quot;,
	}
	conn, err := grpc.Dial(&quot;:&quot;+PORT, grpc.WithTransportCredentials(c), grpc.WithPerRPCCredentials(&amp;auth))
	...
}
</code></pre><p>在 Client 端，重点实现 <code>type PerRPCCredentials interface</code> 所需的方法，关注两点即可：</p>
<ul>
<li>struct Auth：GetRequestMetadata、RequireTransportSecurity</li>
<li>grpc.WithPerRPCCredentials</li>
</ul>
<h3 id="server">Server</h3>
<pre><code>package main

import (
	&quot;context&quot;
	&quot;log&quot;
	&quot;net&quot;

	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/codes&quot;
	&quot;google.golang.org/grpc/metadata&quot;
	&quot;google.golang.org/grpc/status&quot;

	&quot;github.com/EDDYCJY/go-grpc-example/pkg/gtls&quot;
	pb &quot;github.com/EDDYCJY/go-grpc-example/proto&quot;
)

type SearchService struct {
	auth *Auth
}

func (s *SearchService) Search(ctx context.Context, r *pb.SearchRequest) (*pb.SearchResponse, error) {
	if err := s.auth.Check(ctx); err != nil {
		return nil, err
	}
	return &amp;pb.SearchResponse{Response: r.GetRequest() + &quot; Token Server&quot;}, nil
}

const PORT = &quot;9004&quot;

func main() {
	...
}

type Auth struct {
	appKey    string
	appSecret string
}

func (a *Auth) Check(ctx context.Context) error {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return status.Errorf(codes.Unauthenticated, &quot;自定义认证 Token 失败&quot;)
	}

	var (
		appKey    string
		appSecret string
	)
	if value, ok := md[&quot;app_key&quot;]; ok {
		appKey = value[0]
	}
	if value, ok := md[&quot;app_secret&quot;]; ok {
		appSecret = value[0]
	}

	if appKey != a.GetAppKey() || appSecret != a.GetAppSecret() {
		return status.Errorf(codes.Unauthenticated, &quot;自定义认证 Token 无效&quot;)
	}

	return nil
}

func (a *Auth) GetAppKey() string {
	return &quot;eddycjy&quot;
}

func (a *Auth) GetAppSecret() string {
	return &quot;20181005&quot;
}
</code></pre><p>在 Server 端就更简单了，实际就是调用 <code>metadata.FromIncomingContext</code> 从上下文中获取 metadata，再在不同的 RPC 方法中进行认证检查</p>
<h3 id="验证">验证</h3>
<p>重新启动 server.go 和 client.go，得到以下结果：</p>
<pre><code>$ go run client.go
2018/10/05 20:59:58 resp: gRPC Token Server
</code></pre><p>修改 client.go 的值，制造两者不一致，得到无效结果：</p>
<pre><code>$ go run client.go
2018/10/05 21:00:05 client.Search err: rpc error: code = Unauthenticated desc = invalid token
exit status 1
</code></pre><h3 id="一个个加太麻烦">一个个加太麻烦</h3>
<p>我相信你肯定会问一个个加，也太麻烦了吧？有这个想法的你，应当把 <code>type PerRPCCredentials interface</code> 做成一个拦截器（interceptor）</p>
<h2 id="总结">总结</h2>
<p>本章节比较简单，主要是针对 RPC 方法的自定义认证进行了介绍，如果是想做全局的，建议是举一反三从拦截器下手哦。</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-grpc-example">go-grpc-example</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载七」让你的服务同时提供 HTTP 接口</title>
			<link>https://eddycjy.com/posts/go/grpc/2018-10-12-grpc-http/</link>
			<pubDate>Fri, 12 Oct 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc/2018-10-12-grpc-http/</guid>
			<description>前言   接口需要提供给其他业务组访问，但是 RPC 协议不同无法内调，对方问能否走 HTTP 接口，怎么办？
  微信（公众号、小程序）等第三方回调接口只支持 HTTP 接口，怎么办
  我相信你在实际工作中都会遇到如上问题，在 gRPC 中都是有解决方案的，本章节将会进行介绍 🤔
为什么可以同时提供 HTTP 接口 关键一点，gRPC 的协议是基于 HTTP/2 的，因此应用程序能够在单个 TCP 端口上提供 HTTP/1.1 和 gRPC 接口服务（两种不同的流量）
怎么同时提供 HTTP 接口 检测协议 if r.ProtoMajor == 2 &amp;amp;&amp;amp; strings.Contains(r.Header.Get(&amp;quot;Content-Type&amp;quot;), &amp;quot;application/grpc&amp;quot;) { server.ServeHTTP(w, r) } else { mux.ServeHTTP(w, r) } 流程  检测请求协议是否为 HTTP/2 判断 Content-Type 是否为 application/grpc（gRPC 的默认标识位） 根据协议的不同转发到不同的服务处理  gRPC TLS 在前面的章节，为了便于展示因此没有简单封装
在本节需复用代码，重新封装了，可详见：go-grpc-example
目录结构 新建 simple_http_client、simple_http_server 目录，目录结构如下：</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<ul>
<li>
<p>接口需要提供给其他业务组访问，但是 RPC 协议不同无法内调，对方问能否走 HTTP 接口，怎么办？</p>
</li>
<li>
<p>微信（公众号、小程序）等第三方回调接口只支持 HTTP 接口，怎么办</p>
</li>
</ul>
<p>我相信你在实际工作中都会遇到如上问题，在 gRPC 中都是有解决方案的，本章节将会进行介绍 🤔</p>
<h2 id="为什么可以同时提供-http-接口">为什么可以同时提供 HTTP 接口</h2>
<p>关键一点，gRPC 的协议是基于 HTTP/2 的，因此应用程序能够在单个 TCP 端口上提供 HTTP/1.1 和 gRPC 接口服务（两种不同的流量）</p>
<h2 id="怎么同时提供-http-接口">怎么同时提供 HTTP 接口</h2>
<h3 id="检测协议">检测协议</h3>
<pre><code>if r.ProtoMajor == 2 &amp;&amp; strings.Contains(r.Header.Get(&quot;Content-Type&quot;), &quot;application/grpc&quot;) {
    server.ServeHTTP(w, r)
} else {
    mux.ServeHTTP(w, r)
}
</code></pre><h3 id="流程">流程</h3>
<ol>
<li>检测请求协议是否为 HTTP/2</li>
<li>判断 Content-Type 是否为 application/grpc（gRPC 的默认标识位）</li>
<li>根据协议的不同转发到不同的服务处理</li>
</ol>
<h2 id="grpc">gRPC</h2>
<h3 id="tls">TLS</h3>
<p>在前面的章节，为了便于展示因此没有简单封装</p>
<p>在本节需复用代码，重新封装了，可详见：<a href="https://github.com/EDDYCJY/go-grpc-example/tree/master/pkg/gtls">go-grpc-example</a></p>
<h3 id="目录结构">目录结构</h3>
<p>新建 simple_http_client、simple_http_server 目录，目录结构如下：</p>
<pre><code>go-grpc-example
├── client
│   ├── simple_client
│   ├── simple_http_client
│   └── stream_client
├── conf
├── pkg
│   └── gtls
├── proto
├── server
│   ├── simple_http_server
│   ├── simple_server
│   └── stream_server
</code></pre><h3 id="server">Server</h3>
<p>在 simple_http_server 目录下新建 server.go，写入文件内容：</p>
<pre><code>package main

import (
	&quot;context&quot;
	&quot;log&quot;
	&quot;net/http&quot;
	&quot;strings&quot;

	&quot;github.com/EDDYCJY/go-grpc-example/pkg/gtls&quot;
	pb &quot;github.com/EDDYCJY/go-grpc-example/proto&quot;

	&quot;google.golang.org/grpc&quot;
)

type SearchService struct{}

func (s *SearchService) Search(ctx context.Context, r *pb.SearchRequest) (*pb.SearchResponse, error) {
	return &amp;pb.SearchResponse{Response: r.GetRequest() + &quot; HTTP Server&quot;}, nil
}

const PORT = &quot;9003&quot;

func main() {
	certFile := &quot;../../conf/server/server.pem&quot;
	keyFile := &quot;../../conf/server/server.key&quot;
	tlsServer := gtls.Server{
		CertFile: certFile,
		KeyFile:  keyFile,
	}

	c, err := tlsServer.GetTLSCredentials()
	if err != nil {
		log.Fatalf(&quot;tlsServer.GetTLSCredentials err: %v&quot;, err)
	}

	mux := GetHTTPServeMux()

	server := grpc.NewServer(grpc.Creds(c))
	pb.RegisterSearchServiceServer(server, &amp;SearchService{})

	http.ListenAndServeTLS(&quot;:&quot;+PORT,
		certFile,
		keyFile,
		http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.ProtoMajor == 2 &amp;&amp; strings.Contains(r.Header.Get(&quot;Content-Type&quot;), &quot;application/grpc&quot;) {
				server.ServeHTTP(w, r)
			} else {
				mux.ServeHTTP(w, r)
			}

			return
		}),
	)
}

func GetHTTPServeMux() *http.ServeMux {
	mux := http.NewServeMux()
	mux.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte(&quot;eddycjy: go-grpc-example&quot;))
	})

	return mux
}
</code></pre><ul>
<li>http.NewServeMux：创建一个新的 ServeMux，ServeMux 本质上是一个路由表。它默认实现了 ServeHTTP，因此返回 Handler 后可直接通过 HandleFunc 注册 pattern 和处理逻辑的方法</li>
<li>http.ListenAndServeTLS：可简单的理解为提供监听 HTTPS 服务的方法，重点的协议判断转发，也在这里面</li>
</ul>
<p>其实，你理解后就会觉得很简单，核心步骤：判断 -&gt; 转发 -&gt; 响应。我们改变了前两步的默认逻辑，仅此而已</p>
<h3 id="client">Client</h3>
<p>在 simple_http_server 目录下新建 client.go，写入文件内容：</p>
<pre><code>package main

import (
	&quot;context&quot;
	&quot;log&quot;

	&quot;google.golang.org/grpc&quot;

	&quot;github.com/EDDYCJY/go-grpc-example/pkg/gtls&quot;
	pb &quot;github.com/EDDYCJY/go-grpc-example/proto&quot;
)

const PORT = &quot;9003&quot;

func main() {
	tlsClient := gtls.Client{
		ServerName: &quot;go-grpc-example&quot;,
		CertFile:   &quot;../../conf/server/server.pem&quot;,
	}
	c, err := tlsClient.GetTLSCredentials()
	if err != nil {
		log.Fatalf(&quot;tlsClient.GetTLSCredentials err: %v&quot;, err)
	}

	conn, err := grpc.Dial(&quot;:&quot;+PORT, grpc.WithTransportCredentials(c))
	if err != nil {
		log.Fatalf(&quot;grpc.Dial err: %v&quot;, err)
	}
	defer conn.Close()

	client := pb.NewSearchServiceClient(conn)
	resp, err := client.Search(context.Background(), &amp;pb.SearchRequest{
		Request: &quot;gRPC&quot;,
	})
	if err != nil {
		log.Fatalf(&quot;client.Search err: %v&quot;, err)
	}

	log.Printf(&quot;resp: %s&quot;, resp.GetResponse())
}
</code></pre><h2 id="验证">验证</h2>
<h3 id="grpc-client">gRPC Client</h3>
<pre><code>$ go run client.go 
2018/10/04 14:56:56 resp: gRPC HTTP Server
</code></pre><h3 id="http11-访问">HTTP/1.1 访问</h3>
<p><img src="https://image.eddycjy.com/1d92cb9e949e32eef7f8a64a6a77deb9.jpg" alt="image"></p>
<h2 id="总结">总结</h2>
<p>通过本章节，表面上完成了同端口提供双服务的功能，但实际上，应该是加深了 HTTP/2 的理解和使用，这才是本质</p>
<h2 id="拓展">拓展</h2>
<p>如果你有一个需求，是要<strong>同时提供</strong> RPC 和 RESTful JSON API 两种接口的，不要犹豫，点进去：<a href="https://segmentfault.com/a/1190000013339403">gRPC + gRPC Gateway 实践</a></p>
<h2 id="问题">问题</h2>
<p>你以为这个方案就万能了吗，不。Envoy Proxy 的支持就不完美，无法同时监听一个端口的两种流量 😤</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-grpc-example">go-grpc-example</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载六」Unary and Stream interceptor</title>
			<link>https://eddycjy.com/posts/go/grpc/2018-10-10-interceptor/</link>
			<pubDate>Wed, 10 Oct 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc/2018-10-10-interceptor/</guid>
			<description>前言 我想在每个 RPC 方法的前或后做某些事情，怎么做？
本章节将要介绍的拦截器（interceptor），就能帮你在合适的地方实现这些功能。
有几种方法 在 gRPC 中，大类可分为两种 RPC 方法，与拦截器的对应关系是：
 普通方法：一元拦截器（grpc.UnaryInterceptor） 流方法：流拦截器（grpc.StreamInterceptor）  看一看 grpc.UnaryInterceptor func UnaryInterceptor(i UnaryServerInterceptor) ServerOption { return func(o *options) { if o.unaryInt != nil { panic(&amp;quot;The unary server interceptor was already set and may not be reset.&amp;quot;) } o.unaryInt = i } } 函数原型：
type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error) 通过查看源码可得知，要完成一个拦截器需要实现 UnaryServerInterceptor 方法。形参如下：
 ctx context.Context：请求上下文 req interface{}：RPC 方法的请求参数 info *UnaryServerInfo：RPC 方法的所有信息 handler UnaryHandler：RPC 方法本身  grpc.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>我想在每个 RPC 方法的前或后做某些事情，怎么做？</p>
<p>本章节将要介绍的拦截器（interceptor），就能帮你在合适的地方实现这些功能。</p>
<h2 id="有几种方法">有几种方法</h2>
<p>在 gRPC 中，大类可分为两种 RPC 方法，与拦截器的对应关系是：</p>
<ul>
<li>普通方法：一元拦截器（grpc.UnaryInterceptor）</li>
<li>流方法：流拦截器（grpc.StreamInterceptor）</li>
</ul>
<h2 id="看一看">看一看</h2>
<h3 id="grpcunaryinterceptor">grpc.UnaryInterceptor</h3>
<pre><code>func UnaryInterceptor(i UnaryServerInterceptor) ServerOption {
	return func(o *options) {
		if o.unaryInt != nil {
			panic(&quot;The unary server interceptor was already set and may not be reset.&quot;)
		}
		o.unaryInt = i
	}
}
</code></pre><p>函数原型：</p>
<pre><code>type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)
</code></pre><p>通过查看源码可得知，要完成一个拦截器需要实现 <code>UnaryServerInterceptor</code> 方法。形参如下：</p>
<ul>
<li>ctx context.Context：请求上下文</li>
<li>req interface{}：RPC 方法的请求参数</li>
<li>info *UnaryServerInfo：RPC 方法的所有信息</li>
<li>handler UnaryHandler：RPC 方法本身</li>
</ul>
<h3 id="grpcstreaminterceptor">grpc.StreamInterceptor</h3>
<pre><code>func StreamInterceptor(i StreamServerInterceptor) ServerOption
</code></pre><p>函数原型：</p>
<pre><code>type StreamServerInterceptor func(srv interface{}, ss ServerStream, info *StreamServerInfo, handler StreamHandler) error
</code></pre><p>StreamServerInterceptor 与 UnaryServerInterceptor 形参的意义是一样，不再赘述</p>
<h3 id="如何实现多个拦截器">如何实现多个拦截器</h3>
<p>另外，可以发现 gRPC 本身居然只能设置一个拦截器，难道所有的逻辑都只能写在一起？</p>
<p>关于这一点，你可以放心。采用开源项目 <a href="https://github.com/grpc-ecosystem/go-grpc-middleware">go-grpc-middleware</a> 就可以解决这个问题，本章也会使用它。</p>
<pre><code>import &quot;github.com/grpc-ecosystem/go-grpc-middleware&quot;

myServer := grpc.NewServer(
    grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
        ...
    )),
    grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
       ...
    )),
)
</code></pre><h2 id="grpc">gRPC</h2>
<p>从本节开始编写 gRPC interceptor 的代码，我们会将实现以下拦截器：</p>
<ul>
<li>logging：RPC 方法的入参出参的日志输出</li>
<li>recover：RPC 方法的异常保护和日志输出</li>
</ul>
<h3 id="实现-interceptor">实现 interceptor</h3>
<h4 id="logging">logging</h4>
<pre><code>func LoggingInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
	log.Printf(&quot;gRPC method: %s, %v&quot;, info.FullMethod, req)
	resp, err := handler(ctx, req)
	log.Printf(&quot;gRPC method: %s, %v&quot;, info.FullMethod, resp)
	return resp, err
}
</code></pre><h4 id="recover">recover</h4>
<pre><code>func RecoveryInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
	defer func() {
		if e := recover(); e != nil {
			debug.PrintStack()
			err = status.Errorf(codes.Internal, &quot;Panic err: %v&quot;, e)
		}
	}()

	return handler(ctx, req)
}
</code></pre><h3 id="server">Server</h3>
<pre><code>import (
	&quot;context&quot;
	&quot;crypto/tls&quot;
	&quot;crypto/x509&quot;
	&quot;errors&quot;
	&quot;io/ioutil&quot;
	&quot;log&quot;
	&quot;net&quot;
	&quot;runtime/debug&quot;

	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/credentials&quot;
	&quot;google.golang.org/grpc/status&quot;
	&quot;google.golang.org/grpc/codes&quot;
	&quot;github.com/grpc-ecosystem/go-grpc-middleware&quot;

	pb &quot;github.com/EDDYCJY/go-grpc-example/proto&quot;
)

...

func main() {
	c, err := GetTLSCredentialsByCA()
	if err != nil {
		log.Fatalf(&quot;GetTLSCredentialsByCA err: %v&quot;, err)
	}

	opts := []grpc.ServerOption{
		grpc.Creds(c),
		grpc_middleware.WithUnaryServerChain(
			RecoveryInterceptor,
			LoggingInterceptor,
		),
	}

	server := grpc.NewServer(opts...)
	pb.RegisterSearchServiceServer(server, &amp;SearchService{})

	lis, err := net.Listen(&quot;tcp&quot;, &quot;:&quot;+PORT)
	if err != nil {
		log.Fatalf(&quot;net.Listen err: %v&quot;, err)
	}

	server.Serve(lis)
}
</code></pre><h2 id="验证">验证</h2>
<h3 id="logging-1">logging</h3>
<p>启动 simple_server/server.go，执行 simple_client/client.go 发起请求，得到结果：</p>
<pre><code>$ go run server.go
2018/10/02 13:46:35 gRPC method: /proto.SearchService/Search, request:&quot;gRPC&quot; 
2018/10/02 13:46:35 gRPC method: /proto.SearchService/Search, response:&quot;gRPC Server&quot;
</code></pre><h3 id="recover-1">recover</h3>
<p>在 RPC 方法中人为地制造运行时错误，再重复启动 server/client.go，得到结果：</p>
<h4 id="client">client</h4>
<pre><code>$ go run client.go
2018/10/02 13:19:03 client.Search err: rpc error: code = Internal desc = Panic err: assignment to entry in nil map
exit status 1
</code></pre><h4 id="server-1">server</h4>
<pre><code>$ go run server.go
goroutine 23 [running]:
runtime/debug.Stack(0xc420223588, 0x1033da9, 0xc420001980)
	/usr/local/Cellar/go/1.10.1/libexec/src/runtime/debug/stack.go:24 +0xa7
runtime/debug.PrintStack()
	/usr/local/Cellar/go/1.10.1/libexec/src/runtime/debug/stack.go:16 +0x22
main.RecoveryInterceptor.func1(0xc420223a10)
...
</code></pre><p>检查服务是否仍然运行，即可知道 Recovery 是否成功生效</p>
<h2 id="总结">总结</h2>
<p>通过本章节，你可以学会最常见的拦截器使用方法。接下来其它“新”需求只要举一反三即可。</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-grpc-example">go-grpc-example</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载五」基于 CA 的 TLS 证书认证</title>
			<link>https://eddycjy.com/posts/go/grpc/2018-10-08-ca-tls/</link>
			<pubDate>Mon, 08 Oct 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc/2018-10-08-ca-tls/</guid>
			<description>前言 在上一章节中，我们提出了一个问题。就是如何保证证书的可靠性和有效性？你如何确定你 Server、Client 的证书是对的呢？
CA 为了保证证书的可靠性和有效性，在这里可引入 CA 颁发的根证书的概念。其遵守 X.509 标准
根证书 根证书（root certificate）是属于根证书颁发机构（CA）的公钥证书。我们可以通过验证 CA 的签名从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书（客户端、服务端）
它包含的文件如下：
 公钥 密钥  生成 Key openssl genrsa -out ca.key 2048 生成密钥 openssl req -new -x509 -days 7200 -key ca.key -out ca.pem 填写信息 Country Name (2 letter code) []: State or Province Name (full name) []: Locality Name (eg, city) []: Organization Name (eg, company) []: Organizational Unit Name (eg, section) []: Common Name (eg, fully qualified host name) []:go-grpc-example Email Address []: Server 生成 CSR openssl req -new -key server.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在上一章节中，我们提出了一个问题。就是如何保证证书的可靠性和有效性？你如何确定你 Server、Client 的证书是对的呢？</p>
<h2 id="ca">CA</h2>
<p>为了保证证书的可靠性和有效性，在这里可引入 CA 颁发的根证书的概念。其遵守 X.509 标准</p>
<h3 id="根证书">根证书</h3>
<p>根证书（root certificate）是属于根证书颁发机构（CA）的公钥证书。我们可以通过验证 CA 的签名从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书（客户端、服务端）</p>
<p>它包含的文件如下：</p>
<ul>
<li>公钥</li>
<li>密钥</li>
</ul>
<h3 id="生成-key">生成 Key</h3>
<pre><code>openssl genrsa -out ca.key 2048
</code></pre><h3 id="生成密钥">生成密钥</h3>
<pre><code>openssl req -new -x509 -days 7200 -key ca.key -out ca.pem
</code></pre><h4 id="填写信息">填写信息</h4>
<pre><code>Country Name (2 letter code) []:
State or Province Name (full name) []:
Locality Name (eg, city) []:
Organization Name (eg, company) []:
Organizational Unit Name (eg, section) []:
Common Name (eg, fully qualified host name) []:go-grpc-example
Email Address []:
</code></pre><h3 id="server">Server</h3>
<h4 id="生成-csr">生成 CSR</h4>
<pre><code>openssl req -new -key server.key -out server.csr
</code></pre><h5 id="填写信息-1">填写信息</h5>
<pre><code>Country Name (2 letter code) []:
State or Province Name (full name) []:
Locality Name (eg, city) []:
Organization Name (eg, company) []:
Organizational Unit Name (eg, section) []:
Common Name (eg, fully qualified host name) []:go-grpc-example
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
</code></pre><p>CSR 是 Cerificate Signing Request 的英文缩写，为证书请求文件。主要作用是 CA 会利用 CSR 文件进行签名使得攻击者无法伪装或篡改原有证书</p>
<h4 id="基于-ca-签发">基于 CA 签发</h4>
<pre><code>openssl x509 -req -sha256 -CA ca.pem -CAkey ca.key -CAcreateserial -days 3650 -in server.csr -out server.pem
</code></pre><h3 id="client">Client</h3>
<h3 id="生成-key-1">生成 Key</h3>
<pre><code>openssl ecparam -genkey -name secp384r1 -out client.key
</code></pre><h3 id="生成-csr-1">生成 CSR</h3>
<pre><code>openssl req -new -key client.key -out client.csr
</code></pre><h4 id="基于-ca-签发-1">基于 CA 签发</h4>
<pre><code>openssl x509 -req -sha256 -CA ca.pem -CAkey ca.key -CAcreateserial -days 3650 -in client.csr -out client.pem
</code></pre><h3 id="整理目录">整理目录</h3>
<p>至此我们生成了一堆文件，请按照以下目录结构存放：</p>
<pre><code>$ tree conf 
conf
├── ca.key
├── ca.pem
├── ca.srl
├── client
│   ├── client.csr
│   ├── client.key
│   └── client.pem
└── server
    ├── server.csr
    ├── server.key
    └── server.pem
</code></pre><p>另外有一些文件是不应该出现在仓库内，应当保密或删除的。但为了真实演示所以保留着（敲黑板）</p>
<h2 id="grpc">gRPC</h2>
<p>接下来将正式开始针对 gRPC 进行编码，改造上一章节的代码。目标是基于 CA 进行 TLS 认证 🤫</p>
<h3 id="server-1">Server</h3>
<pre><code>package main

import (
	&quot;context&quot;
	&quot;log&quot;
	&quot;net&quot;
	&quot;crypto/tls&quot;
	&quot;crypto/x509&quot;
	&quot;io/ioutil&quot;

	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/credentials&quot;

	pb &quot;github.com/EDDYCJY/go-grpc-example/proto&quot;
)

...

const PORT = &quot;9001&quot;

func main() {
	cert, err := tls.LoadX509KeyPair(&quot;../../conf/server/server.pem&quot;, &quot;../../conf/server/server.key&quot;)
	if err != nil {
		log.Fatalf(&quot;tls.LoadX509KeyPair err: %v&quot;, err)
	}

	certPool := x509.NewCertPool()
	ca, err := ioutil.ReadFile(&quot;../../conf/ca.pem&quot;)
	if err != nil {
		log.Fatalf(&quot;ioutil.ReadFile err: %v&quot;, err)
	}

	if ok := certPool.AppendCertsFromPEM(ca); !ok {
		log.Fatalf(&quot;certPool.AppendCertsFromPEM err&quot;)
	}

	c := credentials.NewTLS(&amp;tls.Config{
		Certificates: []tls.Certificate{cert},
		ClientAuth:   tls.RequireAndVerifyClientCert,
		ClientCAs:    certPool,
	})

	server := grpc.NewServer(grpc.Creds(c))
	pb.RegisterSearchServiceServer(server, &amp;SearchService{})

	lis, err := net.Listen(&quot;tcp&quot;, &quot;:&quot;+PORT)
	if err != nil {
		log.Fatalf(&quot;net.Listen err: %v&quot;, err)
	}

	server.Serve(lis)
}
</code></pre><ul>
<li>tls.LoadX509KeyPair()：从证书相关文件中<strong>读取</strong>和<strong>解析</strong>信息，得到证书公钥、密钥对</li>
</ul>
<pre><code>func LoadX509KeyPair(certFile, keyFile string) (Certificate, error) {
	certPEMBlock, err := ioutil.ReadFile(certFile)
	if err != nil {
		return Certificate{}, err
	}
	keyPEMBlock, err := ioutil.ReadFile(keyFile)
	if err != nil {
		return Certificate{}, err
	}
	return X509KeyPair(certPEMBlock, keyPEMBlock)
}
</code></pre><ul>
<li>x509.NewCertPool()：创建一个新的、空的 CertPool</li>
<li>certPool.AppendCertsFromPEM()：尝试解析所传入的 PEM 编码的证书。如果解析成功会将其加到 CertPool 中，便于后面的使用</li>
<li>credentials.NewTLS：构建基于 TLS 的 TransportCredentials 选项</li>
<li>tls.Config：Config 结构用于配置 TLS 客户端或服务器</li>
</ul>
<p>在 Server，共使用了三个 Config 配置项：</p>
<p>（1）Certificates：设置证书链，允许包含一个或多个</p>
<p>（2）ClientAuth：要求必须校验客户端的证书。可以根据实际情况选用以下参数：</p>
<pre><code>const (
	NoClientCert ClientAuthType = iota
	RequestClientCert
	RequireAnyClientCert
	VerifyClientCertIfGiven
	RequireAndVerifyClientCert
)
</code></pre><p>（3）ClientCAs：设置根证书的集合，校验方式使用 ClientAuth 中设定的模式</p>
<h3 id="client-1">Client</h3>
<pre><code>package main

import (
	&quot;context&quot;
	&quot;crypto/tls&quot;
	&quot;crypto/x509&quot;
	&quot;io/ioutil&quot;
	&quot;log&quot;

	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/credentials&quot;

	pb &quot;github.com/EDDYCJY/go-grpc-example/proto&quot;
)

const PORT = &quot;9001&quot;

func main() {
	cert, err := tls.LoadX509KeyPair(&quot;../../conf/client/client.pem&quot;, &quot;../../conf/client/client.key&quot;)
	if err != nil {
		log.Fatalf(&quot;tls.LoadX509KeyPair err: %v&quot;, err)
	}

	certPool := x509.NewCertPool()
	ca, err := ioutil.ReadFile(&quot;../../conf/ca.pem&quot;)
	if err != nil {
		log.Fatalf(&quot;ioutil.ReadFile err: %v&quot;, err)
	}

	if ok := certPool.AppendCertsFromPEM(ca); !ok {
		log.Fatalf(&quot;certPool.AppendCertsFromPEM err&quot;)
	}

	c := credentials.NewTLS(&amp;tls.Config{
		Certificates: []tls.Certificate{cert},
		ServerName:   &quot;go-grpc-example&quot;,
		RootCAs:      certPool,
	})

	conn, err := grpc.Dial(&quot;:&quot;+PORT, grpc.WithTransportCredentials(c))
	if err != nil {
		log.Fatalf(&quot;grpc.Dial err: %v&quot;, err)
	}
	defer conn.Close()

	client := pb.NewSearchServiceClient(conn)
	resp, err := client.Search(context.Background(), &amp;pb.SearchRequest{
		Request: &quot;gRPC&quot;,
	})
	if err != nil {
		log.Fatalf(&quot;client.Search err: %v&quot;, err)
	}

	log.Printf(&quot;resp: %s&quot;, resp.GetResponse())
}
</code></pre><p>在 Client 中绝大部分与 Server 一致，不同点的地方是，在 Client 请求 Server 端时，Client 端会使用根证书和 ServerName 去对 Server 端进行校验</p>
<p>简单流程大致如下：</p>
<ol>
<li>Client 通过请求得到 Server 端的证书</li>
<li>使用 CA 认证的根证书对 Server 端的证书进行可靠性、有效性等校验</li>
<li>校验 ServerName 是否可用、有效</li>
</ol>
<p>当然了，在设置了 <code>tls.RequireAndVerifyClientCert</code> 模式的情况下，Server 也会使用 CA 认证的根证书对 Client 端的证书进行可靠性、有效性等校验。也就是两边都会进行校验，极大的保证了安全性 👍</p>
<h3 id="验证">验证</h3>
<p>重新启动 server.go 和执行 client.go，查看响应结果是否正常</p>
<h2 id="总结">总结</h2>
<p>在本章节，我们使用 CA 颁发的根证书对客户端、服务端的证书进行了签发。进一步的提高了两者的通讯安全</p>
<p>这回是真的大功告成了！</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-grpc-example">go-grpc-example</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载四」TLS 证书认证</title>
			<link>https://eddycjy.com/posts/go/grpc/2018-10-07-grpc-tls/</link>
			<pubDate>Sun, 07 Oct 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc/2018-10-07-grpc-tls/</guid>
			<description>前言 在前面的章节里，我们介绍了 gRPC 的四种 API 使用方式。是不是很简单呢 😀
此时存在一个安全问题，先前的例子中 gRPC Client/Server 都是明文传输的，会不会有被窃听的风险呢？
从结论上来讲，是有的。在明文通讯的情况下，你的请求就是裸奔的，有可能被第三方恶意篡改或者伪造为“非法”的数据
抓个包 嗯，明文传输无误。这是有问题的，接下将改造我们的 gRPC，以便于解决这个问题 😤
证书生成 私钥 openssl ecparam -genkey -name secp384r1 -out server.key 自签公钥 openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650 填写信息 Country Name (2 letter code) []: State or Province Name (full name) []: Locality Name (eg, city) []: Organization Name (eg, company) []: Organizational Unit Name (eg, section) []: Common Name (eg, fully qualified host name) []:go-grpc-example Email Address []: 生成完毕 生成证书结束后，将证书相关文件放到 conf/ 下，目录结构：</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在前面的章节里，我们介绍了 gRPC 的四种 API 使用方式。是不是很简单呢 😀</p>
<p>此时存在一个安全问题，先前的例子中 gRPC Client/Server 都是明文传输的，会不会有被窃听的风险呢？</p>
<p>从结论上来讲，是有的。在明文通讯的情况下，你的请求就是裸奔的，有可能被第三方恶意篡改或者伪造为“非法”的数据</p>
<h2 id="抓个包">抓个包</h2>
<p><img src="https://image.eddycjy.com/15e68df2ba9aa7cace3e26e35c79f200.jpg" alt="image"></p>
<p><img src="https://image.eddycjy.com/ebebd3ea7d306ad2fcd311f1d8b46cc0.jpg" alt="image"></p>
<p>嗯，明文传输无误。这是有问题的，接下将改造我们的 gRPC，以便于解决这个问题 😤</p>
<h2 id="证书生成">证书生成</h2>
<h3 id="私钥">私钥</h3>
<pre><code>openssl ecparam -genkey -name secp384r1 -out server.key
</code></pre><h3 id="自签公钥">自签公钥</h3>
<pre><code>openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650
</code></pre><h4 id="填写信息">填写信息</h4>
<pre><code>Country Name (2 letter code) []:
State or Province Name (full name) []:
Locality Name (eg, city) []:
Organization Name (eg, company) []:
Organizational Unit Name (eg, section) []:
Common Name (eg, fully qualified host name) []:go-grpc-example
Email Address []:
</code></pre><h3 id="生成完毕">生成完毕</h3>
<p>生成证书结束后，将证书相关文件放到 conf/ 下，目录结构：</p>
<pre><code>$ tree go-grpc-example
go-grpc-example
├── client
├── conf
│   ├── server.key
│   └── server.pem
├── proto
└── server
    ├── simple_server
    └── stream_server
</code></pre><p>由于本文偏向 gRPC，详解可参见 <a href="https://segmentfault.com/a/1190000013408485#articleHeader3">《制作证书》</a>。后续番外可能会展开细节描述 👌</p>
<h2 id="为什么之前不需要证书">为什么之前不需要证书</h2>
<p>在 simple_server 中，为什么“啥事都没干”就能在不需要证书的情况下运行呢？</p>
<h3 id="server">Server</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>
</code></pre></div><p>在服务端显然没有传入任何 DialOptions</p>
<h3 id="client">Client</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">())</span>
</code></pre></div><p>在客户端留意到 <code>grpc.WithInsecure()</code> 方法</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithInsecure</span><span class="p">()</span> <span class="nx">DialOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">insecure</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>在方法内可以看到 <code>WithInsecure</code> 返回一个 <code>DialOption</code>，并且它最终会通过读取设置的值来禁用安全传输</p>
<p>那么它“最终”又是在哪里处理的呢，我们把视线移到 <code>grpc.Dial()</code> 方法内</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">DialOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">opts</span> <span class="p">{</span>
		<span class="nx">opt</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">)</span>
	<span class="p">}</span>
    <span class="o">...</span>

    <span class="k">if</span> <span class="p">!</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">insecure</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">TransportCredentials</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errNoTransportSecurity</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">TransportCredentials</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errCredentialsConflict</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">cd</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">PerRPCCredentials</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">cd</span><span class="p">.</span><span class="nf">RequireTransportSecurity</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errTransportCredentialsMissing</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>

	<span class="nx">creds</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">TransportCredentials</span>
	<span class="k">if</span> <span class="nx">creds</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">creds</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nx">ServerName</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">authority</span> <span class="p">=</span> <span class="nx">creds</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nx">ServerName</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">insecure</span> <span class="o">&amp;&amp;</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">authority</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">authority</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">authority</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Use endpoint from &#34;scheme://authority/endpoint&#34; as the default
</span><span class="c1"></span>		<span class="c1">// authority for ClientConn.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nx">authority</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Endpoint</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h2 id="grpc">gRPC</h2>
<p>接下来我们将正式开始编码，在 gRPC Client/Server 上实现 TLS 证书认证的支持 🤔</p>
<h3 id="tls-server">TLS Server</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net&#34;</span>

	<span class="s">&#34;google.golang.org/grpc&#34;</span>
	<span class="s">&#34;google.golang.org/grpc/credentials&#34;</span>

	<span class="nx">pb</span> <span class="s">&#34;github.com/EDDYCJY/go-grpc-example/proto&#34;</span>
<span class="p">)</span>

<span class="o">...</span>

<span class="kd">const</span> <span class="nx">PORT</span> <span class="p">=</span> <span class="s">&#34;9001&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">credentials</span><span class="p">.</span><span class="nf">NewServerTLSFromFile</span><span class="p">(</span><span class="s">&#34;../../conf/server.pem&#34;</span><span class="p">,</span> <span class="s">&#34;../../conf/server.key&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;credentials.NewServerTLSFromFile err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">server</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">(</span><span class="nx">grpc</span><span class="p">.</span><span class="nf">Creds</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
	<span class="nx">pb</span><span class="p">.</span><span class="nf">RegisterSearchServiceServer</span><span class="p">(</span><span class="nx">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">SearchService</span><span class="p">{})</span>

	<span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;net.Listen err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">server</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>credentials.NewServerTLSFromFile：根据服务端输入的证书文件和密钥构造 TLS 凭证</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewServerTLSFromFile</span><span class="p">(</span><span class="nx">certFile</span><span class="p">,</span> <span class="nx">keyFile</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">TransportCredentials</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cert</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tls</span><span class="p">.</span><span class="nf">LoadX509KeyPair</span><span class="p">(</span><span class="nx">certFile</span><span class="p">,</span> <span class="nx">keyFile</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">NewTLS</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Certificates</span><span class="p">:</span> <span class="p">[]</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Certificate</span><span class="p">{</span><span class="nx">cert</span><span class="p">}}),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>grpc.Creds()：返回一个 ServerOption，用于设置服务器连接的凭据。用于 <code>grpc.NewServer(opt ...ServerOption)</code> 为 gRPC Server 设置连接选项</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Creds</span><span class="p">(</span><span class="nx">c</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">TransportCredentials</span><span class="p">)</span> <span class="nx">ServerOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">creds</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>经过以上两个简单步骤，gRPC Server 就建立起需证书认证的服务啦 🤔</p>
<h3 id="tls-client">TLS Client</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;log&#34;</span>

	<span class="s">&#34;google.golang.org/grpc&#34;</span>
	<span class="s">&#34;google.golang.org/grpc/credentials&#34;</span>

	<span class="nx">pb</span> <span class="s">&#34;github.com/EDDYCJY/go-grpc-example/proto&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">PORT</span> <span class="p">=</span> <span class="s">&#34;9001&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">credentials</span><span class="p">.</span><span class="nf">NewClientTLSFromFile</span><span class="p">(</span><span class="s">&#34;../../conf/server.pem&#34;</span><span class="p">,</span> <span class="s">&#34;go-grpc-example&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;credentials.NewClientTLSFromFile err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc.Dial err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">client</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nf">NewSearchServiceClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">SearchRequest</span><span class="p">{</span>
		<span class="nx">Request</span><span class="p">:</span> <span class="s">&#34;gRPC&#34;</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;client.Search err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;resp: %s&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nf">GetResponse</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>credentials.NewClientTLSFromFile()：根据客户端输入的证书文件和密钥构造 TLS 凭证。serverNameOverride 为服务名称</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewClientTLSFromFile</span><span class="p">(</span><span class="nx">certFile</span><span class="p">,</span> <span class="nx">serverNameOverride</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">TransportCredentials</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">certFile</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">cp</span> <span class="o">:=</span> <span class="nx">x509</span><span class="p">.</span><span class="nf">NewCertPool</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">cp</span><span class="p">.</span><span class="nf">AppendCertsFromPEM</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;credentials: failed to append certificates&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">NewTLS</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">ServerName</span><span class="p">:</span> <span class="nx">serverNameOverride</span><span class="p">,</span> <span class="nx">RootCAs</span><span class="p">:</span> <span class="nx">cp</span><span class="p">}),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>grpc.WithTransportCredentials()：返回一个配置连接的 DialOption 选项。用于 <code>grpc.Dial(target string, opts ...DialOption)</code> 设置连接选项</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithTransportCredentials</span><span class="p">(</span><span class="nx">creds</span> <span class="nx">credentials</span><span class="p">.</span><span class="nx">TransportCredentials</span><span class="p">)</span> <span class="nx">DialOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">newFuncDialOption</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">dialOptions</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">o</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">TransportCredentials</span> <span class="p">=</span> <span class="nx">creds</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><h2 id="验证">验证</h2>
<h3 id="请求">请求</h3>
<p>重新启动 server.go 和执行 client.go，得到响应结果</p>
<pre><code>$ go run client.go
2018/09/30 20:00:21 resp: gRPC Server
</code></pre><h3 id="抓个包-1">抓个包</h3>
<p><img src="https://image.eddycjy.com/c8ad6edf1f7d084883b847b3eee29dd2.jpg" alt="image"></p>
<p>成功。</p>
<h2 id="总结">总结</h2>
<p>在本章节我们实现了 gRPC TLS Client/Servert，你以为大功告成了吗？我不 😤</p>
<h2 id="问题">问题</h2>
<p>你仔细再看看，Client 是基于 Server 端的证书和服务名称来建立请求的。这样的话，你就需要将 Server 的证书通过各种手段给到 Client 端，否则是无法完成这项任务的</p>
<p>问题也就来了，你无法保证你的“各种手段”是安全的，毕竟现在的网络环境是很危险的，万一被&hellip;</p>
<p>我们将在下一章节解决这个问题，保证其可靠性 🙂</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-grpc-example">go-grpc-example</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>log 标准库</title>
			<link>https://eddycjy.com/posts/go/pkg/2018-09-28-log/</link>
			<pubDate>Fri, 28 Sep 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/pkg/2018-09-28-log/</guid>
			<description>日志 输出 2018/09/28 20:03:08 EDDYCJY Blog... 构成 [日期]&amp;lt;空格&amp;gt;[时分秒]&amp;lt;空格&amp;gt;[内容]&amp;lt;\n&amp;gt;
源码剖析 Logger type Logger struct { mu sync.Mutex prefix string flag int out io.Writer buf []byte }  mu：互斥锁，用于确保原子的写入 prefix：每行需写入的日志前缀内容 flag：设置日志辅助信息（时间、文件名、行号）的写入。可选如下标识位：  const ( Ldate = 1 &amp;lt;&amp;lt; iota // value: 1 Ltime // value: 2 Lmicroseconds // value: 4 Llongfile // value: 8 Lshortfile // value: 16 LUTC // value: 32 LstdFlags = Ldate | Ltime // value: 3 )  Ldate：当地时区的格式化日期：2009/01/23 Ltime：当地时区的格式化时间：01:23:23 Lmicroseconds：在 Ltime 的基础上，增加微秒的时间数值显示 Llongfile：完整的文件名和行号：/a/b/c/d.</description>
			<content type="html"><![CDATA[<h2 id="日志">日志</h2>
<h3 id="输出">输出</h3>
<pre><code>2018/09/28 20:03:08 EDDYCJY Blog...
</code></pre><h3 id="构成">构成</h3>
<p>[日期]&lt;空格&gt;[时分秒]&lt;空格&gt;[内容]&lt;\n&gt;</p>
<h2 id="源码剖析">源码剖析</h2>
<h3 id="logger">Logger</h3>
<pre><code>type Logger struct {
	mu     sync.Mutex 
	prefix string
	flag   int
	out    io.Writer
	buf    []byte
}
</code></pre><ol>
<li>mu：互斥锁，用于确保原子的写入</li>
<li>prefix：每行需写入的日志前缀内容</li>
<li>flag：设置日志辅助信息（时间、文件名、行号）的写入。可选如下标识位：</li>
</ol>
<pre><code>const (
	Ldate         = 1 &lt;&lt; iota       // value: 1
	Ltime                           // value: 2
	Lmicroseconds                   // value: 4
	Llongfile                       // value: 8
	Lshortfile                      // value: 16
	LUTC                            // value: 32
	LstdFlags     = Ldate | Ltime   // value: 3
)
</code></pre><ul>
<li>Ldate：当地时区的格式化日期：2009/01/23</li>
<li>Ltime：当地时区的格式化时间：01:23:23</li>
<li>Lmicroseconds：在 Ltime 的基础上，增加微秒的时间数值显示</li>
<li>Llongfile：完整的文件名和行号：/a/b/c/d.go:23</li>
<li>Lshortfile：当前文件名和行号：d.go：23，会覆盖 Llongfile 标识</li>
<li>LUTC：如果设置 Ldate 或 Ltime，且设置 LUTC，则优先使用 UTC 时区而不是本地时区</li>
<li>LstdFlags：Logger 的默认初始值（Ldate 和 Ltime）</li>
</ul>
<ol start="4">
<li>out：io.Writer</li>
<li>buf：用于存储将要写入的日志内容</li>
</ol>
<h3 id="new">New</h3>
<pre><code>func New(out io.Writer, prefix string, flag int) *Logger {
	return &amp;Logger{out: out, prefix: prefix, flag: flag}
}

var std = New(os.Stderr, &quot;&quot;, LstdFlags)
</code></pre><p>New 方法用于初始化 Logger，接受三个初始参数，可以定制化而在 log 包内默认会初始一个 std，它指向标准输入流。而默认的标准输出、标准错误就是显示器（输出到屏幕上），标准输入就是键盘。辅助的时间信息默认为 <code>Ldate | Ltime</code>，也就是 <code>2009/01/23 01:23:23</code></p>
<pre><code>// os
var (
	Stdin  = NewFile(uintptr(syscall.Stdin), &quot;/dev/stdin&quot;)
	Stdout = NewFile(uintptr(syscall.Stdout), &quot;/dev/stdout&quot;)
	Stderr = NewFile(uintptr(syscall.Stderr), &quot;/dev/stderr&quot;)
)
</code></pre><ul>
<li>Stdin：标准输入</li>
<li>Stdout：标准输出</li>
<li>Stderr：标准错误</li>
</ul>
<h3 id="getter">Getter</h3>
<ul>
<li>Flags</li>
<li>Prefix</li>
</ul>
<h3 id="setter">Setter</h3>
<ul>
<li>SetFlags</li>
<li>SetPrefix</li>
<li>SetOutput</li>
</ul>
<h3 id="print-fatal-panic">Print*, Fatal*, Panic*</h3>
<pre><code>func Print(v ...interface{}) {
	std.Output(2, fmt.Sprint(v...))
}

func Printf(format string, v ...interface{}) {
	std.Output(2, fmt.Sprintf(format, v...))
}

func Println(v ...interface{}) {
	std.Output(2, fmt.Sprintln(v...))
}

func Fatal(v ...interface{}) {
	std.Output(2, fmt.Sprint(v...))
	os.Exit(1)
}

func Panic(v ...interface{}) {
	s := fmt.Sprint(v...)
	std.Output(2, s)
	panic(s)
}

...
</code></pre><p>这一部分介绍最常用的日志写入方法，从源码可得知 <code>Xrintln</code>、<code>Xrintf</code> 函数 <strong>换行</strong>、<strong>可变参数</strong>都是通过 <code>fmt</code> 标准库的方法去实现的</p>
<p><code>Fatal</code> 和 <code>Panic</code> 是通过 <code>os.Exit(1)</code>、<code>panic(s)</code> 集成实现的。而具体的组装逻辑是通过 <code>Output</code> 方法实现的</p>
<h4 id="loggeroutput">Logger.Output</h4>
<pre><code>func (l *Logger) Output(calldepth int, s string) error {
	now := time.Now() // get this early.
	var file string
	var line int
	l.mu.Lock()
	defer l.mu.Unlock()
	if l.flag&amp;(Lshortfile|Llongfile) != 0 {
		// Release lock while getting caller info - it's expensive.
		l.mu.Unlock()
		var ok bool
		_, file, line, ok = runtime.Caller(calldepth)
		if !ok {
			file = &quot;???&quot;
			line = 0
		}
		l.mu.Lock()
	}
	l.buf = l.buf[:0]
	l.formatHeader(&amp;l.buf, now, file, line)
	l.buf = append(l.buf, s...)
	if len(s) == 0 || s[len(s)-1] != '\n' {
		l.buf = append(l.buf, '\n')
	}
	_, err := l.out.Write(l.buf)
	return err
}
</code></pre><p>Output 方法，简单来讲就是将写入的日志事件信息组装并输出，它会根据 flag 标识位的不同来使用 <code>runtime.Caller</code> 去获取当前 goroutine 所执行的函数文件、行号等调用信息（log 标准库中默认深度为 2）。另外如果结尾不是换行符 <code>\n</code>，将自动补全一个换行</p>
<h4 id="loggerformatheader">Logger.formatHeader</h4>
<pre><code>func (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int) {
	*buf = append(*buf, l.prefix...)
	if l.flag&amp;(Ldate|Ltime|Lmicroseconds) != 0 {
		if l.flag&amp;LUTC != 0 {
			t = t.UTC()
		}
		if l.flag&amp;Ldate != 0 {
			year, month, day := t.Date()
			itoa(buf, year, 4)
			*buf = append(*buf, '/')
			itoa(buf, int(month), 2)
			*buf = append(*buf, '/')
			itoa(buf, day, 2)
			*buf = append(*buf, ' ')
		}
		if l.flag&amp;(Ltime|Lmicroseconds) != 0 {
			hour, min, sec := t.Clock()
			itoa(buf, hour, 2)
			*buf = append(*buf, ':')
			itoa(buf, min, 2)
			*buf = append(*buf, ':')
			itoa(buf, sec, 2)
			if l.flag&amp;Lmicroseconds != 0 {
				*buf = append(*buf, '.')
				itoa(buf, t.Nanosecond()/1e3, 6)
			}
			*buf = append(*buf, ' ')
		}
	}
	if l.flag&amp;(Lshortfile|Llongfile) != 0 {
		if l.flag&amp;Lshortfile != 0 {
			short := file
			for i := len(file) - 1; i &gt; 0; i-- {
				if file[i] == '/' {
					short = file[i+1:]
					break
				}
			}
			file = short
		}
		*buf = append(*buf, file...)
		*buf = append(*buf, ':')
		itoa(buf, line, -1)
		*buf = append(*buf, &quot;: &quot;...)
	}
}
</code></pre><p>该方法主要是用于格式化日志头（前缀），根据入参不同的标识位，添加分隔符和对应的值到日志信息中。执行流程如下：</p>
<p>（1）如果不是空值，则将 prefix 写入 buf</p>
<p>（2）如果设置 <code>Ldate</code>、<code>Ltime</code>、<code>Lmicroseconds</code>，则对应将日期和时间写入 buf</p>
<p>（3）如果设置 <code>Lshortfile</code>、<code>Llongfile</code>，则对应将文件和行号信息写入 buf</p>
<h4 id="loggeritoa">Logger.itoa</h4>
<pre><code>func itoa(buf *[]byte, i int, wid int) {
	// Assemble decimal in reverse order.
	var b [20]byte
	bp := len(b) - 1
	for i &gt;= 10 || wid &gt; 1 {
		wid--
		q := i / 10
		b[bp] = byte('0' + i - q*10)
		bp--
		i = q
	}
	// i &lt; 10
	b[bp] = byte('0' + i)
	*buf = append(*buf, b[bp:]...)
}
</code></pre><p>该方法主要用于将整数转换为定长的十进制 ASCII，同时给出负数宽度避免左侧补 0。另外会以相反的顺序组合十进制</p>
<h3 id="如何定制化-logger">如何定制化 Logger</h3>
<p>在标准库内，可通过其开放的 New 方法来实现各种各样的自定义 Logger 组件，但是为什么也可以直接 <code>log.Print*</code> 等方法呢？</p>
<pre><code>func New(out io.Writer, prefix string, flag int) *Logger
</code></pre><p>其实是在标准库内，如果你刚刚细心的看了前面的小节，不难发现其默认实现了一个 Logger 组件</p>
<pre><code>var std = New(os.Stderr, &quot;&quot;, LstdFlags)
</code></pre><p>这也是一个小小的精妙之处 ⭕️</p>
<h2 id="总结">总结</h2>
<p>通过查阅 log 标准库的源码，可得知最简单的一个日志包应该如何编写。另外 log 包是在所有涉及到 Logger 的地方都对 <code>sync.Mutex</code> 进行操作（以此解决原子问题），其余逻辑均为组装日志信息和转换数值格式，该包较为经典，可以多读几遍 😄</p>
<h2 id="问题">问题</h2>
<p>为什么在调用 <code>runtime.Caller</code> 前要先解锁，后再加锁呢?</p>
]]></content>
		</item>
		
		<item>
			<title>「连载三」gRPC Streaming, Client and Server</title>
			<link>https://eddycjy.com/posts/go/grpc/2018-09-24-stream-client-server/</link>
			<pubDate>Mon, 24 Sep 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc/2018-09-24-stream-client-server/</guid>
			<description>前言 本章节将介绍 gRPC 的流式，分为三种类型：
 Server-side streaming RPC：服务器端流式 RPC Client-side streaming RPC：客户端流式 RPC Bidirectional streaming RPC：双向流式 RPC  流 任何技术，因为有痛点，所以才有了存在的必要性。如果您想要了解 gRPC 的流式调用，请继续
图 gRPC Streaming 是基于 HTTP/2 的，后续章节再进行详细讲解
为什么不用 Simple RPC 流式为什么要存在呢，是 Simple RPC 有什么问题吗？通过模拟业务场景，可得知在使用 Simple RPC 时，有如下问题：
 数据包过大造成的瞬时压力 接收数据包时，需要所有数据包都接受成功且正确后，才能够回调响应，进行业务处理（无法客户端边发送，服务端边处理）  为什么用 Streaming RPC  大规模数据包 实时场景  模拟场景 每天早上 6 点，都有一批百万级别的数据集要同从 A 同步到 B，在同步的时候，会做一系列操作（归档、数据分析、画像、日志等）。这一次性涉及的数据量确实大
在同步完成后，也有人马上会去查阅数据，为了新的一天筹备。也符合实时性。
两者相较下，这个场景下更适合使用 Streaming RPC
gRPC 在讲解具体的 gRPC 流式代码时，会着重在第一节讲解，因为三种模式其实是不同的组合。希望你能够注重理解，举一反三，其实都是一样的知识点 👍
目录结构 $ tree go-grpc-example go-grpc-example ├── client │ ├── simple_client │ │ └── client.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章节将介绍 gRPC 的流式，分为三种类型：</p>
<ul>
<li>Server-side streaming RPC：服务器端流式 RPC</li>
<li>Client-side streaming RPC：客户端流式 RPC</li>
<li>Bidirectional streaming RPC：双向流式 RPC</li>
</ul>
<h2 id="流">流</h2>
<p>任何技术，因为有痛点，所以才有了存在的必要性。如果您想要了解 gRPC 的流式调用，请继续</p>
<h3 id="图">图</h3>
<p><img src="https://image.eddycjy.com/8812038d20ffece377c0e4901c9a9231.png" alt="image"></p>
<p>gRPC Streaming 是基于 HTTP/2 的，后续章节再进行详细讲解</p>
<h3 id="为什么不用-simple-rpc">为什么不用 Simple RPC</h3>
<p>流式为什么要存在呢，是 Simple RPC 有什么问题吗？通过模拟业务场景，可得知在使用 Simple RPC 时，有如下问题：</p>
<ul>
<li>数据包过大造成的瞬时压力</li>
<li>接收数据包时，需要所有数据包都接受成功且正确后，才能够回调响应，进行业务处理（无法客户端边发送，服务端边处理）</li>
</ul>
<h3 id="为什么用-streaming-rpc">为什么用 Streaming RPC</h3>
<ul>
<li>大规模数据包</li>
<li>实时场景</li>
</ul>
<h4 id="模拟场景">模拟场景</h4>
<p>每天早上 6 点，都有一批百万级别的数据集要同从 A 同步到 B，在同步的时候，会做一系列操作（归档、数据分析、画像、日志等）。这一次性涉及的数据量确实大</p>
<p>在同步完成后，也有人马上会去查阅数据，为了新的一天筹备。也符合实时性。</p>
<p>两者相较下，这个场景下更适合使用 Streaming RPC</p>
<h2 id="grpc">gRPC</h2>
<p>在讲解具体的 gRPC 流式代码时，会<strong>着重在第一节讲解</strong>，因为三种模式其实是不同的组合。希望你能够注重理解，举一反三，其实都是一样的知识点 👍</p>
<h3 id="目录结构">目录结构</h3>
<pre><code>$ tree go-grpc-example
go-grpc-example
├── client
│   ├── simple_client
│   │   └── client.go
│   └── stream_client
│       └── client.go
├── proto
│   ├── search.proto
│   └── stream.proto
└── server
    ├── simple_server
    │   └── server.go
    └── stream_server
        └── server.go
</code></pre><p>增加 stream_server、stream_client 存放服务端和客户端文件，proto/stream.proto 用于编写 IDL</p>
<h3 id="idl">IDL</h3>
<p>在 proto 文件夹下的 stream.proto 文件中，写入如下内容：</p>
<pre><code>syntax = &quot;proto3&quot;;

package proto;

service StreamService {
    rpc List(StreamRequest) returns (stream StreamResponse) {};

    rpc Record(stream StreamRequest) returns (StreamResponse) {};

    rpc Route(stream StreamRequest) returns (stream StreamResponse) {};
}


message StreamPoint {
  string name = 1;
  int32 value = 2;
}

message StreamRequest {
  StreamPoint pt = 1;
}

message StreamResponse {
  StreamPoint pt = 1;
}
</code></pre><p>注意关键字 stream，声明其为一个流方法。这里共涉及三个方法，对应关系为</p>
<ul>
<li>List：服务器端流式 RPC</li>
<li>Record：客户端流式 RPC</li>
<li>Route：双向流式 RPC</li>
</ul>
<h3 id="基础模板--空定义">基础模板 + 空定义</h3>
<h4 id="server">Server</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net&#34;</span>

	<span class="s">&#34;google.golang.org/grpc&#34;</span>

	<span class="nx">pb</span> <span class="s">&#34;github.com/EDDYCJY/go-grpc-example/proto&#34;</span>

<span class="p">)</span>

<span class="kd">type</span> <span class="nx">StreamService</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">PORT</span> <span class="p">=</span> <span class="s">&#34;9002&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">server</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>
	<span class="nx">pb</span><span class="p">.</span><span class="nf">RegisterStreamServiceServer</span><span class="p">(</span><span class="nx">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">StreamService</span><span class="p">{})</span>

	<span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;net.Listen err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">server</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">List</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">,</span> <span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_ListServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">Record</span><span class="p">(</span><span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_RecordServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">Route</span><span class="p">(</span><span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_RouteServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>写代码前，建议先将 gRPC Server 的基础模板和接口给空定义出来。若有不清楚可参见上一章节的知识点</p>
<h4 id="client">Client</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;log&#34;</span>

	<span class="s">&#34;google.golang.org/grpc&#34;</span>

	<span class="nx">pb</span> <span class="s">&#34;github.com/EDDYCJY/go-grpc-example/proto&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">PORT</span> <span class="p">=</span> <span class="s">&#34;9002&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc.Dial err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">client</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nf">NewStreamServiceClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nf">printLists</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">{</span><span class="nx">Pt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;gRPC Stream Client: List&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="mi">2018</span><span class="p">}})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;printLists.err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nf">printRecord</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">{</span><span class="nx">Pt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;gRPC Stream Client: Record&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="mi">2018</span><span class="p">}})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;printRecord.err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nf">printRoute</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">{</span><span class="nx">Pt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;gRPC Stream Client: Route&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="mi">2018</span><span class="p">}})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;printRoute.err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">printLists</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">printRecord</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">printRoute</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h3 id="一server-side-streaming-rpc服务器端流式-rpc">一、Server-side streaming RPC：服务器端流式 RPC</h3>
<p>服务器端流式 RPC，显然是单向流，并代指 Server 为 Stream 而 Client 为普通 RPC 请求</p>
<p>简单来讲就是客户端发起一次普通的 RPC 请求，服务端通过流式响应多次发送数据集，客户端 Recv 接收数据集。大致如图：</p>
<p><img src="https://image.eddycjy.com/b25a47e2f2fb2a8c352a547f7612808b.png" alt="image"></p>
<h4 id="server-1">Server</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">List</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">,</span> <span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_ListServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamResponse</span><span class="p">{</span>
			<span class="nx">Pt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span>
				<span class="nx">Name</span><span class="p">:</span>  <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span>
				<span class="nx">Value</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span> <span class="o">+</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span>
			<span class="p">},</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>在 Server，主要留意 <code>stream.Send</code> 方法。它看上去能发送 N 次？有没有大小限制？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StreamService_ListServer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Send</span><span class="p">(</span><span class="o">*</span><span class="nx">StreamResponse</span><span class="p">)</span> <span class="kt">error</span>
	<span class="nx">grpc</span><span class="p">.</span><span class="nx">ServerStream</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">streamServiceListServer</span><span class="p">)</span> <span class="nf">Send</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">StreamResponse</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ServerStream</span><span class="p">.</span><span class="nf">SendMsg</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>通过阅读源码，可得知是 protoc 在生成时，根据定义生成了各式各样符合标准的接口方法。最终再统一调度内部的 <code>SendMsg</code> 方法，该方法涉及以下过程:</p>
<ul>
<li>消息体（对象）序列化</li>
<li>压缩序列化后的消息体</li>
<li>对正在传输的消息体增加 5 个字节的 header</li>
<li>判断压缩+序列化后的消息体总字节长度是否大于预设的 maxSendMessageSize（预设值为 <code>math.MaxInt32</code>），若超出则提示错误</li>
<li>写入给流的数据集</li>
</ul>
<h4 id="client-1">Client</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">printLists</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">List</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">r</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;resp: pj.name: %s, pt.value: %d&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>在 Client，主要留意 <code>stream.Recv()</code> 方法。什么情况下 <code>io.EOF</code> ？什么情况下存在错误信息呢?</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StreamService_ListClient</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Recv</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">StreamResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientStream</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">streamServiceListClient</span><span class="p">)</span> <span class="nf">Recv</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">StreamResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">StreamResponse</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ClientStream</span><span class="p">.</span><span class="nf">RecvMsg</span><span class="p">(</span><span class="nx">m</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">m</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>RecvMsg 会从流中读取完整的 gRPC 消息体，另外通过阅读源码可得知：</p>
<p>（1）RecvMsg 是阻塞等待的</p>
<p>（2）RecvMsg 当流成功/结束（调用了 Close）时，会返回 <code>io.EOF</code></p>
<p>（3）RecvMsg 当流出现任何错误时，流会被中止，错误信息会包含 RPC 错误码。而在 RecvMsg 中可能出现如下错误：</p>
<ul>
<li>io.EOF</li>
<li>io.ErrUnexpectedEOF</li>
<li>transport.ConnectionError</li>
<li>google.golang.org/grpc/codes</li>
</ul>
<p>同时需要注意，默认的 MaxReceiveMessageSize 值为 1024 _ 1024 _ 4，建议不要超出</p>
<h4 id="验证">验证</h4>
<p>运行 stream_server/server.go：</p>
<pre><code>$ go run server.go
</code></pre><p>运行 stream_client/client.go：</p>
<pre><code>$ go run client.go
2018/09/24 16:18:25 resp: pj.name: gRPC Stream Client: List, pt.value: 2018
2018/09/24 16:18:25 resp: pj.name: gRPC Stream Client: List, pt.value: 2019
2018/09/24 16:18:25 resp: pj.name: gRPC Stream Client: List, pt.value: 2020
2018/09/24 16:18:25 resp: pj.name: gRPC Stream Client: List, pt.value: 2021
2018/09/24 16:18:25 resp: pj.name: gRPC Stream Client: List, pt.value: 2022
2018/09/24 16:18:25 resp: pj.name: gRPC Stream Client: List, pt.value: 2023
2018/09/24 16:18:25 resp: pj.name: gRPC Stream Client: List, pt.value: 2024
</code></pre><h3 id="二client-side-streaming-rpc客户端流式-rpc">二、Client-side streaming RPC：客户端流式 RPC</h3>
<p>客户端流式 RPC，单向流，客户端通过流式发起<strong>多次</strong> RPC 请求给服务端，服务端发起<strong>一次</strong>响应给客户端，大致如图：</p>
<p><img src="https://image.eddycjy.com/97473884d939ec91d6cdf53090bef92e.png" alt="image"></p>
<h4 id="server-2">Server</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">Record</span><span class="p">(</span><span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_RecordServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">SendAndClose</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamResponse</span><span class="p">{</span><span class="nx">Pt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;gRPC Stream Server: Record&#34;</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span> <span class="mi">1</span><span class="p">}})</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;stream.Recv pt.name: %s, pt.value: %d&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>多了一个从未见过的方法 <code>stream.SendAndClose</code>，它是做什么用的呢？</p>
<p>在这段程序中，我们对每一个 Recv 都进行了处理，当发现 <code>io.EOF</code> (流关闭) 后，需要将最终的响应结果发送给客户端，同时关闭正在另外一侧等待的 Recv</p>
<h4 id="client-2">Client</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">printRecord</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Record</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">CloseAndRecv</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;resp: pj.name: %s, pt.value: %d&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p><code>stream.CloseAndRecv</code> 和 <code>stream.SendAndClose</code> 是配套使用的流方法，相信聪明的你已经秒懂它的作用了</p>
<h4 id="验证-1">验证</h4>
<p>重启 stream_server/server.go，再次运行 stream_client/client.go：</p>
<h5 id="stream_client">stream_client：</h5>
<pre><code>$ go run client.go
2018/09/24 16:23:03 resp: pj.name: gRPC Stream Server: Record, pt.value: 1
</code></pre><h5 id="stream_server">stream_server：</h5>
<pre><code>$ go run server.go
2018/09/24 16:23:03 stream.Recv pt.name: gRPC Stream Client: Record, pt.value: 2018
2018/09/24 16:23:03 stream.Recv pt.name: gRPC Stream Client: Record, pt.value: 2018
2018/09/24 16:23:03 stream.Recv pt.name: gRPC Stream Client: Record, pt.value: 2018
2018/09/24 16:23:03 stream.Recv pt.name: gRPC Stream Client: Record, pt.value: 2018
2018/09/24 16:23:03 stream.Recv pt.name: gRPC Stream Client: Record, pt.value: 2018
2018/09/24 16:23:03 stream.Recv pt.name: gRPC Stream Client: Record, pt.value: 2018
</code></pre><h3 id="三bidirectional-streaming-rpc双向流式-rpc">三、Bidirectional streaming RPC：双向流式 RPC</h3>
<p>双向流式 RPC，顾名思义是双向流。由客户端以流式的方式发起请求，服务端同样以流式的方式响应请求</p>
<p>首个请求一定是 Client 发起，但具体交互方式（谁先谁后、一次发多少、响应多少、什么时候关闭）根据程序编写的方式来确定（可以结合协程）</p>
<p>假设该双向流是<strong>按顺序发送</strong>的话，大致如图：</p>
<p><img src="https://image.eddycjy.com/ab80297cd6715048a235e0c9b0f36091.png" alt="image"></p>
<p>还是要强调，双向流变化很大，因程序编写的不同而不同。<strong>双向流图示无法适用不同的场景</strong></p>
<h4 id="server-3">Server</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">StreamService</span><span class="p">)</span> <span class="nf">Route</span><span class="p">(</span><span class="nx">stream</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamService_RouteServer</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamResponse</span><span class="p">{</span>
			<span class="nx">Pt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamPoint</span><span class="p">{</span>
				<span class="nx">Name</span><span class="p">:</span>  <span class="s">&#34;gPRC Stream Client: Route&#34;</span><span class="p">,</span>
				<span class="nx">Value</span><span class="p">:</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span>
			<span class="p">},</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">n</span><span class="o">++</span>

		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;stream.Recv pt.name: %s, pt.value: %d&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="client-3">Client</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">printRoute</span><span class="p">(</span><span class="nx">client</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">StreamServiceClient</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">StreamRequest</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">stream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Route</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">stream</span><span class="p">.</span><span class="nf">Recv</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;resp: pj.name: %s, pt.value: %d&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">stream</span><span class="p">.</span><span class="nf">CloseSend</span><span class="p">()</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="验证-2">验证</h4>
<p>重启 stream_server/server.go，再次运行 stream_client/client.go：</p>
<h5 id="stream_server-1">stream_server</h5>
<pre><code>$ go run server.go
2018/09/24 16:29:43 stream.Recv pt.name: gRPC Stream Client: Route, pt.value: 2018
2018/09/24 16:29:43 stream.Recv pt.name: gRPC Stream Client: Route, pt.value: 2018
2018/09/24 16:29:43 stream.Recv pt.name: gRPC Stream Client: Route, pt.value: 2018
2018/09/24 16:29:43 stream.Recv pt.name: gRPC Stream Client: Route, pt.value: 2018
2018/09/24 16:29:43 stream.Recv pt.name: gRPC Stream Client: Route, pt.value: 2018
2018/09/24 16:29:43 stream.Recv pt.name: gRPC Stream Client: Route, pt.value: 2018
</code></pre><h5 id="stream_client-1">stream_client</h5>
<pre><code>$ go run client.go
2018/09/24 16:29:43 resp: pj.name: gPRC Stream Client: Route, pt.value: 0
2018/09/24 16:29:43 resp: pj.name: gPRC Stream Client: Route, pt.value: 1
2018/09/24 16:29:43 resp: pj.name: gPRC Stream Client: Route, pt.value: 2
2018/09/24 16:29:43 resp: pj.name: gPRC Stream Client: Route, pt.value: 3
2018/09/24 16:29:43 resp: pj.name: gPRC Stream Client: Route, pt.value: 4
2018/09/24 16:29:43 resp: pj.name: gPRC Stream Client: Route, pt.value: 5
2018/09/24 16:29:43 resp: pj.name: gPRC Stream Client: Route, pt.value: 6
</code></pre><h2 id="总结">总结</h2>
<p>在本文共介绍了三类流的交互方式，可以根据实际的业务场景去选择合适的方式。会事半功倍哦 🎑</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-grpc-example">go-grpc-example</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载二」gRPC Client and Server</title>
			<link>https://eddycjy.com/posts/go/grpc/2018-09-23-client-and-server/</link>
			<pubDate>Sun, 23 Sep 2018 12:30:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc/2018-09-23-client-and-server/</guid>
			<description>前言 本章节将使用 Go 来编写 gRPC Server 和 Client，让其互相通讯。在此之上会使用到如下库：
 google.golang.org/grpc github.com/golang/protobuf/protoc-gen-go  安装 gRPC go get -u google.golang.org/grpc Protocol Buffers v3 wget https://github.com/google/protobuf/releases/download/v3.5.1/protobuf-all-3.5.1.zip unzip protobuf-all-3.5.1.zip cd protobuf-3.5.1/ ./configure make make install 检查是否安装成功
protoc --version 若出现以下错误，执行 ldconfig 命名就能解决这问题
protoc: error while loading shared libraries: libprotobuf.so.15: cannot open shared object file: No such file or directory Protoc Plugin go get -u github.com/golang/protobuf/protoc-gen-go 安装环境若有问题，可参考我先前的文章 《介绍与环境安装》 内有详细介绍，不再赘述
gRPC 本小节开始正式编写 gRPC 相关的程序，一起上车吧 😄
图示 目录结构 $ tree go-grpc-example go-grpc-example ├── client ├── proto │ └── search.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>本章节将使用 Go 来编写 gRPC Server 和 Client，让其互相通讯。在此之上会使用到如下库：</p>
<ul>
<li>google.golang.org/grpc</li>
<li>github.com/golang/protobuf/protoc-gen-go</li>
</ul>
<h2 id="安装">安装</h2>
<h3 id="grpc">gRPC</h3>
<pre><code>go get -u google.golang.org/grpc
</code></pre><h3 id="protocol-buffers-v3">Protocol Buffers v3</h3>
<pre><code>wget https://github.com/google/protobuf/releases/download/v3.5.1/protobuf-all-3.5.1.zip
unzip protobuf-all-3.5.1.zip
cd protobuf-3.5.1/
./configure
make
make install
</code></pre><p>检查是否安装成功</p>
<pre><code>protoc --version
</code></pre><p>若出现以下错误，执行 <code>ldconfig</code> 命名就能解决这问题</p>
<pre><code>protoc: error while loading shared libraries: libprotobuf.so.15: cannot open shared object file: No such file or directory
</code></pre><h3 id="protoc-plugin">Protoc Plugin</h3>
<pre><code>go get -u github.com/golang/protobuf/protoc-gen-go
</code></pre><p>安装环境若有问题，可参考我先前的文章 <a href="https://segmentfault.com/a/1190000013339403">《介绍与环境安装》</a> 内有详细介绍，不再赘述</p>
<h2 id="grpc-1">gRPC</h2>
<p>本小节开始正式编写 gRPC 相关的程序，一起上车吧 😄</p>
<h3 id="图示">图示</h3>
<p><img src="https://image.eddycjy.com/415d9544fce1e774e1095ab99b6cc015.png" alt="image"></p>
<h3 id="目录结构">目录结构</h3>
<pre><code>$ tree go-grpc-example
go-grpc-example
├── client
├── proto
│   └── search.proto
└── server.go
</code></pre><h3 id="idl">IDL</h3>
<h4 id="编写">编写</h4>
<p>在 proto 文件夹下的 search.proto 文件中，写入如下内容：</p>
<pre><code>syntax = &quot;proto3&quot;;

package proto;

service SearchService {
    rpc Search(SearchRequest) returns (SearchResponse) {}
}

message SearchRequest {
    string request = 1;
}

message SearchResponse {
    string response = 1;
}
</code></pre><h4 id="生成">生成</h4>
<p>在 proto 文件夹下执行如下命令：</p>
<pre><code>$ protoc --go_out=plugins=grpc:. *.proto
</code></pre><ul>
<li>plugins=plugin1+plugin2：指定要加载的子插件列表</li>
</ul>
<p>我们定义的 proto 文件是涉及了 RPC 服务的，而默认是不会生成 RPC 代码的，因此需要给出 <code>plugins</code> 参数传递给 <code>protoc-gen-go</code>，告诉它，请支持 RPC（这里指定了 gRPC）</p>
<ul>
<li>&ndash;go_out=.：设置 Go 代码输出的目录</li>
</ul>
<p>该指令会加载 protoc-gen-go 插件达到生成 Go 代码的目的，生成的文件以 .pb.go 为文件后缀</p>
<ul>
<li>: （冒号）</li>
</ul>
<p>冒号充当分隔符的作用，后跟所需要的参数集。如果这处不涉及 RPC，命令可简化为：</p>
<pre><code>$ protoc --go_out=. *.proto
</code></pre><p>注：建议你看看两条命令生成的 .pb.go 文件，分别有什么区别</p>
<h4 id="生成后">生成后</h4>
<p>执行完毕命令后，将得到一个 .pb.go 文件，文件内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SearchRequest</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Request</span>              <span class="kt">string</span>   <span class="s">`protobuf:&#34;bytes,1,opt,name=request&#34; json:&#34;request,omitempty&#34;`</span>
	<span class="nx">XXX_NoUnkeyedLiteral</span> <span class="kd">struct</span><span class="p">{}</span> <span class="s">`json:&#34;-&#34;`</span>
	<span class="nx">XXX_unrecognized</span>     <span class="p">[]</span><span class="kt">byte</span>   <span class="s">`json:&#34;-&#34;`</span>
	<span class="nx">XXX_sizecache</span>        <span class="kt">int32</span>    <span class="s">`json:&#34;-&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">SearchRequest</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span>         <span class="p">{</span> <span class="o">*</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">SearchRequest</span><span class="p">{}</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">SearchRequest</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">CompactTextString</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">SearchRequest</span><span class="p">)</span> <span class="nf">ProtoMessage</span><span class="p">()</span>    <span class="p">{}</span>
<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">SearchRequest</span><span class="p">)</span> <span class="nf">Descriptor</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fileDescriptor_search_8b45f79ee13ff6a3</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">SearchRequest</span><span class="p">)</span> <span class="nf">GetRequest</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">m</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Request</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</code></pre></div><p>通过阅读这一部分代码，可以知道主要涉及如下方面：</p>
<ul>
<li>字段名称从小写下划线转换为大写驼峰模式（字段导出）</li>
<li>生成一组 Getters 方法，能便于处理一些空指针取值的情况</li>
<li>ProtoMessage 方法实现 proto.Message 的接口</li>
<li>生成 Rest 方法，便于将 Protobuf 结构体恢复为零值</li>
<li>Repeated 转换为切片</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SearchRequest</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Request</span>              <span class="kt">string</span>   <span class="s">`protobuf:&#34;bytes,1,opt,name=request&#34; json:&#34;request,omitempty&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">SearchRequest</span><span class="p">)</span> <span class="nf">Descriptor</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fileDescriptor_search_8b45f79ee13ff6a3</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SearchResponse</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Response</span>             <span class="kt">string</span>   <span class="s">`protobuf:&#34;bytes,1,opt,name=response&#34; json:&#34;response,omitempty&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">SearchResponse</span><span class="p">)</span> <span class="nf">Descriptor</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fileDescriptor_search_8b45f79ee13ff6a3</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">RegisterFile</span><span class="p">(</span><span class="s">&#34;search.proto&#34;</span><span class="p">,</span> <span class="nx">fileDescriptor_search_8b45f79ee13ff6a3</span><span class="p">)</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">fileDescriptor_search_8b45f79ee13ff6a3</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span>
	<span class="c1">// 131 bytes of a gzipped FileDescriptorProto
</span><span class="c1"></span>	<span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0x29</span><span class="p">,</span> <span class="mh">0x4e</span><span class="p">,</span> <span class="mh">0x4d</span><span class="p">,</span> <span class="mh">0x2c</span><span class="p">,</span>
	<span class="mh">0x4a</span><span class="p">,</span> <span class="mh">0xce</span><span class="p">,</span> <span class="mh">0xd0</span><span class="p">,</span> <span class="mh">0x2b</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">,</span> <span class="mh">0xca</span><span class="p">,</span> <span class="mh">0x2f</span><span class="p">,</span> <span class="mh">0xc9</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span> <span class="mh">0x62</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x53</span><span class="p">,</span> <span class="mh">0x4a</span><span class="p">,</span> <span class="mh">0x9a</span><span class="p">,</span> <span class="mh">0x5c</span><span class="p">,</span> <span class="mh">0xbc</span><span class="p">,</span>
	<span class="mh">0xc1</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">,</span> <span class="mh">0xe1</span><span class="p">,</span> <span class="mh">0xa0</span><span class="p">,</span> <span class="mh">0xd4</span><span class="p">,</span> <span class="mh">0xc2</span><span class="p">,</span> <span class="mh">0xd2</span><span class="p">,</span> <span class="mh">0xd4</span><span class="p">,</span> <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x09</span><span class="p">,</span> <span class="mh">0x2e</span><span class="p">,</span> <span class="mh">0xf6</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="mh">0x53</span><span class="p">,</span> <span class="mh">0x82</span><span class="p">,</span> <span class="mh">0x51</span><span class="p">,</span> <span class="mh">0x81</span><span class="p">,</span> <span class="mh">0x51</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0x33</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0xc6</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0xd2</span><span class="p">,</span> <span class="mh">0xe1</span><span class="p">,</span> <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0x29</span><span class="p">,</span> <span class="mh">0x2d</span><span class="p">,</span>
	<span class="mh">0x2e</span><span class="p">,</span> <span class="mh">0xc8</span><span class="p">,</span> <span class="mh">0xcf</span><span class="p">,</span> <span class="mh">0x2b</span><span class="p">,</span> <span class="mh">0x4e</span><span class="p">,</span> <span class="mh">0x15</span><span class="p">,</span> <span class="mh">0x92</span><span class="p">,</span> <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">,</span> <span class="mh">0x82</span><span class="p">,</span> <span class="mh">0xb2</span><span class="p">,</span> <span class="mh">0xa1</span><span class="p">,</span> <span class="mh">0x8a</span><span class="p">,</span> <span class="mh">0xe1</span><span class="p">,</span> <span class="mh">0x7c</span><span class="p">,</span>
	<span class="mh">0x23</span><span class="p">,</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="mh">0xc1</span><span class="p">,</span> <span class="mh">0xc1</span><span class="p">,</span> <span class="mh">0xa9</span><span class="p">,</span> <span class="mh">0x45</span><span class="p">,</span> <span class="mh">0x65</span><span class="p">,</span> <span class="mh">0x99</span><span class="p">,</span> <span class="mh">0xc9</span><span class="p">,</span> <span class="mh">0xa9</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="mh">0xe6</span><span class="p">,</span> <span class="mh">0x5c</span><span class="p">,</span> <span class="mh">0x6c</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x13</span><span class="p">,</span> <span class="mh">0xf4</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="mh">0x2c</span><span class="p">,</span> <span class="mh">0x96</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">,</span> <span class="mh">0x45</span><span class="p">,</span> <span class="mh">0x13</span><span class="p">,</span> <span class="mh">0x85</span><span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="mh">0xa3</span><span class="p">,</span> <span class="mh">0xc4</span><span class="p">,</span>
	<span class="mh">0x90</span><span class="p">,</span> <span class="mh">0xc4</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">,</span> <span class="mh">0x16</span><span class="p">,</span> <span class="mh">0x37</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xf3</span><span class="p">,</span> <span class="mh">0xba</span><span class="p">,</span> <span class="mh">0x74</span><span class="p">,</span> <span class="mh">0x95</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">,</span>
	<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>而这一部分代码主要是围绕 <code>fileDescriptor</code> 进行，在这里 <code>fileDescriptor_search_8b45f79ee13ff6a3</code> 表示一个编译后的 proto 文件，而每一个方法都包含 Descriptor 方法，代表着这一个方法在 <code>fileDescriptor</code> 中具体的 Message Field</p>
<h3 id="server">Server</h3>
<p>这一小节将编写 gRPC Server 的基础模板，完成一个方法的调用。对 server.go 写入如下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net&#34;</span>

	<span class="s">&#34;google.golang.org/grpc&#34;</span>

	<span class="nx">pb</span> <span class="s">&#34;github.com/EDDYCJY/go-grpc-example/proto&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">SearchService</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SearchService</span><span class="p">)</span> <span class="nf">Search</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">SearchRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">SearchResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">SearchResponse</span><span class="p">{</span><span class="nx">Response</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nf">GetRequest</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; Server&#34;</span><span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">PORT</span> <span class="p">=</span> <span class="s">&#34;9001&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">server</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>
	<span class="nx">pb</span><span class="p">.</span><span class="nf">RegisterSearchServiceServer</span><span class="p">(</span><span class="nx">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">SearchService</span><span class="p">{})</span>

	<span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;net.Listen err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">server</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>创建 gRPC Server 对象，你可以理解为它是 Server 端的抽象对象</li>
<li>将 SearchService（其包含需要被调用的服务端接口）注册到 gRPC Server 的内部注册中心。这样可以在接受到请求时，通过内部的服务发现，发现该服务端接口并转接进行逻辑处理</li>
<li>创建 Listen，监听 TCP 端口</li>
<li>gRPC Server 开始 lis.Accept，直到 Stop 或 GracefulStop</li>
</ul>
<h3 id="client">Client</h3>
<p>接下来编写 gRPC Go Client 的基础模板，打开 client/client.go 文件，写入以下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;log&#34;</span>

	<span class="s">&#34;google.golang.org/grpc&#34;</span>

	<span class="nx">pb</span> <span class="s">&#34;github.com/EDDYCJY/go-grpc-example/proto&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">PORT</span> <span class="p">=</span> <span class="s">&#34;9001&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">PORT</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;grpc.Dial err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">client</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nf">NewSearchServiceClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">SearchRequest</span><span class="p">{</span>
		<span class="nx">Request</span><span class="p">:</span> <span class="s">&#34;gRPC&#34;</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;client.Search err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;resp: %s&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nf">GetResponse</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>创建与给定目标（服务端）的连接交互</li>
<li>创建 SearchService 的客户端对象</li>
<li>发送 RPC 请求，等待同步响应，得到回调后返回响应结果</li>
<li>输出响应结果</li>
</ul>
<h2 id="验证">验证</h2>
<h3 id="启动-server">启动 Server</h3>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ <span class="nb">pwd</span>
<span class="nv">$GOPATH</span>/github.com/EDDYCJY/go-grpc-example
$ go run server.go
</code></pre></div><h3 id="启动-client">启动 Client</h3>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ <span class="nb">pwd</span>
<span class="nv">$GOPATH</span>/github.com/EDDYCJY/go-grpc-example/client
$ go run client.go
2018/09/23 11:06:23 resp: gRPC Server
</code></pre></div><h2 id="总结">总结</h2>
<p>在本章节，我们对 Protobuf、gRPC Client/Server 分别都进行了介绍。希望你结合文中讲述内容再写一个 Demo 进行深入了解，肯定会更棒 🤔</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-grpc-example">go-grpc-example</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载一」gRPC及相关介绍</title>
			<link>https://eddycjy.com/posts/go/grpc/2018-09-22-install/</link>
			<pubDate>Sat, 22 Sep 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc/2018-09-22-install/</guid>
			<description>项目地址：https://github.com/EDDYCJY/go-grpc-example
作为开篇章，将会介绍 gRPC 相关的一些知识。简单来讲 gRPC 是一个 基于 HTTP/2 协议设计的 RPC 框架，它采用了 Protobuf 作为 IDL
你是否有过疑惑，它们都是些什么？本文将会介绍一些常用的知识和概念，更详细的会给出手册地址去深入
一、RPC 什么是 RPC RPC 代指远程过程调用（Remote Procedure Call），它的调用包含了传输协议和编码（对象序列号）协议等等。允许运行于一台计算机的程序调用另一台计算机的子程序，而开发人员无需额外地为这个交互作用编程
实际场景： 有两台服务器，分别是 A、B。在 A 上的应用 C 想要调用 B 服务器上的应用 D，它们可以直接本地调用吗？
答案是不能的，但走 RPC 的话，十分方便。因此常有人称使用 RPC，就跟本地调用一个函数一样简单
RPC 框架 我认为，一个完整的 RPC 框架，应包含负载均衡、服务注册和发现、服务治理等功能，并具有可拓展性便于流量监控系统等接入
那么它才算完整的，当然了。有些较单一的 RPC 框架，通过组合多组件也能达到这个标准
你认为呢？
常见 RPC 框架  gRPC Thrift Rpcx Dubbo  比较一下    \ 跨语言 多 IDL 服务治理 注册中心 服务管理     gRPC √ × × × ×   Thrift √ × × × ×   Rpcx × √ √ √ √   Dubbo × √ √ √ √    为什么要 RPC 简单、通用、安全、效率</description>
			<content type="html"><![CDATA[<p>项目地址：https://github.com/EDDYCJY/go-grpc-example</p>
<p>作为开篇章，将会介绍 gRPC 相关的一些知识。简单来讲 gRPC 是一个 基于 HTTP/2 协议设计的 RPC 框架，它采用了 Protobuf 作为 IDL</p>
<p>你是否有过疑惑，它们都是些什么？本文将会介绍一些常用的知识和概念，更详细的会给出手册地址去深入</p>
<h2 id="一rpc">一、RPC</h2>
<h3 id="什么是-rpc">什么是 RPC</h3>
<p>RPC 代指远程过程调用（Remote Procedure Call），它的调用包含了传输协议和编码（对象序列号）协议等等。允许运行于一台计算机的程序调用另一台计算机的子程序，而开发人员无需额外地为这个交互作用编程</p>
<h4 id="实际场景">实际场景：</h4>
<p>有两台服务器，分别是 A、B。在 A 上的应用 C 想要调用 B 服务器上的应用 D，它们可以直接本地调用吗？<br>
答案是不能的，但走 RPC 的话，十分方便。因此常有人称使用 RPC，就跟本地调用一个函数一样简单</p>
<h3 id="rpc-框架">RPC 框架</h3>
<p>我认为，一个完整的 RPC 框架，应包含负载均衡、服务注册和发现、服务治理等功能，并具有可拓展性便于流量监控系统等接入<br>
那么它才算完整的，当然了。有些较单一的 RPC 框架，通过组合多组件也能达到这个标准</p>
<p>你认为呢？</p>
<h3 id="常见-rpc-框架">常见 RPC 框架</h3>
<ul>
<li><a href="https://grpc.io/">gRPC</a></li>
<li><a href="https://github.com/apache/thrift">Thrift</a></li>
<li><a href="https://github.com/smallnest/rpcx">Rpcx</a></li>
<li><a href="https://github.com/apache/incubator-dubbo">Dubbo</a></li>
</ul>
<h3 id="比较一下">比较一下</h3>
<table>
<thead>
<tr>
<th>\</th>
<th>跨语言</th>
<th>多 IDL</th>
<th>服务治理</th>
<th>注册中心</th>
<th>服务管理</th>
</tr>
</thead>
<tbody>
<tr>
<td>gRPC</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>Thrift</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>Rpcx</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Dubbo</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<h3 id="为什么要-rpc">为什么要 RPC</h3>
<p>简单、通用、安全、效率</p>
<h3 id="rpc-可以基于-http-吗">RPC 可以基于 HTTP 吗</h3>
<p>RPC 是代指远程过程调用，是可以基于 HTTP 协议的</p>
<p>肯定会有人说效率优势，我可以告诉你，那是基于 HTTP/1.1 来讲的，HTTP/2 优化了许多问题（当然也存在新的问题），所以你看到了本文的主题 gRPC</p>
<h2 id="二protobuf">二、Protobuf</h2>
<h3 id="介绍">介绍</h3>
<p>Protocol Buffers 是一种与语言、平台无关，可扩展的序列化结构化数据的方法，常用于通信协议，数据存储等等。相较于 JSON、XML，它更小、更快、更简单，因此也更受开发人员的青眯</p>
<h3 id="语法">语法</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">syntax</span> <span class="p">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span>

<span class="nx">service</span> <span class="nx">SearchService</span> <span class="p">{</span>
    <span class="nx">rpc</span> <span class="nf">Search</span> <span class="p">(</span><span class="nx">SearchRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">SearchResponse</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">message</span> <span class="nx">SearchRequest</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="nx">query</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int32</span> <span class="nx">page_number</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int32</span> <span class="nx">result_per_page</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">message</span> <span class="nx">SearchResponse</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>1、第一行（非空的非注释行）声明使用 <code>proto3</code> 语法。如果不声明，将默认使用 <code>proto2</code> 语法。同时我建议用 v2 还是 v3，都应当声明其使用的版本</p>
<p>2、定义 <code>SearchService</code> RPC 服务，其包含 RPC 方法 <code>Search</code>，入参为 <code>SearchRequest</code> 消息，出参为 <code>SearchResponse</code> 消息</p>
<p>3、定义 <code>SearchRequest</code>、<code>SearchResponse</code> 消息，前者定义了三个字段，每一个字段包含三个属性：类型、字段名称、字段编号</p>
<p>4、Protobuf 编译器会根据选择的语言不同，生成相应语言的 Service Interface Code 和 Stubs</p>
<p>最后，这里只是简单的语法介绍，详细的请右拐 <a href="https://developers.google.com/protocol-buffers/docs/proto3">
Language Guide (proto3)</a></p>
<h3 id="数据类型">数据类型</h3>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>C++ Type</th>
<th>Java Type</th>
<th>Go Type</th>
<th>PHP Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>double</td>
<td>double</td>
<td>double</td>
<td>float64</td>
<td>float</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float32</td>
<td>float</td>
</tr>
<tr>
<td>int32</td>
<td>int32</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>int64</td>
<td>int64</td>
<td>long</td>
<td>int64</td>
<td>integer/string</td>
</tr>
<tr>
<td>uint32</td>
<td>uint32</td>
<td>int</td>
<td>uint32</td>
<td>integer</td>
</tr>
<tr>
<td>uint64</td>
<td>uint64</td>
<td>long</td>
<td>uint64</td>
<td>integer/string</td>
</tr>
<tr>
<td>sint32</td>
<td>int32</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>sint64</td>
<td>int64</td>
<td>long</td>
<td>int64</td>
<td>integer/string</td>
</tr>
<tr>
<td>fixed32</td>
<td>uint32</td>
<td>int</td>
<td>uint32</td>
<td>integer</td>
</tr>
<tr>
<td>fixed64</td>
<td>uint64</td>
<td>long</td>
<td>uint64</td>
<td>integer/string</td>
</tr>
<tr>
<td>sfixed32</td>
<td>int32</td>
<td>int</td>
<td>int32</td>
<td>integer</td>
</tr>
<tr>
<td>sfixed64</td>
<td>int64</td>
<td>long</td>
<td>int64</td>
<td>integer/string</td>
</tr>
<tr>
<td>bool</td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td>String</td>
<td>string</td>
<td>string</td>
</tr>
<tr>
<td>bytes</td>
<td>string</td>
<td>ByteString</td>
<td>[]byte</td>
<td>string</td>
</tr>
</tbody>
</table>
<h3 id="v2-和-v3-主要区别">v2 和 v3 主要区别</h3>
<ul>
<li>删除原始值字段的字段存在逻辑</li>
<li>删除 required 字段</li>
<li>删除 optional 字段，默认就是</li>
<li>删除 default 字段</li>
<li>删除扩展特性，新增 Any 类型来替代它</li>
<li>删除 unknown 字段的支持</li>
<li>新增 <a href="https://developers.google.com/protocol-buffers/docs/proto3#json">JSON Mapping</a></li>
<li>新增 Map 类型的支持</li>
<li>修复 enum 的 unknown 类型</li>
<li>repeated 默认使用 packed 编码</li>
<li>引入了新的语言实现（C＃，JavaScript，Ruby，Objective-C）</li>
</ul>
<p>以上是日常涉及的常见功能，如果还想详细了解可阅读 <a href="https://github.com/protocolbuffers/protobuf/releases?after=v3.2.1">Protobuf Version 3.0.0</a></p>
<h3 id="相较-protobuf为什么不使用-xml">相较 Protobuf，为什么不使用 XML？</h3>
<ul>
<li>更简单</li>
<li>数据描述文件只需原来的 1/10 至 1/3</li>
<li>解析速度是原来的 20 倍至 100 倍</li>
<li>减少了二义性</li>
<li>生成了更易使用的数据访问类</li>
</ul>
<h2 id="三grpc">三、gRPC</h2>
<h3 id="介绍-1">介绍</h3>
<p>gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计</p>
<h4 id="多语言">多语言</h4>
<ul>
<li>C++</li>
<li>C#</li>
<li>Dart</li>
<li>Go</li>
<li>Java</li>
<li>Node.js</li>
<li>Objective-C</li>
<li>PHP</li>
<li>Python</li>
<li>Ruby</li>
</ul>
<h4 id="特点">特点</h4>
<p>1、HTTP/2</p>
<p>2、Protobuf</p>
<p>3、客户端、服务端基于同一份 IDL</p>
<p>4、移动网络的良好支持</p>
<p>5、支持多语言</p>
<h3 id="概览">概览</h3>
<p><img src="https://image.eddycjy.com/7dcac5be0a34636c699025368242d3f3.png" alt="image"></p>
<h3 id="讲解">讲解</h3>
<p>1、客户端（gRPC Sub）调用 A 方法，发起 RPC 调用</p>
<p>2、对请求信息使用 Protobuf 进行对象序列化压缩（IDL）</p>
<p>3、服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理并返回</p>
<p>4、对响应结果使用 Protobuf 进行对象序列化压缩（IDL）</p>
<p>5、客户端接受到服务端响应，解码请求体。回调被调用的 A 方法，唤醒正在等待响应（阻塞）的客户端调用并返回响应结果</p>
<h3 id="示例">示例</h3>
<p>在这一小节，将简单的给大家展示 gRPC 的客户端和服务端的示例代码，希望大家先有一个基础的印象，将会在下一章节详细介绍 🤔</p>
<h4 id="构建和启动服务端">构建和启动服务端</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">lis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;:%d&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">port</span><span class="p">))</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;failed to listen: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">grpcServer</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">()</span>
<span class="o">...</span>
<span class="nx">pb</span><span class="p">.</span><span class="nf">RegisterSearchServer</span><span class="p">(</span><span class="nx">grpcServer</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">SearchServer</span><span class="p">{})</span>
<span class="nx">grpcServer</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">lis</span><span class="p">)</span>
</code></pre></div><p>1、监听指定 TCP 端口，用于接受客户端请求</p>
<p>2、创建 gRPC Server 的实例对象</p>
<p>3、gRPC Server 内部服务和路由的注册</p>
<p>4、Serve() 调用服务器以执行阻塞等待，直到进程被终止或被 Stop() 调用</p>
<h4 id="创建客户端">创建客户端</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">opts</span> <span class="p">[]</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">DialOption</span>
<span class="o">...</span>
<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="o">*</span><span class="nx">serverAddr</span><span class="p">,</span> <span class="nx">opts</span><span class="o">...</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;fail to dial: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="nx">client</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nf">NewSearchClient</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
<span class="o">...</span>
</code></pre></div><p>1、创建 gRPC Channel 与 gRPC Server 进行通信（需服务器地址和端口作为参数）</p>
<p>2、设置 DialOptions 凭证（例如，TLS，GCE 凭据，JWT 凭证）</p>
<p>3、创建 Search Client Stub</p>
<p>4、调用对应的服务方法</p>
<h2 id="思考题">思考题</h2>
<p>1、什么场景下不适合使用 Protobuf，而适合使用 JSON、XML？</p>
<p>2、Protobuf 一节中提到的 packed 编码，是什么？</p>
<h2 id="总结">总结</h2>
<p>在开篇内容中，我利用了尽量简短的描述给你介绍了接下来所必须、必要的知识点
希望你能够有所收获，建议能到我给的参考资料处进行深入学习，是最好的了</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://developers.google.com/protocol-buffers/docs/proto3">Protocol Buffers</a></li>
<li><a href="https://grpc.io/docs/">gRPC</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go 大杀器之性能剖析 PProf</title>
			<link>https://eddycjy.com/posts/go/tools/2018-09-15-go-tool-pprof/</link>
			<pubDate>Sat, 15 Sep 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/tools/2018-09-15-go-tool-pprof/</guid>
			<description>前言 写了几吨代码，实现了几百个接口。功能测试也通过了，终于成功的部署上线了
结果，性能不佳，什么鬼？😭
想做性能分析 PProf 想要进行性能优化，首先瞩目在 Go 自身提供的工具链来作为分析依据，本文将带你学习、使用 Go 后花园，涉及如下：
 runtime/pprof：采集程序（非 Server）的运行数据进行分析 net/http/pprof：采集 HTTP Server 的运行时数据进行分析  是什么 pprof 是用于可视化和分析性能分析数据的工具
pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）
profile.proto 是一个 Protocol Buffer v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式
支持什么使用模式  Report generation：报告生成 Interactive terminal use：交互式终端使用 Web interface：Web 界面  可以做什么  CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏 Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况  一个简单的例子 我们将编写一个简单且有点问题的例子，用于基本的程序初步分析
编写 demo 文件 （1）demo.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>写了几吨代码，实现了几百个接口。功能测试也通过了，终于成功的部署上线了</p>
<p>结果，性能不佳，什么鬼？😭</p>
<h2 id="想做性能分析">想做性能分析</h2>
<h3 id="pprof">PProf</h3>
<p>想要进行性能优化，首先瞩目在 Go 自身提供的工具链来作为分析依据，本文将带你学习、使用 Go 后花园，涉及如下：</p>
<ul>
<li>runtime/pprof：采集程序（非 Server）的运行数据进行分析</li>
<li>net/http/pprof：采集 HTTP Server 的运行时数据进行分析</li>
</ul>
<h3 id="是什么">是什么</h3>
<p>pprof 是用于可视化和分析性能分析数据的工具</p>
<p>pprof 以 <a href="https://github.com/google/pprof/blob/master/proto/profile.proto">profile.proto</a> 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）</p>
<p>profile.proto 是一个 Protocol Buffer v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式</p>
<h3 id="支持什么使用模式">支持什么使用模式</h3>
<ul>
<li>Report generation：报告生成</li>
<li>Interactive terminal use：交互式终端使用</li>
<li>Web interface：Web 界面</li>
</ul>
<h3 id="可以做什么">可以做什么</h3>
<ul>
<li>CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置</li>
<li>Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏</li>
<li>Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置</li>
<li>Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况</li>
</ul>
<h2 id="一个简单的例子">一个简单的例子</h2>
<p>我们将编写一个简单且有点问题的例子，用于基本的程序初步分析</p>
<h3 id="编写-demo-文件">编写 demo 文件</h3>
<p>（1）demo.go，文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="nx">_</span> <span class="s">&#34;net/http/pprof&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-pprof-example/data&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;https://github.com/EDDYCJY&#34;</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;0.0.0.0:6060&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>（2）data/d.go，文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">data</span>

<span class="kd">var</span> <span class="nx">datas</span> <span class="p">[]</span><span class="kt">string</span>

<span class="kd">func</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
	<span class="nx">sData</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">datas</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">datas</span><span class="p">,</span> <span class="nx">sData</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">sData</span>
<span class="p">}</span>

</code></pre></div><p>运行这个文件，你的 HTTP 服务会多出 /debug/pprof 的 endpoint 可用于观察应用程序的情况</p>
<h3 id="分析">分析</h3>
<h4 id="一通过-web-界面">一、通过 Web 界面</h4>
<p>查看当前总览：访问 <code>http://127.0.0.1:6060/debug/pprof/</code></p>
<pre><code>/debug/pprof/

profiles:
0	block
5	goroutine
3	heap
0	mutex
9	threadcreate

full goroutine stack dump
</code></pre><p>这个页面中有许多子页面，咱们继续深究下去，看看可以得到什么？</p>
<ul>
<li>cpu（CPU Profiling）: <code>$HOST/debug/pprof/profile</code>，默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件</li>
<li>block（Block Profiling）：<code>$HOST/debug/pprof/block</code>，查看导致阻塞同步的堆栈跟踪</li>
<li>goroutine：<code>$HOST/debug/pprof/goroutine</code>，查看当前所有运行的 goroutines 堆栈跟踪</li>
<li>heap（Memory Profiling）: <code>$HOST/debug/pprof/heap</code>，查看活动对象的内存分配情况</li>
<li>mutex（Mutex Profiling）：<code>$HOST/debug/pprof/mutex</code>，查看导致互斥锁的竞争持有者的堆栈跟踪</li>
<li>threadcreate：<code>$HOST/debug/pprof/threadcreate</code>，查看创建新 OS 线程的堆栈跟踪</li>
</ul>
<h4 id="二通过交互式终端使用">二、通过交互式终端使用</h4>
<p>（1）go tool pprof http://localhost:6060/debug/pprof/profile?seconds=60</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ go tool pprof http://localhost:6060/debug/pprof/profile<span class="se">\?</span>seconds<span class="se">\=</span><span class="m">60</span>

Fetching profile over HTTP from http://localhost:6060/debug/pprof/profile?seconds<span class="o">=</span><span class="m">60</span>
Saved profile in /Users/eddycjy/pprof/pprof.samples.cpu.007.pb.gz
Type: cpu
Duration: 1mins, Total <span class="nv">samples</span> <span class="o">=</span> 26.55s <span class="o">(</span>44.15%<span class="o">)</span>
Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
<span class="o">(</span>pprof<span class="o">)</span>
</code></pre></div><p>执行该命令后，需等待 60 秒（可调整 seconds 的值），pprof 会进行 CPU Profiling。结束后将默认进入 pprof 的交互式命令模式，可以对分析的结果进行查看或导出。具体可执行 <code>pprof help</code> 查看命令说明</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">(</span>pprof<span class="o">)</span> top10
Showing nodes accounting <span class="k">for</span> 25.92s, 97.63% of 26.55s total
Dropped <span class="m">85</span> nodes <span class="o">(</span>cum &lt;<span class="o">=</span> 0.13s<span class="o">)</span>
Showing top <span class="m">10</span> nodes out of <span class="m">21</span>
      flat  flat%   sum%        cum   cum%
    23.28s 87.68% 87.68%     23.29s 87.72%  syscall.Syscall
     0.77s  2.90% 90.58%      0.77s  2.90%  runtime.memmove
     0.58s  2.18% 92.77%      0.58s  2.18%  runtime.freedefer
     0.53s  2.00% 94.76%      1.42s  5.35%  runtime.scanobject
     0.36s  1.36% 96.12%      0.39s  1.47%  runtime.heapBitsForObject
     0.35s  1.32% 97.44%      0.45s  1.69%  runtime.greyobject
     0.02s 0.075% 97.51%     24.96s 94.01%  main.main.func1
     0.01s 0.038% 97.55%     23.91s 90.06%  os.<span class="o">(</span>*File<span class="o">)</span>.Write
     0.01s 0.038% 97.59%      0.19s  0.72%  runtime.mallocgc
     0.01s 0.038% 97.63%     23.30s 87.76%  syscall.Write
</code></pre></div><ul>
<li>flat：给定函数上运行耗时</li>
<li>flat%：同上的 CPU 运行耗时总比例</li>
<li>sum%：给定函数累积使用 CPU 总比例</li>
<li>cum：当前函数加上它之上的调用运行总耗时</li>
<li>cum%：同上的 CPU 运行耗时总比例</li>
</ul>
<p>最后一列为函数名称，在大多数的情况下，我们可以通过这五列得出一个应用程序的运行情况，加以优化 🤔</p>
<p>（2）go tool pprof http://localhost:6060/debug/pprof/heap</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ go tool pprof http://localhost:6060/debug/pprof/heap
Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap
Saved profile in /Users/eddycjy/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.008.pb.gz
Type: inuse_space
Entering interactive mode <span class="o">(</span><span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">for</span> commands, <span class="s2">&#34;o&#34;</span> <span class="k">for</span> options<span class="o">)</span>
<span class="o">(</span>pprof<span class="o">)</span> top
Showing nodes accounting <span class="k">for</span> 837.48MB, 100% of 837.48MB total
      flat  flat%   sum%        cum   cum%
  837.48MB   100%   100%   837.48MB   100%  main.main.func1
</code></pre></div><ul>
<li>
<p>-inuse_space：分析应用程序的常驻内存占用情况</p>
</li>
<li>
<p>-alloc_objects：分析应用程序的内存临时分配情况</p>
</li>
</ul>
<p>（3） go tool pprof http://localhost:6060/debug/pprof/block</p>
<p>（4） go tool pprof http://localhost:6060/debug/pprof/mutex</p>
<h4 id="三pprof-可视化界面">三、PProf 可视化界面</h4>
<p>这是令人期待的一小节。在这之前，我们需要简单的编写好测试用例来跑一下</p>
<h5 id="编写测试用例">编写测试用例</h5>
<p>（1）新建 data/d_test.go，文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">data</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">const</span> <span class="nx">url</span> <span class="p">=</span> <span class="s">&#34;https://github.com/EDDYCJY&#34;</span>

<span class="kd">func</span> <span class="nf">TestAdd</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Test.Add error!&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkAdd</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">Add</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>（2）执行测试用例</p>
<pre><code>$ go test -bench=. -cpuprofile=cpu.prof
pkg: github.com/EDDYCJY/go-pprof-example/data
BenchmarkAdd-4   	10000000	       187 ns/op
PASS
ok  	github.com/EDDYCJY/go-pprof-example/data	2.300s
</code></pre><p>-memprofile 也可以了解一下</p>
<h5 id="启动-pprof-可视化界面">启动 PProf 可视化界面</h5>
<h6 id="方法一">方法一：</h6>
<pre><code>$ go tool pprof -http=:8080 cpu.prof
</code></pre><h6 id="方法二">方法二：</h6>
<pre><code>$ go tool pprof cpu.prof
$ (pprof) web
</code></pre><p>如果出现 <code>Could not execute dot; may need to install graphviz.</code>，就是提示你要安装 <code>graphviz</code> 了 （请右拐谷歌）</p>
<h5 id="查看-pprof-可视化界面">查看 PProf 可视化界面</h5>
<p>（1）Top</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xlsYD.jpg" alt="image"></p>
<p>（2）Graph</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xlgld.jpg" alt="image"></p>
<p>框越大，线越粗代表它占用的时间越大哦</p>
<p>（3）Peek</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xlROI.jpg" alt="image"></p>
<p>（4）Source</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xl4Tf.jpg" alt="image"></p>
<p>通过 PProf 的可视化界面，我们能够更方便、更直观的看到 Go 应用程序的调用链、使用情况等，并且在 View 菜单栏中，还支持如上多种方式的切换</p>
<p>你想想，在烦恼不知道什么问题的时候，能用这些辅助工具来检测问题，是不是瞬间效率翻倍了呢 👌</p>
<h4 id="四pprof-火焰图">四、PProf 火焰图</h4>
<p>另一种可视化数据的方法是火焰图，需手动安装原生 PProf 工具：</p>
<p>（1） 安装 PProf</p>
<pre><code>$ go get -u github.com/google/pprof
</code></pre><p>（2） 启动 PProf 可视化界面:</p>
<pre><code>$ pprof -http=:8080 cpu.prof
</code></pre><p>（3） 查看 PProf 可视化界面</p>
<p>打开 PProf 的可视化界面时，你会明显发现比官方工具链的 PProf 精致一些，并且多了 Flame Graph（火焰图）</p>
<p>它就是本次的目标之一，它的最大优点是动态的。调用顺序由上到下（A -&gt; B -&gt; C -&gt; D），每一块代表一个函数，越大代表占用 CPU 的时间更长。同时它也支持点击块深入进行分析！</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xlj00.jpg" alt="image"></p>
<h2 id="总结">总结</h2>
<p>在本章节，粗略地介绍了 Go 的性能利器 PProf。在特定的场景中，PProf 给定位、剖析问题带了极大的帮助</p>
<p>希望本文对你有所帮助，另外建议能够自己实际操作一遍，最好是可以深入琢磨一下，内含大量的用法、知识点 🤓</p>
<h2 id="思考题">思考题</h2>
<p>你很优秀的看到了最后，那么有两道简单的思考题，希望拓展你的思路</p>
<p>（1）flat 一定大于 cum 吗，为什么？什么场景下 cum 会比 flat 大？</p>
<p>（2）本章节的 demo 代码，有什么性能问题？怎么解决它？</p>
]]></content>
		</item>
		
		<item>
			<title>「连载十七」用Nginx部署Go应用</title>
			<link>https://eddycjy.com/posts/go/gin/2018-09-01-nginx/</link>
			<pubDate>Sat, 01 Sep 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-09-01-nginx/</guid>
			<description>知识点  Nginx。 反向代理。  本文目标 简单部署后端服务。
做什么 在本章节，我们将简单介绍 Nginx 以及使用 Nginx 来完成对 go-gin-example 的部署，会实现反向代理和简单负载均衡的功能。
Nginx 是什么 Nginx 是一个 Web Server，可以用作反向代理、负载均衡、邮件代理、TCP / UDP、HTTP 服务器等等，它拥有很多吸引人的特性，例如：
 以较低的内存占用率处理 10,000 多个并发连接（每 10k 非活动 HTTP 保持活动连接约 2.5 MB ） 静态服务器（处理静态文件） 正向、反向代理 负载均衡 通过 OpenSSL 对 TLS / SSL 与 SNI 和 OCSP 支持 FastCGI、SCGI、uWSGI 的支持 WebSockets、HTTP/1.1 的支持 Nginx + Lua  安装 请右拐谷歌或百度，安装好 Nginx 以备接下来的使用
简单讲解 常用命令  nginx：启动 Nginx nginx -s stop：立刻停止 Nginx 服务 nginx -s reload：重新加载配置文件 nginx -s quit：平滑停止 Nginx 服务 nginx -t：测试配置文件是否正确 nginx -v：显示 Nginx 版本信息 nginx -V：显示 Nginx 版本信息、编译器和配置参数的信息  涉及配置 1、 proxy_pass：配置反向代理的路径。需要注意的是如果 proxy_pass 的 url 最后为 /，则表示绝对路径。否则（不含变量下）表示相对路径，所有的路径都会被代理过去</description>
			<content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<ul>
<li>Nginx。</li>
<li>反向代理。</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>简单部署后端服务。</p>
<h2 id="做什么">做什么</h2>
<p>在本章节，我们将简单介绍 Nginx 以及使用 Nginx 来完成对 <a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a> 的部署，会实现反向代理和简单负载均衡的功能。</p>
<h2 id="nginx">Nginx</h2>
<h3 id="是什么">是什么</h3>
<p>Nginx 是一个 Web Server，可以用作反向代理、负载均衡、邮件代理、TCP / UDP、HTTP 服务器等等，它拥有很多吸引人的特性，例如：</p>
<ul>
<li>以较低的内存占用率处理 10,000 多个并发连接（每 10k 非活动 HTTP 保持活动连接约 2.5 MB ）</li>
<li>静态服务器（处理静态文件）</li>
<li>正向、反向代理</li>
<li>负载均衡</li>
<li>通过 OpenSSL 对 TLS / SSL 与 SNI 和 OCSP 支持</li>
<li>FastCGI、SCGI、uWSGI 的支持</li>
<li>WebSockets、HTTP/1.1 的支持</li>
<li>Nginx + Lua</li>
</ul>
<h3 id="安装">安装</h3>
<p>请右拐谷歌或百度，安装好 Nginx 以备接下来的使用</p>
<h3 id="简单讲解">简单讲解</h3>
<h4 id="常用命令">常用命令</h4>
<ul>
<li>nginx：启动 Nginx</li>
<li>nginx -s stop：立刻停止 Nginx 服务</li>
<li>nginx -s reload：重新加载配置文件</li>
<li>nginx -s quit：平滑停止 Nginx 服务</li>
<li>nginx -t：测试配置文件是否正确</li>
<li>nginx -v：显示 Nginx 版本信息</li>
<li>nginx -V：显示 Nginx 版本信息、编译器和配置参数的信息</li>
</ul>
<h4 id="涉及配置">涉及配置</h4>
<p>1、 proxy_pass：配置<strong>反向代理的路径</strong>。需要注意的是如果 proxy_pass 的 url 最后为
/，则表示绝对路径。否则（不含变量下）表示相对路径，所有的路径都会被代理过去</p>
<p>2、 upstream：配置<strong>负载均衡</strong>，upstream 默认是以轮询的方式进行负载，另外还支持<strong>四种模式</strong>，分别是：</p>
<p>（1）weight：权重，指定轮询的概率，weight 与访问概率成正比</p>
<p>（2）ip_hash：按照访问 IP 的 hash 结果值分配</p>
<p>（3）fair：按后端服务器响应时间进行分配，响应时间越短优先级别越高</p>
<p>（4）url_hash：按照访问 URL 的 hash 结果值分配</p>
<h2 id="部署">部署</h2>
<p>在这里需要对 nginx.conf 进行配置，如果你不知道对应的配置文件是哪个，可执行 <code>nginx -t</code> 看一下</p>
<pre><code>$ nginx -t
nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is ok
nginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful
</code></pre><p>显然，我的配置文件在 <code>/usr/local/etc/nginx/</code> 目录下，并且测试通过</p>
<h3 id="反向代理">反向代理</h3>
<p>反向代理是指以代理服务器来接受网络上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。（来自<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488?fr=aladdin">百科</a>）</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xlQe0.png" alt="image"></p>
<h4 id="配置-hosts">配置 hosts</h4>
<p>由于需要用本机作为演示，因此先把映射配上去，打开 <code>/etc/hosts</code>，增加内容：</p>
<pre><code>127.0.0.1       api.blog.com
</code></pre><h4 id="配置-nginxconf">配置 nginx.conf</h4>
<p>打开 nginx 的配置文件 nginx.conf（我的是 /usr/local/etc/nginx/nginx.conf），我们做了如下事情：</p>
<p>增加 server 片段的内容，设置 server_name 为 api.blog.com 并且监听 8081 端口，将所有路径转发到 <code>http://127.0.0.1:8000/</code> 下</p>
<pre><code>worker_processes  1;

events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       8081;
        server_name  api.blog.com;

        location / {
            proxy_pass http://127.0.0.1:8000/;
        }
    }
}
</code></pre><h4 id="验证">验证</h4>
<h5 id="启动-go-gin-example">启动 go-gin-example</h5>
<p>回到 <a href="github.com/EDDYCJY/go-gin-example">go-gin-example</a> 的项目下，执行 make，再运行 ./go-gin-exmaple</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ make
github.com/EDDYCJY/go-gin-example
$ ls
LICENSE        README.md      conf           go-gin-example middleware     pkg            runtime        vendor
Makefile       README_ZH.md   docs           main.go        models         routers        service
$ ./go-gin-example
...
<span class="o">[</span>GIN-debug<span class="o">]</span> DELETE /api/v1/articles/:id      --&gt; github.com/EDDYCJY/go-gin-example/routers/api/v1.DeleteArticle <span class="o">(</span><span class="m">4</span> handlers<span class="o">)</span>
<span class="o">[</span>GIN-debug<span class="o">]</span> POST   /api/v1/articles/poster/generate --&gt; github.com/EDDYCJY/go-gin-example/routers/api/v1.GenerateArticlePoster <span class="o">(</span><span class="m">4</span> handlers<span class="o">)</span>
Actual pid is <span class="m">14672</span>
</code></pre></div><h5 id="重启-nginx">重启 nginx</h5>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ nginx -t
nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is ok
nginx: configuration file /usr/local/etc/nginx/nginx.conf <span class="nb">test</span> is successful
$ nginx -s reload
</code></pre></div><h5 id="访问接口">访问接口</h5>
<p><img src="https://s2.ax1x.com/2020/02/15/1xlEFS.jpg" alt="image"></p>
<p>如此，就实现了一个简单的反向代理了，是不是很简单呢</p>
<h3 id="负载均衡">负载均衡</h3>
<p>负载均衡，英文名称为 Load Balance（常称 LB），其意思就是分摊到多个操作单元上进行执行（来自百科）</p>
<p>你能从运维口中经常听见，XXX 负载怎么突然那么高。 那么它到底是什么呢？</p>
<p>其背后一般有多台 server，系统会根据配置的策略（例如 Nginx 有提供四种选择）来进行动态调整，尽可能的达到各节点均衡，从而提高系统整体的吞吐量和快速响应</p>
<h4 id="如何演示">如何演示</h4>
<p>前提条件为多个后端服务，那么势必需要多个 <a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a>，为了演示我们可以启动多个端口，达到模拟的效果</p>
<p>为了便于演示，分别在启动前将 conf/app.ini 的应用端口修改为 8001 和 8002（也可以做成传入参数的模式），达到启动 2 个监听 8001 和 8002 的后端服务</p>
<h4 id="配置-nginxconf-1">配置 nginx.conf</h4>
<p>回到 nginx.conf 的老地方，增加负载均衡所需的配置。新增 upstream 节点，设置其对应的 2 个后端服务，最后修改了 proxy_pass 指向（格式为 http:// + upstream 的节点名称）</p>
<pre><code>worker_processes  1;

events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  65;

    upstream api.blog.com {
        server 127.0.0.1:8001;
        server 127.0.0.1:8002;
    }

    server {
        listen       8081;
        server_name  api.blog.com;

        location / {
            proxy_pass http://api.blog.com/;
        }
    }
}
</code></pre><h5 id="重启-nginx-1">重启 nginx</h5>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ nginx -t
nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is ok
nginx: configuration file /usr/local/etc/nginx/nginx.conf <span class="nb">test</span> is successful
$ nginx -s reload
</code></pre></div><h4 id="验证-1">验证</h4>
<p>再重复访问 <code>http://api.blog.com:8081/auth?username={USER_NAME}}&amp;password={PASSWORD}</code>，多访问几次便于查看效果</p>
<p>目前 Nginx 没有进行特殊配置，那么它是轮询策略，而 go-gin-example 默认开着 debug 模式，看看请求 log 就明白了</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xlZWQ.jpg" alt="image"></p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xlnQs.jpg" alt="image"></p>
<h2 id="总结">总结</h2>
<p>在本章节，希望您能够简单习得日常使用的 Web Server 背后都是一些什么逻辑，Nginx 是什么？反向代理？负载均衡？</p>
<p>怎么简单部署，知道了吧。</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「番外」请入门 Makefile</title>
			<link>https://eddycjy.com/posts/go/gin/2018-08-26-makefile/</link>
			<pubDate>Sun, 26 Aug 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-08-26-makefile/</guid>
			<description>知识点  写一个 Makefile  本文目标 含一定复杂度的软件工程，基本上都是先编译 A，再依赖 B，再编译 C&amp;hellip;，最后才执行构建。如果每次都人为编排，又或是每新来一个同事就问你项目 D 怎么构建、重新构建需要注意什么&amp;hellip;等等情况，岂不是要崩溃？
我们常常会在开源项目中发现 Makefile，你是否有过疑问？
本章节会简单介绍 Makefile 的使用方式，最后建议深入学习。
怎么解决 对于构建编排，Docker 有 Dockerfile ，在 Unix 中有神器 Make &amp;hellip;.
Make 是什么 Make 是一个构建自动化工具，会在当前目录下寻找 Makefile 或 makefile 文件。如果存在，会依据 Makefile 的构建规则去完成构建
当然了，实际上 Makefile 内都是你根据 make 语法规则，自己编写的特定 Shell 命令等
它是一个工具，规则也很简单。在支持的范围内，编译 A， 依赖 B，再编译 C，完全没问题
规则 Makefile 由多条规则组成，每条规则都以一个 target（目标）开头，后跟一个 : 冒号，冒号后是这一个目标的 prerequisites（前置条件）
紧接着新的一行，必须以一个 tab 作为开头，后面跟随 command（命令），也就是你希望这一个 target 所执行的构建命令
[target] ... : [prerequisites] ... &amp;lt;tab&amp;gt;[command] ... ...  target：一个目标代表一条规则，可以是一个或多个文件名。也可以是某个操作的名字（标签），称为伪目标（phony） prerequisites：前置条件，这一项是可选参数。通常是多个文件名、伪目标。它的作用是 target 是否需要重新构建的标准，如果前置条件不存在或有过更新（文件的最后一次修改时间）则认为 target 需要重新构建 command：构建这一个 target 的具体命令集  简单的例子 本文将以 go-gin-example 去编写 Makefile 文件，请跨入 make 的大门</description>
			<content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<ul>
<li>写一个 Makefile</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>含一定复杂度的软件工程，基本上都是先编译 A，再依赖 B，再编译 C&hellip;，最后才执行构建。如果每次都人为编排，又或是每新来一个同事就问你项目 D 怎么构建、重新构建需要注意什么&hellip;等等情况，岂不是要崩溃？</p>
<p>我们常常会在开源项目中发现 Makefile，你是否有过疑问？</p>
<p>本章节会简单介绍 Makefile 的使用方式，最后建议深入学习。</p>
<h2 id="怎么解决">怎么解决</h2>
<p>对于构建编排，Docker 有 Dockerfile ，在 Unix 中有神器 <a href="https://en.wikipedia.org/wiki/Make_%28software%29">Make</a> &hellip;.</p>
<h2 id="make">Make</h2>
<h3 id="是什么">是什么</h3>
<p>Make 是一个构建自动化工具，会在当前目录下寻找 Makefile 或 makefile 文件。如果存在，会依据 Makefile 的<strong>构建规则</strong>去完成构建</p>
<p>当然了，实际上 Makefile 内都是你根据 make 语法规则，自己编写的特定 Shell 命令等</p>
<p>它是一个工具，规则也很简单。在支持的范围内，编译 A， 依赖 B，再编译 C，完全没问题</p>
<h3 id="规则">规则</h3>
<p>Makefile 由多条规则组成，每条规则都以一个 target（目标）开头，后跟一个 : 冒号，冒号后是这一个目标的 prerequisites（前置条件）</p>
<p>紧接着新的一行，必须以一个 tab 作为开头，后面跟随 command（命令），也就是你希望这一个 target 所执行的构建命令</p>
<pre><code>[target] ... : [prerequisites] ...
&lt;tab&gt;[command]
    ...
    ...
</code></pre><ul>
<li>target：一个目标代表一条规则，可以是一个或多个文件名。也可以是某个操作的名字（标签），称为<strong>伪目标（phony）</strong></li>
<li>prerequisites：前置条件，这一项是<strong>可选参数</strong>。通常是多个文件名、伪目标。它的作用是 target 是否需要重新构建的标准，如果前置条件不存在或有过更新（文件的最后一次修改时间）则认为 target 需要重新构建</li>
<li>command：构建这一个 target 的具体命令集</li>
</ul>
<h3 id="简单的例子">简单的例子</h3>
<p>本文将以 <a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a> 去编写 Makefile 文件，请跨入 make 的大门</p>
<h4 id="分析">分析</h4>
<p>在编写 Makefile 前，需要先分析构建先后顺序、依赖项，需要解决的问题等</p>
<h4 id="编写">编写</h4>
<div class="highlight"><pre class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">.PHONY</span><span class="o">:</span> <span class="n">build</span> <span class="n">clean</span> <span class="n">tool</span> <span class="n">lint</span> <span class="n">help</span>

<span class="nf">all</span><span class="o">:</span> <span class="n">build</span>

<span class="nf">build</span><span class="o">:</span>
	go build -v .

<span class="nf">tool</span><span class="o">:</span>
	go tool vet . <span class="p">|&amp;</span> grep -v vendor<span class="p">;</span> <span class="nb">true</span>
	gofmt -w .

<span class="nf">lint</span><span class="o">:</span>
	golint ./...

<span class="nf">clean</span><span class="o">:</span>
	rm -rf go-gin-example
	go clean -i .

<span class="nf">help</span><span class="o">:</span>
	@echo <span class="s2">&#34;make: compile packages and dependencies&#34;</span>
	@echo <span class="s2">&#34;make tool: run specified go tool&#34;</span>
	@echo <span class="s2">&#34;make lint: golint ./...&#34;</span>
	@echo <span class="s2">&#34;make clean: remove object files and cached files&#34;</span>
</code></pre></div><p>1、在上述文件中，使用了 <code>.PHONY</code>，其作用是声明 build / clean / tool / lint / help 为<strong>伪目标</strong>，声明为伪目标会怎么样呢？</p>
<ul>
<li>
<p>声明为伪目标后：在执行对应的命令时，make 就不会去检查是否存在 build / clean / tool / lint / help 其对应的文件，而是每次都会运行标签对应的命令</p>
</li>
<li>
<p>若不声明：恰好存在对应的文件，则 make 将会认为 xx 文件已存在，没有重新构建的必要了</p>
</li>
</ul>
<p>2、这块比较简单，在命令行执行即可看见效果，实现了以下功能：</p>
<ol>
<li>make: make 就是 make all</li>
<li>make build: 编译当前项目的包和依赖项</li>
<li>make tool: 运行指定的 Go 工具集</li>
<li>make lint: golint 一下</li>
<li>make clean: 删除对象文件和缓存文件</li>
<li>make help: help</li>
</ol>
<h4 id="为什么会打印执行的命令">为什么会打印执行的命令</h4>
<p>如果你实际操作过，可能会有疑问。明明只是执行命令，为什么会打印到标准输出上了？</p>
<h5 id="原因">原因</h5>
<p>make 默认会打印每条命令，再执行。这个行为被定义为<strong>回声</strong></p>
<h5 id="解决">解决</h5>
<p>可以在对应命令前加上 @，可指定该命令不被打印到标准输出上</p>
<div class="highlight"><pre class="chroma"><code class="language-makefile" data-lang="makefile"><span class="nf">build</span><span class="o">:</span>
	@go build -v .
</code></pre></div><p>那么还有其他的特殊符号吗？有的，请课后去了解下 +、- 的用途 🤩</p>
<h2 id="小结">小结</h2>
<p>这是一篇比较简洁的文章，希望可以让您对 Makefile 有一个基本了解。</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「连载十六」在图片上绘制文字</title>
			<link>https://eddycjy.com/posts/go/gin/2018-07-07-font/</link>
			<pubDate>Sat, 07 Jul 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-07-07-font/</guid>
			<description>知识点  字体库使用 图片合成  本文目标 主要实现合并后的海报上绘制文字的功能（这个需求也是常见的很了），内容比较简单。
实现 这里使用的是 微软雅黑 的字体，请点击进行下载并存放到 runtime/fonts 目录下（字体文件占 16 MB 大小）
安装 $ go get -u github.com/golang/freetype 绘制文字 打开 service/article_service/article_poster.go 文件，增加绘制文字的业务逻辑，如下：
type DrawText struct { JPG draw.Image Merged *os.File Title string X0 int Y0 int Size0 float64 SubTitle string X1 int Y1 int Size1 float64 } func (a *ArticlePosterBg) DrawPoster(d *DrawText, fontName string) error { fontSource := setting.AppSetting.RuntimeRootPath + setting.AppSetting.FontSavePath + fontName fontSourceBytes, err := ioutil.</description>
			<content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<ul>
<li>字体库使用</li>
<li>图片合成</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>主要实现<strong>合并后的海报上绘制文字</strong>的功能（这个需求也是常见的很了），内容比较简单。</p>
<h2 id="实现">实现</h2>
<p>这里使用的是 <a href="https://github.com/EDDYCJY/go-gin-example/blob/master/runtime/fonts/msyhbd.ttc">微软雅黑</a> 的字体，请点击进行下载并<strong>存放到 runtime/fonts 目录</strong>下（字体文件占 16 MB 大小）</p>
<h3 id="安装">安装</h3>
<pre><code>$ go get -u github.com/golang/freetype
</code></pre><h3 id="绘制文字">绘制文字</h3>
<p>打开 service/article_service/article_poster.go 文件，增加绘制文字的业务逻辑，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">DrawText</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">JPG</span>    <span class="nx">draw</span><span class="p">.</span><span class="nx">Image</span>
	<span class="nx">Merged</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span>

	<span class="nx">Title</span> <span class="kt">string</span>
	<span class="nx">X0</span>    <span class="kt">int</span>
	<span class="nx">Y0</span>    <span class="kt">int</span>
	<span class="nx">Size0</span> <span class="kt">float64</span>

	<span class="nx">SubTitle</span> <span class="kt">string</span>
	<span class="nx">X1</span>       <span class="kt">int</span>
	<span class="nx">Y1</span>       <span class="kt">int</span>
	<span class="nx">Size1</span>    <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">ArticlePosterBg</span><span class="p">)</span> <span class="nf">DrawPoster</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">DrawText</span><span class="p">,</span> <span class="nx">fontName</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">fontSource</span> <span class="o">:=</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">RuntimeRootPath</span> <span class="o">+</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">FontSavePath</span> <span class="o">+</span> <span class="nx">fontName</span>
	<span class="nx">fontSourceBytes</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">fontSource</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">trueTypeFont</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">freetype</span><span class="p">.</span><span class="nf">ParseFont</span><span class="p">(</span><span class="nx">fontSourceBytes</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">fc</span> <span class="o">:=</span> <span class="nx">freetype</span><span class="p">.</span><span class="nf">NewContext</span><span class="p">()</span>
	<span class="nx">fc</span><span class="p">.</span><span class="nf">SetDPI</span><span class="p">(</span><span class="mi">72</span><span class="p">)</span>
	<span class="nx">fc</span><span class="p">.</span><span class="nf">SetFont</span><span class="p">(</span><span class="nx">trueTypeFont</span><span class="p">)</span>
	<span class="nx">fc</span><span class="p">.</span><span class="nf">SetFontSize</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Size0</span><span class="p">)</span>
	<span class="nx">fc</span><span class="p">.</span><span class="nf">SetClip</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">JPG</span><span class="p">.</span><span class="nf">Bounds</span><span class="p">())</span>
	<span class="nx">fc</span><span class="p">.</span><span class="nf">SetDst</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">JPG</span><span class="p">)</span>
	<span class="nx">fc</span><span class="p">.</span><span class="nf">SetSrc</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">Black</span><span class="p">)</span>

	<span class="nx">pt</span> <span class="o">:=</span> <span class="nx">freetype</span><span class="p">.</span><span class="nf">Pt</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">X0</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Y0</span><span class="p">)</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fc</span><span class="p">.</span><span class="nf">DrawString</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Title</span><span class="p">,</span> <span class="nx">pt</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">fc</span><span class="p">.</span><span class="nf">SetFontSize</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Size1</span><span class="p">)</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fc</span><span class="p">.</span><span class="nf">DrawString</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">SubTitle</span><span class="p">,</span> <span class="nx">freetype</span><span class="p">.</span><span class="nf">Pt</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">X1</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Y1</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">jpeg</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Merged</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">JPG</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>这里主要使用了 freetype 包，分别涉及如下细项：</p>
<p>1、freetype.NewContext：创建一个新的 Context，会对其设置一些默认值</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewContext</span><span class="p">()</span> <span class="o">*</span><span class="nx">Context</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Context</span><span class="p">{</span>
		<span class="nx">r</span><span class="p">:</span>        <span class="nx">raster</span><span class="p">.</span><span class="nf">NewRasterizer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="nx">fontSize</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
		<span class="nx">dpi</span><span class="p">:</span>      <span class="mi">72</span><span class="p">,</span>
		<span class="nx">scale</span><span class="p">:</span>    <span class="mi">12</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>2、fc.SetDPI：设置屏幕每英寸的分辨率</p>
<p>3、fc.SetFont：设置用于绘制文本的字体</p>
<p>4、fc.SetFontSize：以磅为单位设置字体大小</p>
<p>5、fc.SetClip：设置剪裁矩形以进行绘制</p>
<p>6、fc.SetDst：设置目标图像</p>
<p>7、fc.SetSrc：设置绘制操作的源图像，通常为 <a href="https://golang.org/pkg/image/#Uniform">image.Uniform</a></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
        <span class="c1">// Black is an opaque black uniform image.
</span><span class="c1"></span>        <span class="nx">Black</span> <span class="p">=</span> <span class="nf">NewUniform</span><span class="p">(</span><span class="nx">color</span><span class="p">.</span><span class="nx">Black</span><span class="p">)</span>
        <span class="c1">// White is an opaque white uniform image.
</span><span class="c1"></span>        <span class="nx">White</span> <span class="p">=</span> <span class="nf">NewUniform</span><span class="p">(</span><span class="nx">color</span><span class="p">.</span><span class="nx">White</span><span class="p">)</span>
        <span class="c1">// Transparent is a fully transparent uniform image.
</span><span class="c1"></span>        <span class="nx">Transparent</span> <span class="p">=</span> <span class="nf">NewUniform</span><span class="p">(</span><span class="nx">color</span><span class="p">.</span><span class="nx">Transparent</span><span class="p">)</span>
        <span class="c1">// Opaque is a fully opaque uniform image.
</span><span class="c1"></span>        <span class="nx">Opaque</span> <span class="p">=</span> <span class="nf">NewUniform</span><span class="p">(</span><span class="nx">color</span><span class="p">.</span><span class="nx">Opaque</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div><p>8、fc.DrawString：根据 Pt 的坐标值绘制给定的文本内容</p>
<h3 id="业务逻辑">业务逻辑</h3>
<p>打开 service/article_service/article_poster.go 方法，在 Generate 方法增加绘制文字的代码逻辑，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">ArticlePosterBg</span><span class="p">)</span> <span class="nf">Generate</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fullPath</span> <span class="o">:=</span> <span class="nx">qrcode</span><span class="p">.</span><span class="nf">GetQrCodeFullPath</span><span class="p">()</span>
	<span class="nx">fileName</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Qr</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">fullPath</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">a</span><span class="p">.</span><span class="nf">CheckMergedImage</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">...</span>

		<span class="nx">draw</span><span class="p">.</span><span class="nf">Draw</span><span class="p">(</span><span class="nx">jpg</span><span class="p">,</span> <span class="nx">jpg</span><span class="p">.</span><span class="nf">Bounds</span><span class="p">(),</span> <span class="nx">bgImage</span><span class="p">,</span> <span class="nx">bgImage</span><span class="p">.</span><span class="nf">Bounds</span><span class="p">().</span><span class="nx">Min</span><span class="p">,</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">Over</span><span class="p">)</span>
		<span class="nx">draw</span><span class="p">.</span><span class="nf">Draw</span><span class="p">(</span><span class="nx">jpg</span><span class="p">,</span> <span class="nx">jpg</span><span class="p">.</span><span class="nf">Bounds</span><span class="p">(),</span> <span class="nx">qrImage</span><span class="p">,</span> <span class="nx">qrImage</span><span class="p">.</span><span class="nf">Bounds</span><span class="p">().</span><span class="nx">Min</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nf">Pt</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Y</span><span class="p">)),</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">Over</span><span class="p">)</span>

		<span class="nx">err</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">DrawPoster</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">DrawText</span><span class="p">{</span>
			<span class="nx">JPG</span><span class="p">:</span>    <span class="nx">jpg</span><span class="p">,</span>
			<span class="nx">Merged</span><span class="p">:</span> <span class="nx">mergedF</span><span class="p">,</span>

			<span class="nx">Title</span><span class="p">:</span> <span class="s">&#34;Golang Gin 系列文章&#34;</span><span class="p">,</span>
			<span class="nx">X0</span><span class="p">:</span>    <span class="mi">80</span><span class="p">,</span>
			<span class="nx">Y0</span><span class="p">:</span>    <span class="mi">160</span><span class="p">,</span>
			<span class="nx">Size0</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>

			<span class="nx">SubTitle</span><span class="p">:</span> <span class="s">&#34;---煎鱼&#34;</span><span class="p">,</span>
			<span class="nx">X1</span><span class="p">:</span>       <span class="mi">320</span><span class="p">,</span>
			<span class="nx">Y1</span><span class="p">:</span>       <span class="mi">220</span><span class="p">,</span>
			<span class="nx">Size1</span><span class="p">:</span>    <span class="mi">36</span><span class="p">,</span>
		<span class="p">},</span> <span class="s">&#34;msyhbd.ttc&#34;</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">fileName</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h2 id="验证">验证</h2>
<p>访问生成文章海报的接口 <code>$HOST/api/v1/articles/poster/generate?token=$token</code>，检查其生成结果，如下图</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xKBTS.jpg" alt="image"></p>
<h2 id="总结">总结</h2>
<p>在本章节在 <a href="https://github.com/EDDYCJY/blog/blob/master/golang/gin/2018-07-04-Gin%E5%AE%9E%E8%B7%B5-%E8%BF%9E%E8%BD%BD%E5%8D%81%E4%BA%94-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81-%E5%90%88%E5%B9%B6%E6%B5%B7%E6%8A%A5.md">连载十五</a> 的基础上增加了绘制文字，在实现上并不困难，而这两块需求一般会同时出现，大家可以多加练习，了解里面的逻辑和其他 API 😁</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 02 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「连载十五」生成二维码、合并海报</title>
			<link>https://eddycjy.com/posts/go/gin/2018-07-05-image/</link>
			<pubDate>Thu, 05 Jul 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-07-05-image/</guid>
			<description>知识点  图片生成 二维码生成  本文目标 在文章的详情页中，我们常常会需要去宣传它，而目前最常见的就是发海报了，今天我们将实现如下功能：
  生成二维码
  合并海报（背景图 + 二维码）
  实现 首先，你需要在 App 配置项中增加二维码及其海报的存储路径，我们约定配置项名称为 QrCodeSavePath，值为 qrcode/，经过多节连载的你应该能够完成，若有不懂可参照 go-gin-example。
生成二维码 安装 $ go get -u github.com/boombuler/barcode 工具包 考虑生成二维码这一动作贴合工具包的定义，且有公用的可能性，新建 pkg/qrcode/qrcode.go 文件，写入内容：
package qrcode import ( &amp;#34;image/jpeg&amp;#34; &amp;#34;github.com/boombuler/barcode&amp;#34; &amp;#34;github.com/boombuler/barcode/qr&amp;#34; &amp;#34;github.com/EDDYCJY/go-gin-example/pkg/file&amp;#34; &amp;#34;github.com/EDDYCJY/go-gin-example/pkg/setting&amp;#34; &amp;#34;github.com/EDDYCJY/go-gin-example/pkg/util&amp;#34; ) type QrCode struct { URL string Width int Height int Ext string Level qr.ErrorCorrectionLevel Mode qr.Encoding } const ( EXT_JPG = &amp;#34;.jpg&amp;#34; ) func NewQrCode(url string, width, height int, level qr.</description>
			<content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<ul>
<li>图片生成</li>
<li>二维码生成</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>在文章的详情页中，我们常常会需要去宣传它，而目前最常见的就是发海报了，今天我们将实现如下功能：</p>
<ul>
<li>
<p>生成二维码</p>
</li>
<li>
<p>合并海报（背景图 + 二维码）</p>
</li>
</ul>
<h2 id="实现">实现</h2>
<p>首先，你需要在 App 配置项中增加二维码及其海报的存储路径，我们约定配置项名称为 <code>QrCodeSavePath</code>，值为 <code>qrcode/</code>，经过多节连载的你应该能够完成，若有不懂可参照 <a href="https://github.com/EDDYCJY/go-gin-example/blob/master/conf/app.ini#L14">go-gin-example</a>。</p>
<h2 id="生成二维码">生成二维码</h2>
<h3 id="安装">安装</h3>
<pre><code>$ go get -u github.com/boombuler/barcode
</code></pre><h3 id="工具包">工具包</h3>
<p>考虑生成二维码这一动作贴合工具包的定义，且有公用的可能性，新建 pkg/qrcode/qrcode.go 文件，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">qrcode</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;image/jpeg&#34;</span>

	<span class="s">&#34;github.com/boombuler/barcode&#34;</span>
	<span class="s">&#34;github.com/boombuler/barcode/qr&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/file&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/util&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">QrCode</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">URL</span>    <span class="kt">string</span>
	<span class="nx">Width</span>  <span class="kt">int</span>
	<span class="nx">Height</span> <span class="kt">int</span>
	<span class="nx">Ext</span>    <span class="kt">string</span>
	<span class="nx">Level</span>  <span class="nx">qr</span><span class="p">.</span><span class="nx">ErrorCorrectionLevel</span>
	<span class="nx">Mode</span>   <span class="nx">qr</span><span class="p">.</span><span class="nx">Encoding</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">EXT_JPG</span> <span class="p">=</span> <span class="s">&#34;.jpg&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">NewQrCode</span><span class="p">(</span><span class="nx">url</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">level</span> <span class="nx">qr</span><span class="p">.</span><span class="nx">ErrorCorrectionLevel</span><span class="p">,</span> <span class="nx">mode</span> <span class="nx">qr</span><span class="p">.</span><span class="nx">Encoding</span><span class="p">)</span> <span class="o">*</span><span class="nx">QrCode</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">QrCode</span><span class="p">{</span>
		<span class="nx">URL</span><span class="p">:</span>    <span class="nx">url</span><span class="p">,</span>
		<span class="nx">Width</span><span class="p">:</span>  <span class="nx">width</span><span class="p">,</span>
		<span class="nx">Height</span><span class="p">:</span> <span class="nx">height</span><span class="p">,</span>
		<span class="nx">Level</span><span class="p">:</span>  <span class="nx">level</span><span class="p">,</span>
		<span class="nx">Mode</span><span class="p">:</span>   <span class="nx">mode</span><span class="p">,</span>
		<span class="nx">Ext</span><span class="p">:</span>    <span class="nx">EXT_JPG</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetQrCodePath</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">QrCodeSavePath</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetQrCodeFullPath</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">RuntimeRootPath</span> <span class="o">+</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">QrCodeSavePath</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetQrCodeFullUrl</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">PrefixUrl</span> <span class="o">+</span> <span class="s">&#34;/&#34;</span> <span class="o">+</span> <span class="nf">GetQrCodePath</span><span class="p">()</span> <span class="o">+</span> <span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetQrCodeFileName</span><span class="p">(</span><span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">util</span><span class="p">.</span><span class="nf">EncodeMD5</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">QrCode</span><span class="p">)</span> <span class="nf">GetQrCodeExt</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Ext</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">QrCode</span><span class="p">)</span> <span class="nf">CheckEncode</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">src</span> <span class="o">:=</span> <span class="nx">path</span> <span class="o">+</span> <span class="nf">GetQrCodeFileName</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nf">GetQrCodeExt</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">file</span><span class="p">.</span><span class="nf">CheckNotExist</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">q</span> <span class="o">*</span><span class="nx">QrCode</span><span class="p">)</span> <span class="nf">Encode</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="o">:=</span> <span class="nf">GetQrCodeFileName</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nf">GetQrCodeExt</span><span class="p">()</span>
	<span class="nx">src</span> <span class="o">:=</span> <span class="nx">path</span> <span class="o">+</span> <span class="nx">name</span>
	<span class="k">if</span> <span class="nx">file</span><span class="p">.</span><span class="nf">CheckNotExist</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
		<span class="nx">code</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">qr</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Level</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Mode</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">code</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">barcode</span><span class="p">.</span><span class="nf">Scale</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Width</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Height</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">MustOpen</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

		<span class="nx">err</span> <span class="p">=</span> <span class="nx">jpeg</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">code</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>这里主要聚焦 <code>func (q *QrCode) Encode</code> 方法，做了如下事情：</p>
<ul>
<li>获取二维码生成路径</li>
<li>创建二维码</li>
<li>缩放二维码到指定大小</li>
<li>新建存放二维码图片的文件</li>
<li>将图像（二维码）以 JPEG 4：2：0 基线格式写入文件</li>
</ul>
<p>另外在 <code>jpeg.Encode(f, code, nil)</code> 中，第三个参数可设置其图像质量，默认值为 75</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// DefaultQuality is the default quality encoding parameter.
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">DefaultQuality</span> <span class="p">=</span> <span class="mi">75</span>

<span class="c1">// Options are the encoding parameters.
</span><span class="c1">// Quality ranges from 1 to 100 inclusive, higher is better.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Options</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Quality</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><h3 id="路由方法">路由方法</h3>
<p>1、第一步</p>
<p>在 routers/api/v1/article.go 新增 GenerateArticlePoster 方法用于接口开发</p>
<p>2、第二步</p>
<p>在 routers/router.go 的 apiv1 中新增 <code>apiv1.POST(&quot;/articles/poster/generate&quot;, v1.GenerateArticlePoster)</code> 路由</p>
<p>3、第三步</p>
<p>修改 GenerateArticlePoster 方法，编写对应的生成逻辑，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">QRCODE_URL</span> <span class="p">=</span> <span class="s">&#34;https://github.com/EDDYCJY/blog#gin%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">GenerateArticlePoster</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">appG</span> <span class="o">:=</span> <span class="nx">app</span><span class="p">.</span><span class="nx">Gin</span><span class="p">{</span><span class="nx">c</span><span class="p">}</span>
	<span class="nx">qrc</span> <span class="o">:=</span> <span class="nx">qrcode</span><span class="p">.</span><span class="nf">NewQrCode</span><span class="p">(</span><span class="nx">QRCODE_URL</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="nx">qr</span><span class="p">.</span><span class="nx">M</span><span class="p">,</span> <span class="nx">qr</span><span class="p">.</span><span class="nx">Auto</span><span class="p">)</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="nx">qrcode</span><span class="p">.</span><span class="nf">GetQrCodeFullPath</span><span class="p">()</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">qrc</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="验证">验证</h3>
<p>通过 POST 方法访问 <code>http://127.0.0.1:8000/api/v1/articles/poster/generate?token=$token</code>（注意 $token）</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xQmb6.jpg" alt="image"></p>
<p>通过检查两个点确定功能是否正常，如下：</p>
<p>1、访问结果是否 200</p>
<p>2、本地目录是否成功生成二维码图片</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xQCUU.jpg" alt="image"></p>
<h2 id="合并海报">合并海报</h2>
<p>在这一节，将实现二维码图片与背景图合并成新的一张图，可用于常见的宣传海报等业务场景</p>
<h3 id="背景图">背景图</h3>
<p><img src="https://s2.ax1x.com/2020/02/15/1xMXgs.jpg" alt="image"></p>
<p>将背景图另存为 runtime/qrcode/bg.jpg（实际应用，可存在 OSS 或其他地方）</p>
<h3 id="service-方法">service 方法</h3>
<p>打开 service/article_service 目录，新建 article_poster.go 文件，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">article_service</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;image&#34;</span>
	<span class="s">&#34;image/draw&#34;</span>
	<span class="s">&#34;image/jpeg&#34;</span>
	<span class="s">&#34;os&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/file&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/qrcode&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">ArticlePoster</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">PosterName</span> <span class="kt">string</span>
	<span class="o">*</span><span class="nx">Article</span>
	<span class="nx">Qr</span> <span class="o">*</span><span class="nx">qrcode</span><span class="p">.</span><span class="nx">QrCode</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewArticlePoster</span><span class="p">(</span><span class="nx">posterName</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">article</span> <span class="o">*</span><span class="nx">Article</span><span class="p">,</span> <span class="nx">qr</span> <span class="o">*</span><span class="nx">qrcode</span><span class="p">.</span><span class="nx">QrCode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ArticlePoster</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">ArticlePoster</span><span class="p">{</span>
		<span class="nx">PosterName</span><span class="p">:</span> <span class="nx">posterName</span><span class="p">,</span>
		<span class="nx">Article</span><span class="p">:</span>    <span class="nx">article</span><span class="p">,</span>
		<span class="nx">Qr</span><span class="p">:</span>         <span class="nx">qr</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetPosterFlag</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;poster&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">ArticlePoster</span><span class="p">)</span> <span class="nf">CheckMergedImage</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">file</span><span class="p">.</span><span class="nf">CheckNotExist</span><span class="p">(</span><span class="nx">path</span><span class="o">+</span><span class="nx">a</span><span class="p">.</span><span class="nx">PosterName</span><span class="p">)</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">ArticlePoster</span><span class="p">)</span> <span class="nf">OpenMergedImage</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">MustOpen</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">PosterName</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">f</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ArticlePosterBg</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="o">*</span><span class="nx">ArticlePoster</span>
	<span class="o">*</span><span class="nx">Rect</span>
	<span class="o">*</span><span class="nx">Pt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Rect</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">X0</span>   <span class="kt">int</span>
	<span class="nx">Y0</span>   <span class="kt">int</span>
	<span class="nx">X1</span>   <span class="kt">int</span>
	<span class="nx">Y1</span>   <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Pt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">X</span> <span class="kt">int</span>
	<span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewArticlePosterBg</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">ap</span> <span class="o">*</span><span class="nx">ArticlePoster</span><span class="p">,</span> <span class="nx">rect</span> <span class="o">*</span><span class="nx">Rect</span><span class="p">,</span> <span class="nx">pt</span> <span class="o">*</span><span class="nx">Pt</span><span class="p">)</span> <span class="o">*</span><span class="nx">ArticlePosterBg</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">ArticlePosterBg</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>          <span class="nx">name</span><span class="p">,</span>
		<span class="nx">ArticlePoster</span><span class="p">:</span> <span class="nx">ap</span><span class="p">,</span>
		<span class="nx">Rect</span><span class="p">:</span>          <span class="nx">rect</span><span class="p">,</span>
		<span class="nx">Pt</span><span class="p">:</span>            <span class="nx">pt</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">ArticlePosterBg</span><span class="p">)</span> <span class="nf">Generate</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fullPath</span> <span class="o">:=</span> <span class="nx">qrcode</span><span class="p">.</span><span class="nf">GetQrCodeFullPath</span><span class="p">()</span>
	<span class="nx">fileName</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Qr</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">fullPath</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">a</span><span class="p">.</span><span class="nf">CheckMergedImage</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">mergedF</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">OpenMergedImage</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">defer</span> <span class="nx">mergedF</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

		<span class="nx">bgF</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">MustOpen</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">defer</span> <span class="nx">bgF</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

		<span class="nx">qrF</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">MustOpen</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">defer</span> <span class="nx">qrF</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

		<span class="nx">bgImage</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">jpeg</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">bgF</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="nx">qrImage</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">jpeg</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">qrF</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">jpg</span> <span class="o">:=</span> <span class="nx">image</span><span class="p">.</span><span class="nf">NewRGBA</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nf">Rect</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Rect</span><span class="p">.</span><span class="nx">X0</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Rect</span><span class="p">.</span><span class="nx">Y0</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Rect</span><span class="p">.</span><span class="nx">X1</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Rect</span><span class="p">.</span><span class="nx">Y1</span><span class="p">))</span>

		<span class="nx">draw</span><span class="p">.</span><span class="nf">Draw</span><span class="p">(</span><span class="nx">jpg</span><span class="p">,</span> <span class="nx">jpg</span><span class="p">.</span><span class="nf">Bounds</span><span class="p">(),</span> <span class="nx">bgImage</span><span class="p">,</span> <span class="nx">bgImage</span><span class="p">.</span><span class="nf">Bounds</span><span class="p">().</span><span class="nx">Min</span><span class="p">,</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">Over</span><span class="p">)</span>
		<span class="nx">draw</span><span class="p">.</span><span class="nf">Draw</span><span class="p">(</span><span class="nx">jpg</span><span class="p">,</span> <span class="nx">jpg</span><span class="p">.</span><span class="nf">Bounds</span><span class="p">(),</span> <span class="nx">qrImage</span><span class="p">,</span> <span class="nx">qrImage</span><span class="p">.</span><span class="nf">Bounds</span><span class="p">().</span><span class="nx">Min</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nf">Pt</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Pt</span><span class="p">.</span><span class="nx">Y</span><span class="p">)),</span> <span class="nx">draw</span><span class="p">.</span><span class="nx">Over</span><span class="p">)</span>

		<span class="nx">jpeg</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">mergedF</span><span class="p">,</span> <span class="nx">jpg</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">fileName</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>这里重点留意 <code>func (a *ArticlePosterBg) Generate()</code> 方法，做了如下事情：</p>
<ul>
<li>获取二维码存储路径</li>
<li>生成二维码图像</li>
<li>检查合并后图像（指的是存放合并后的海报）是否存在</li>
<li>若不存在，则生成待合并的图像 mergedF</li>
<li>打开事先存放的背景图 bgF</li>
<li>打开生成的二维码图像 qrF</li>
<li>解码 bgF 和 qrF 返回 image.Image</li>
<li>创建一个新的 RGBA 图像</li>
<li>在 RGBA 图像上绘制 背景图（bgF）</li>
<li>在已绘制背景图的 RGBA 图像上，在指定 Point 上绘制二维码图像（qrF）</li>
<li>将绘制好的 RGBA 图像以 JPEG 4：2：0 基线格式写入合并后的图像文件（mergedF）</li>
</ul>
<h3 id="错误码">错误码</h3>
<p>新增 <a href="https://github.com/EDDYCJY/go-gin-example/blob/master/pkg/e/code.go#L27">错误码</a>，<a href="https://github.com/EDDYCJY/go-gin-example/blob/master/pkg/e/msg.go#L25">错误提示</a></p>
<h3 id="路由方法-1">路由方法</h3>
<p>打开 routers/api/v1/article.go 文件，修改 GenerateArticlePoster 方法，编写最终的业务逻辑（含生成二维码及合并海报），如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">QRCODE_URL</span> <span class="p">=</span> <span class="s">&#34;https://github.com/EDDYCJY/blog#gin%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">GenerateArticlePoster</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">appG</span> <span class="o">:=</span> <span class="nx">app</span><span class="p">.</span><span class="nx">Gin</span><span class="p">{</span><span class="nx">c</span><span class="p">}</span>
	<span class="nx">article</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">article_service</span><span class="p">.</span><span class="nx">Article</span><span class="p">{}</span>
	<span class="nx">qr</span> <span class="o">:=</span> <span class="nx">qrcode</span><span class="p">.</span><span class="nf">NewQrCode</span><span class="p">(</span><span class="nx">QRCODE_URL</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="nx">qr</span><span class="p">.</span><span class="nx">M</span><span class="p">,</span> <span class="nx">qr</span><span class="p">.</span><span class="nx">Auto</span><span class="p">)</span> <span class="c1">// 目前写死 gin 系列路径，可自行增加业务逻辑
</span><span class="c1"></span>	<span class="nx">posterName</span> <span class="o">:=</span> <span class="nx">article_service</span><span class="p">.</span><span class="nf">GetPosterFlag</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34;-&#34;</span> <span class="o">+</span> <span class="nx">qrcode</span><span class="p">.</span><span class="nf">GetQrCodeFileName</span><span class="p">(</span><span class="nx">qr</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span> <span class="o">+</span> <span class="nx">qr</span><span class="p">.</span><span class="nf">GetQrCodeExt</span><span class="p">()</span>
	<span class="nx">articlePoster</span> <span class="o">:=</span> <span class="nx">article_service</span><span class="p">.</span><span class="nf">NewArticlePoster</span><span class="p">(</span><span class="nx">posterName</span><span class="p">,</span> <span class="nx">article</span><span class="p">,</span> <span class="nx">qr</span><span class="p">)</span>
	<span class="nx">articlePosterBgService</span> <span class="o">:=</span> <span class="nx">article_service</span><span class="p">.</span><span class="nf">NewArticlePosterBg</span><span class="p">(</span>
		<span class="s">&#34;bg.jpg&#34;</span><span class="p">,</span>
		<span class="nx">articlePoster</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="nx">article_service</span><span class="p">.</span><span class="nx">Rect</span><span class="p">{</span>
			<span class="nx">X0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="nx">Y0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="nx">X1</span><span class="p">:</span> <span class="mi">550</span><span class="p">,</span>
			<span class="nx">Y1</span><span class="p">:</span> <span class="mi">700</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="o">&amp;</span><span class="nx">article_service</span><span class="p">.</span><span class="nx">Pt</span><span class="p">{</span>
			<span class="nx">X</span><span class="p">:</span> <span class="mi">125</span><span class="p">,</span>
			<span class="nx">Y</span><span class="p">:</span> <span class="mi">298</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">)</span>

	<span class="nx">_</span><span class="p">,</span> <span class="nx">filePath</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">articlePosterBgService</span><span class="p">.</span><span class="nf">Generate</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_GEN_ARTICLE_POSTER_FAIL</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
		<span class="s">&#34;poster_url&#34;</span><span class="p">:</span>      <span class="nx">qrcode</span><span class="p">.</span><span class="nf">GetQrCodeFullUrl</span><span class="p">(</span><span class="nx">posterName</span><span class="p">),</span>
		<span class="s">&#34;poster_save_url&#34;</span><span class="p">:</span> <span class="nx">filePath</span> <span class="o">+</span> <span class="nx">posterName</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>这块涉及到大量知识，强烈建议阅读下，如下：</p>
<ul>
<li><a href="https://golang.org/pkg/image/#Rect">image.Rect</a></li>
<li><a href="https://golang.org/pkg/image/#Pt">image.Pt</a></li>
<li><a href="https://golang.org/pkg/image/#NewRGBA">image.NewRGBA</a></li>
<li><a href="https://golang.org/pkg/image/jpeg/#Encode">jpeg.Encode</a></li>
<li><a href="https://golang.org/pkg/image/jpeg/#Decode">jpeg.Decode</a></li>
<li><a href="https://golang.org/pkg/image/draw/#Op">draw.Op</a></li>
<li><a href="https://golang.org/pkg/image/draw/#Draw">draw.Draw</a></li>
<li><a href="https://blog.golang.org/go-imagedraw-package">go-imagedraw-package</a></li>
</ul>
<p>其所涉及、关联的库都建议研究一下</p>
<h3 id="staticfs">StaticFS</h3>
<p>在 routers/router.go 文件，增加如下代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span><span class="p">.</span><span class="nf">StaticFS</span><span class="p">(</span><span class="s">&#34;/qrcode&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="nx">qrcode</span><span class="p">.</span><span class="nf">GetQrCodeFullPath</span><span class="p">()))</span>
</code></pre></div><h3 id="验证-1">验证</h3>
<p><img src="https://s2.ax1x.com/2020/02/15/1xMLCQ.jpg" alt="image"></p>
<p>访问完整的 URL 路径，返回合成后的海报并扫除二维码成功则正确 🤓</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xMhjI.jpg" alt="image"></p>
<h2 id="总结">总结</h2>
<p>在本章节实现了两个很常见的业务功能，分别是生成二维码和合并海报。希望你能够仔细阅读我给出的链接，这块的知识量不少，想要用好图像处理的功能，必须理解对应的思路，举一反三</p>
<p>最后希望对你有所帮助 👌</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 02 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「连载十四」实现导出、导入 Excel</title>
			<link>https://eddycjy.com/posts/go/gin/2018-06-14-excel/</link>
			<pubDate>Thu, 14 Jun 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-06-14-excel/</guid>
			<description>知识点  导出功能的实现  本文目标 在本节，我们将实现对标签信息的导出、导入功能，这是很标配功能了，希望你掌握基础的使用方式。
另外在本文我们使用了 2 个 Excel 的包，excelize 最初的 XML 格式文件的一些结构，是通过 tealeg/xlsx 格式文件结构演化而来的，因此特意在此都展示了，你可以根据自己的场景和喜爱去使用。
配置 首先要指定导出的 Excel 文件的存储路径，在 app.ini 中增加配置：
[app] ... ExportSavePath = export/ 修改 setting.go 的 App struct：
type App struct { JwtSecret string PageSize int PrefixUrl string RuntimeRootPath string ImageSavePath string ImageMaxSize int ImageAllowExts []string ExportSavePath string LogSavePath string LogSaveName string LogFileExt string TimeFormat string } 在这里需增加 ExportSavePath 配置项，另外将先前 ImagePrefixUrl 改为 PrefixUrl 用于支撑两者的 HOST 获取</description>
			<content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<ul>
<li>导出功能的实现</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>在本节，我们将实现对标签信息的导出、导入功能，这是很标配功能了，希望你掌握基础的使用方式。</p>
<p>另外在本文我们使用了 2 个 Excel 的包，excelize 最初的 XML 格式文件的一些结构，是通过 tealeg/xlsx 格式文件结构演化而来的，因此特意在此都展示了，你可以根据自己的场景和喜爱去使用。</p>
<h2 id="配置">配置</h2>
<p>首先要指定导出的 Excel 文件的存储路径，在 app.ini 中增加配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="k">[app]</span>
<span class="na">...</span>

<span class="na">ExportSavePath</span> <span class="o">=</span> <span class="s">export/</span>
</code></pre></div><p>修改 setting.go 的 App struct：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">App</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">JwtSecret</span>       <span class="kt">string</span>
	<span class="nx">PageSize</span>        <span class="kt">int</span>
	<span class="nx">PrefixUrl</span>       <span class="kt">string</span>

	<span class="nx">RuntimeRootPath</span> <span class="kt">string</span>

	<span class="nx">ImageSavePath</span>  <span class="kt">string</span>
	<span class="nx">ImageMaxSize</span>   <span class="kt">int</span>
	<span class="nx">ImageAllowExts</span> <span class="p">[]</span><span class="kt">string</span>

	<span class="nx">ExportSavePath</span> <span class="kt">string</span>

	<span class="nx">LogSavePath</span> <span class="kt">string</span>
	<span class="nx">LogSaveName</span> <span class="kt">string</span>
	<span class="nx">LogFileExt</span>  <span class="kt">string</span>
	<span class="nx">TimeFormat</span>  <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div><p>在这里需增加 ExportSavePath 配置项，另外将先前 ImagePrefixUrl 改为 PrefixUrl 用于支撑两者的 HOST 获取</p>
<p>（注意修改 image.go 的 GetImageFullUrl 方法）</p>
<h2 id="pkg">pkg</h2>
<p>新建 pkg/export/excel.go 文件，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">export</span>

<span class="kn">import</span> <span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>

<span class="kd">func</span> <span class="nf">GetExcelFullUrl</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">PrefixUrl</span> <span class="o">+</span> <span class="s">&#34;/&#34;</span> <span class="o">+</span> <span class="nf">GetExcelPath</span><span class="p">()</span> <span class="o">+</span> <span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetExcelPath</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">ExportSavePath</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetExcelFullPath</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">RuntimeRootPath</span> <span class="o">+</span> <span class="nf">GetExcelPath</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>这里编写了一些常用的方法，以后取值方式如果有变动，直接改内部代码即可，对外不可见</p>
<h2 id="尝试一下标准库">尝试一下标准库</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">export</span><span class="p">.</span><span class="nf">GetExcelFullPath</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34;test.csv&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

<span class="nx">f</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="s">&#34;\xEF\xBB\xBF&#34;</span><span class="p">)</span>

<span class="nx">w</span> <span class="o">:=</span> <span class="nx">csv</span><span class="p">.</span><span class="nf">NewWriter</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="nx">data</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">{</span>
	<span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;test1&#34;</span><span class="p">,</span> <span class="s">&#34;test1-1&#34;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&#34;2&#34;</span><span class="p">,</span> <span class="s">&#34;test2&#34;</span><span class="p">,</span> <span class="s">&#34;test2-1&#34;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&#34;3&#34;</span><span class="p">,</span> <span class="s">&#34;test3&#34;</span><span class="p">,</span> <span class="s">&#34;test3-1&#34;</span><span class="p">},</span>
<span class="p">}</span>

<span class="nx">w</span><span class="p">.</span><span class="nf">WriteAll</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</code></pre></div><p>在 Go 提供的标准库 encoding/csv 中，天然的支持 csv 文件的读取和处理，在本段代码中，做了如下工作：</p>
<p>1、os.Create：</p>
<p>创建了一个 test.csv 文件</p>
<p>2、f.WriteString(&quot;\xEF\xBB\xBF&rdquo;)：</p>
<p><code>\xEF\xBB\xBF</code> 是 UTF-8 BOM 的 16 进制格式，在这里的用处是标识文件的编码格式，通常会出现在文件的开头，因此第一步就要将其写入。如果不标识 UTF-8 的编码格式的话，写入的汉字会显示为乱码</p>
<p>3、csv.NewWriter：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewWriter</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="o">*</span><span class="nx">Writer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Writer</span><span class="p">{</span>
		<span class="nx">Comma</span><span class="p">:</span> <span class="sc">&#39;,&#39;</span><span class="p">,</span>
		<span class="nx">w</span><span class="p">:</span>     <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewWriter</span><span class="p">(</span><span class="nx">w</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>4、w.WriteAll：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">Writer</span><span class="p">)</span> <span class="nf">WriteAll</span><span class="p">(</span><span class="nx">records</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">record</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">records</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">record</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nx">w</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>WriteAll 实际是对 Write 的封装，需要注意在最后调用了 <code>w.w.Flush()</code>，这充分了说明了 WriteAll 的使用场景，你可以想想作者的设计用意</p>
<h2 id="导出">导出</h2>
<h3 id="service-方法">Service 方法</h3>
<p>打开 service/tag.go，增加 Export 方法，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Tag</span><span class="p">)</span> <span class="nf">Export</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tags</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">GetAll</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">file</span> <span class="o">:=</span> <span class="nx">xlsx</span><span class="p">.</span><span class="nf">NewFile</span><span class="p">()</span>
	<span class="nx">sheet</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">AddSheet</span><span class="p">(</span><span class="s">&#34;标签信息&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">titles</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;ID&#34;</span><span class="p">,</span> <span class="s">&#34;名称&#34;</span><span class="p">,</span> <span class="s">&#34;创建人&#34;</span><span class="p">,</span> <span class="s">&#34;创建时间&#34;</span><span class="p">,</span> <span class="s">&#34;修改人&#34;</span><span class="p">,</span> <span class="s">&#34;修改时间&#34;</span><span class="p">}</span>
	<span class="nx">row</span> <span class="o">:=</span> <span class="nx">sheet</span><span class="p">.</span><span class="nf">AddRow</span><span class="p">()</span>

	<span class="kd">var</span> <span class="nx">cell</span> <span class="o">*</span><span class="nx">xlsx</span><span class="p">.</span><span class="nx">Cell</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">title</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">titles</span> <span class="p">{</span>
		<span class="nx">cell</span> <span class="p">=</span> <span class="nx">row</span><span class="p">.</span><span class="nf">AddCell</span><span class="p">()</span>
		<span class="nx">cell</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">title</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tags</span> <span class="p">{</span>
		<span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
			<span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">ID</span><span class="p">),</span>
			<span class="nx">v</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span>
			<span class="nx">v</span><span class="p">.</span><span class="nx">CreatedBy</span><span class="p">,</span>
			<span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">CreatedOn</span><span class="p">),</span>
			<span class="nx">v</span><span class="p">.</span><span class="nx">ModifiedBy</span><span class="p">,</span>
			<span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">ModifiedOn</span><span class="p">),</span>
		<span class="p">}</span>

		<span class="nx">row</span> <span class="p">=</span> <span class="nx">sheet</span><span class="p">.</span><span class="nf">AddRow</span><span class="p">()</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span>
			<span class="nx">cell</span> <span class="p">=</span> <span class="nx">row</span><span class="p">.</span><span class="nf">AddCell</span><span class="p">()</span>
			<span class="nx">cell</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">value</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">time</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()))</span>
	<span class="nx">filename</span> <span class="o">:=</span> <span class="s">&#34;tags-&#34;</span> <span class="o">+</span> <span class="nx">time</span> <span class="o">+</span> <span class="s">&#34;.xlsx&#34;</span>

	<span class="nx">fullPath</span> <span class="o">:=</span> <span class="nx">export</span><span class="p">.</span><span class="nf">GetExcelFullPath</span><span class="p">()</span> <span class="o">+</span> <span class="nx">filename</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="nx">fullPath</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">filename</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h2 id="routers-入口">routers 入口</h2>
<p>打开 routers/api/v1/tag.go，增加如下方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ExportTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">appG</span> <span class="o">:=</span> <span class="nx">app</span><span class="p">.</span><span class="nx">Gin</span><span class="p">{</span><span class="nx">C</span><span class="p">:</span> <span class="nx">c</span><span class="p">}</span>
	<span class="nx">name</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span>
	<span class="nx">state</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="k">if</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">PostForm</span><span class="p">(</span><span class="s">&#34;state&#34;</span><span class="p">);</span> <span class="nx">arg</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">state</span> <span class="p">=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">arg</span><span class="p">).</span><span class="nf">MustInt</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">tagService</span> <span class="o">:=</span> <span class="nx">tag_service</span><span class="p">.</span><span class="nx">Tag</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="nx">name</span><span class="p">,</span>
		<span class="nx">State</span><span class="p">:</span> <span class="nx">state</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">filename</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tagService</span><span class="p">.</span><span class="nf">Export</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_EXPORT_TAG_FAIL</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
		<span class="s">&#34;export_url&#34;</span><span class="p">:</span>      <span class="nx">export</span><span class="p">.</span><span class="nf">GetExcelFullUrl</span><span class="p">(</span><span class="nx">filename</span><span class="p">),</span>
		<span class="s">&#34;export_save_url&#34;</span><span class="p">:</span> <span class="nx">export</span><span class="p">.</span><span class="nf">GetExcelPath</span><span class="p">()</span> <span class="o">+</span> <span class="nx">filename</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><h3 id="路由">路由</h3>
<p>在 routers/router.go 文件中增加路由方法，如下</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">apiv1</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/api/v1&#34;</span><span class="p">)</span>
<span class="nx">apiv1</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">jwt</span><span class="p">.</span><span class="nf">JWT</span><span class="p">())</span>
<span class="p">{</span>
	<span class="o">...</span>
	<span class="c1">//导出标签
</span><span class="c1"></span>	<span class="nx">r</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/tags/export&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">ExportTag</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="验证接口">验证接口</h3>
<p>访问 <code>http://127.0.0.1:8000/tags/export</code>，结果如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;code&#34;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
  <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;export_save_url&#34;</span><span class="p">:</span> <span class="s2">&#34;export/tags-1528903393.xlsx&#34;</span><span class="p">,</span>
    <span class="nt">&#34;export_url&#34;</span><span class="p">:</span> <span class="s2">&#34;http://127.0.0.1:8000/export/tags-1528903393.xlsx&#34;</span>
  <span class="p">},</span>
  <span class="nt">&#34;msg&#34;</span><span class="p">:</span> <span class="s2">&#34;ok&#34;</span>
<span class="p">}</span>
</code></pre></div><p>最终通过接口返回了导出文件的地址和保存地址</p>
<h3 id="staticfs">StaticFS</h3>
<p>那你想想，现在直接访问地址肯定是无法下载文件的，那么该如何做呢？</p>
<p>打开 router.go 文件，增加代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span><span class="p">.</span><span class="nf">StaticFS</span><span class="p">(</span><span class="s">&#34;/export&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="nx">export</span><span class="p">.</span><span class="nf">GetExcelFullPath</span><span class="p">()))</span>
</code></pre></div><p>若你不理解，强烈建议温习下前面的章节，举一反三</p>
<h2 id="验证下载">验证下载</h2>
<p>再次访问上面的 export_url ，如：<code>http://127.0.0.1:8000/export/tags-1528903393.xlsx</code>，是不是成功了呢？</p>
<h2 id="导入">导入</h2>
<h3 id="service-方法-1">Service 方法</h3>
<p>打开 service/tag.go，增加 Import 方法，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Tag</span><span class="p">)</span> <span class="nf">Import</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">xlsx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">excelize</span><span class="p">.</span><span class="nf">OpenReader</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">rows</span> <span class="o">:=</span> <span class="nx">xlsx</span><span class="p">.</span><span class="nf">GetRows</span><span class="p">(</span><span class="s">&#34;标签信息&#34;</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">irow</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rows</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">irow</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">string</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">cell</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">row</span> <span class="p">{</span>
				<span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">cell</span><span class="p">)</span>
			<span class="p">}</span>

			<span class="nx">models</span><span class="p">.</span><span class="nf">AddTag</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h2 id="routers-入口-1">routers 入口</h2>
<p>打开 routers/api/v1/tag.go，增加如下方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ImportTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">appG</span> <span class="o">:=</span> <span class="nx">app</span><span class="p">.</span><span class="nx">Gin</span><span class="p">{</span><span class="nx">C</span><span class="p">:</span> <span class="nx">c</span><span class="p">}</span>

	<span class="nx">file</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">FormFile</span><span class="p">(</span><span class="s">&#34;file&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">logging</span><span class="p">.</span><span class="nf">Warn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">tagService</span> <span class="o">:=</span> <span class="nx">tag_service</span><span class="p">.</span><span class="nx">Tag</span><span class="p">{}</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">tagService</span><span class="p">.</span><span class="nf">Import</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">logging</span><span class="p">.</span><span class="nf">Warn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_IMPORT_TAG_FAIL</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="路由-1">路由</h3>
<p>在 routers/router.go 文件中增加路由方法，如下</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">apiv1</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/api/v1&#34;</span><span class="p">)</span>
<span class="nx">apiv1</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">jwt</span><span class="p">.</span><span class="nf">JWT</span><span class="p">())</span>
<span class="p">{</span>
	<span class="o">...</span>
	<span class="c1">//导入标签
</span><span class="c1"></span>	<span class="nx">r</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/tags/import&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">ImportTag</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="验证">验证</h3>
<p><img src="https://s2.ax1x.com/2020/02/15/1xKtSA.jpg" alt="image"></p>
<p>在这里我们将先前导出的 Excel 文件作为入参，访问 <code>http://127.0.0.01:8000/tags/import</code>，检查返回和数据是否正确入库</p>
<h2 id="总结">总结</h2>
<p>在本文中，简单介绍了 Excel 的导入、导出的使用方式，使用了以下 2 个包：</p>
<ul>
<li><a href="https://github.com/tealeg/xlsx">tealeg/xlsx</a></li>
<li><a href="https://github.com/360EntSecGroup-Skylar/excelize">360EntSecGroup-Skylar/excelize</a></li>
</ul>
<p>你可以细细阅读一下它的实现和使用方式，对你的把控更有帮助 🤔</p>
<h2 id="课外">课外</h2>
<ul>
<li>tag：导出使用 excelize 的方式去实现（可能你会发现更简单哦）</li>
<li>tag：导入去重功能实现</li>
<li>artice ：导入、导出功能实现</li>
</ul>
<p>也不失为你很好的练手机会，如果有兴趣，可以试试</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 02 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>用 Go 来了解一下 Redis 通讯协议</title>
			<link>https://eddycjy.com/posts/go/talk/2018-06-07-go-redis-protocol/</link>
			<pubDate>Thu, 07 Jun 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2018-06-07-go-redis-protocol/</guid>
			<description>Go、PHP、Java&amp;hellip; 都有那么多包来支撑你使用 Redis，那你是否有想过
有了服务端，有了客户端，他们俩是怎样通讯，又是基于什么通讯协议做出交互的呢？
介绍 基于我们的目的，本文主要讲解和实践 Redis 的通讯协议
Redis 的客户端和服务端是通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379
客户端和服务器发送的命令或数据一律以 \r\n （CRLF）结尾（这是一条约定）
协议 在 Redis 中分为请求和回复，而请求协议又分为新版和旧版，新版统一请求协议在 Redis 1.2 版本中引入，最终在 Redis 2.0 版本成为 Redis 服务器通信的标准方式
本文是基于新版协议来实现功能，不建议使用旧版（1.2 挺老旧了）。如下是新协议的各种范例：
请求协议 1、 格式示例
*&amp;lt;参数数量&amp;gt; CR LF $&amp;lt;参数 1 的字节数量&amp;gt; CR LF &amp;lt;参数 1 的数据&amp;gt; CR LF ... $&amp;lt;参数 N 的字节数量&amp;gt; CR LF &amp;lt;参数 N 的数据&amp;gt; CR LF 在该协议下所有发送至 Redis 服务器的参数都是二进制安全（binary safe）的
2、打印示例
*3 $3 SET $5 mykey $7 myvalue 3、实际协议值</description>
			<content type="html"><![CDATA[<p>Go、PHP、Java&hellip; 都有那么多包来支撑你使用 Redis，那你是否有想过</p>
<p>有了服务端，有了客户端，他们俩是怎样通讯，又是基于什么通讯协议做出交互的呢？</p>
<h2 id="介绍">介绍</h2>
<p>基于我们的目的，本文主要讲解和实践 Redis 的通讯协议</p>
<p>Redis 的客户端和服务端是通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379</p>
<p>客户端和服务器发送的命令或数据一律以 \r\n （CRLF）结尾（这是一条约定）</p>
<h2 id="协议">协议</h2>
<p>在 Redis 中分为<strong>请求</strong>和<strong>回复</strong>，而请求协议又分为新版和旧版，新版统一请求协议在 Redis 1.2 版本中引入，最终在 Redis 2.0 版本成为 Redis 服务器通信的标准方式</p>
<p>本文是基于新版协议来实现功能，不建议使用旧版（1.2 挺老旧了）。如下是新协议的各种范例：</p>
<h3 id="请求协议">请求协议</h3>
<p>1、 格式示例</p>
<pre><code>*&lt;参数数量&gt; CR LF
$&lt;参数 1 的字节数量&gt; CR LF
&lt;参数 1 的数据&gt; CR LF
...
$&lt;参数 N 的字节数量&gt; CR LF
&lt;参数 N 的数据&gt; CR LF
</code></pre><p>在该协议下所有发送至 Redis 服务器的参数都是二进制安全（binary safe）的</p>
<p>2、打印示例</p>
<pre><code>*3
$3
SET
$5
mykey
$7
myvalue
</code></pre><p>3、实际协议值</p>
<pre><code>&quot;*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n&quot;
</code></pre><p>这就是 Redis 的请求协议规范，按照范例1编写客户端逻辑，最终发送的是范例3，相信你已经有大致的概念了，Redis 的协议非常的简洁易懂，这也是好上手的原因之一，你可以想想协议这么定义的好处在哪？</p>
<h3 id="回复">回复</h3>
<p>Redis 会根据你请求协议的不同（执行的命令结果也不同），返回多种不同类型的回复。在这个回复“协议”中，可以通过检查第一个字节，确定这个回复是什么类型，如下：</p>
<ul>
<li>状态回复（status reply）的第一个字节是 &ldquo;+&rdquo;</li>
<li>错误回复（error reply）的第一个字节是 &ldquo;-&rdquo;</li>
<li>整数回复（integer reply）的第一个字节是 &ldquo;:&rdquo;</li>
<li>批量回复（bulk reply）的第一个字节是 &ldquo;$&rdquo;</li>
<li>多条批量回复（multi bulk reply）的第一个字节是 &ldquo;*&rdquo;</li>
</ul>
<p>有了回复的头部标识，结尾的 CRLF，你可以大致猜想出回复“协议”是怎么样的，但是实践才能得出真理，斎知道怕是你很快就忘记了 😀</p>
<h2 id="实践">实践</h2>
<h3 id="与-redis-服务器交互">与 Redis 服务器交互</h3>
<pre><code>package main

import (
	&quot;log&quot;
	&quot;net&quot;
	&quot;os&quot;

	&quot;github.com/EDDYCJY/redis-protocol-example/protocol&quot;
)

const (
	Address = &quot;127.0.0.1:6379&quot;
	Network = &quot;tcp&quot;
)

func Conn(network, address string) (net.Conn, error) {
	conn, err := net.Dial(network, address)
	if err != nil {
		return nil, err
	}

	return conn, nil
}

func main() {
        // 读取入参
	args := os.Args[1:]
	if len(args) &lt;= 0 {
		log.Fatalf(&quot;Os.Args &lt;= 0&quot;)
	}
    
        // 获取请求协议
	reqCommand := protocol.GetRequest(args)
	
	// 连接 Redis 服务器
	redisConn, err := Conn(Network, Address)
	if err != nil {
		log.Fatalf(&quot;Conn err: %v&quot;, err)
	}
	defer redisConn.Close()
    
        // 写入请求内容
	_, err = redisConn.Write(reqCommand)
	if err != nil {
		log.Fatalf(&quot;Conn Write err: %v&quot;, err)
	}
    
        // 读取回复
	command := make([]byte, 1024)
	n, err := redisConn.Read(command)
	if err != nil {
		log.Fatalf(&quot;Conn Read err: %v&quot;, err)
	}
    
        // 处理回复
	reply, err := protocol.GetReply(command[:n])
	if err != nil {
		log.Fatalf(&quot;protocol.GetReply err: %v&quot;, err)
	}
    
        // 处理后的回复内容
	log.Printf(&quot;Reply: %v&quot;, reply)
	// 原始的回复内容
	log.Printf(&quot;Command: %v&quot;, string(command[:n]))
}
</code></pre><p>在这里我们完成了整个 Redis 客户端和服务端交互的流程，分别如下：</p>
<p>1、读取命令行参数：获取执行的 Redis 命令</p>
<p>2、获取请求协议参数</p>
<p>3、连接 Redis 服务器，获取连接句柄</p>
<p>4、将请求协议参数写入连接：发送请求的命令行参数</p>
<p>5、从连接中读取返回的数据：读取先前请求的回复数据</p>
<p>6、根据回复“协议”内容，处理回复的数据集</p>
<p>7、输出处理后的回复内容及原始回复内容</p>
<h3 id="请求">请求</h3>
<pre><code>func GetRequest(args []string) []byte {
	req := []string{
		&quot;*&quot; + strconv.Itoa(len(args)),
	}

	for _, arg := range args {
		req = append(req, &quot;$&quot;+strconv.Itoa(len(arg)))
		req = append(req, arg)
	}

	str := strings.Join(req, &quot;\r\n&quot;)
	return []byte(str + &quot;\r\n&quot;)
}
</code></pre><p>通过对 Redis 的请求协议的分析，可得出它的规律，先加上标志位，计算参数总数量，再循环合并各个参数的字节数量、值就可以了</p>
<h3 id="回复-1">回复</h3>
<pre><code>func GetReply(reply []byte) (interface{}, error) {
	replyType := reply[0]
	switch replyType {
	case StatusReply:
		return doStatusReply(reply[1:])
	case ErrorReply:
		return doErrorReply(reply[1:])
	case IntegerReply:
		return doIntegerReply(reply[1:])
	case BulkReply:
		return doBulkReply(reply[1:])
	case MultiBulkReply:
		return doMultiBulkReply(reply[1:])
	default:
		return nil, nil
	}
}

func doStatusReply(reply []byte) (string, error) {
	if len(reply) == 3 &amp;&amp; reply[1] == 'O' &amp;&amp; reply[2] == 'K' {
		return OkReply, nil
	}

	if len(reply) == 5 &amp;&amp; reply[1] == 'P' &amp;&amp; reply[2] == 'O' &amp;&amp; reply[3] == 'N' &amp;&amp; reply[4] == 'G' {
		return PongReply, nil
	}

	return string(reply), nil
}

func doErrorReply(reply []byte) (string, error) {
	return string(reply), nil
}

func doIntegerReply(reply []byte) (int, error) {
	pos := getFlagPos('\r', reply)
	result, err := strconv.Atoi(string(reply[:pos]))
	if err != nil {
		return 0, err
	}

	return result, nil
}

...
</code></pre><p>在这里我们对所有回复类型进行了分发，不同的回复标志位对应不同的处理方式，在这里需求注意几项问题，如下：</p>
<p>1、当请求的值不存在，会将特殊值 -1 用作回复</p>
<p>2、服务器发送的所有字符串都由 CRLF 结尾</p>
<p>3、多条批量回复是可基于批量回复的，要注意理解</p>
<p>4、无内容的多条批量回复是存在的</p>
<p>最重要的是，对不同回复的规则的把控，能够让你更好的理解 Redis 的请求、回复的交互过程 👌</p>
<h2 id="小结">小结</h2>
<p>写这篇文章的起因，是因为常常在使用 Redis 时，只是用，你不知道它是基于什么样的通讯协议来通讯，这样的感觉是十分难受的</p>
<p>通过本文的讲解，我相信你已经大致了解 Redis 客户端是怎么样和服务端交互，也清楚了其所用的通讯原理，希望能够对你有所帮助！</p>
<p>最后，如果想详细查看代码，右拐项目地址：https://github.com/EDDYCJY/redis-protocol-example</p>
<p>如果对你有所帮助，欢迎点个 Star 👍</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://doc.redisfans.com/topic/protocol.html">通信协议</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载十三」优化你的应用结构和实现Redis缓存</title>
			<link>https://eddycjy.com/posts/go/gin/2018-06-02-application-redis/</link>
			<pubDate>Sat, 02 Jun 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-06-02-application-redis/</guid>
			<description>前言 之前就在想，不少教程或示例的代码设计都是一步到位的（也没问题）
但实际操作的读者真的能够理解透彻为什么吗？左思右想，有了今天这一章的内容，我认为实际经历过一遍印象会更加深刻
本文目标 在本章节，将介绍以下功能的整理：
 抽离、分层业务逻辑：减轻 routers.go 内的 api 方法的逻辑（但本文暂不分层 repository，这块逻辑还不重）。 增加容错性：对 gorm 的错误进行判断。 Redis 缓存：对获取数据类的接口增加缓存设置。 减少重复冗余代码。  问题在哪？ 在规划阶段我们发现了一个问题，这是目前的伪代码：
if ! HasErrors() { if ExistArticleByID(id) { DeleteArticle(id) code = e.SUCCESS } else { code = e.ERROR_NOT_EXIST_ARTICLE } } else { for _, err := range valid.Errors { logging.Info(err.Key, err.Message) } } c.JSON(http.StatusOK, gin.H{ &amp;#34;code&amp;#34;: code, &amp;#34;msg&amp;#34;: e.GetMsg(code), &amp;#34;data&amp;#34;: make(map[string]string), }) 如果加上规划内的功能逻辑呢，伪代码会变成：
if ! HasErrors() { exists, err := ExistArticleByID(id) if err == nil { if exists { err = DeleteArticle(id) if err == nil { code = e.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>之前就在想，不少教程或示例的代码设计都是一步到位的（也没问题）</p>
<p>但实际操作的读者真的能够理解透彻为什么吗？左思右想，有了今天这一章的内容，我认为实际经历过一遍印象会更加深刻</p>
<h2 id="本文目标">本文目标</h2>
<p>在本章节，将介绍以下功能的整理：</p>
<ul>
<li>抽离、分层业务逻辑：减轻 routers.go 内的 api 方法的逻辑（但本文暂不分层 repository，这块逻辑还不重）。</li>
<li>增加容错性：对 gorm 的错误进行判断。</li>
<li>Redis 缓存：对获取数据类的接口增加缓存设置。</li>
<li>减少重复冗余代码。</li>
</ul>
<h2 id="问题在哪">问题在哪？</h2>
<p>在规划阶段我们发现了一个问题，这是目前的伪代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="p">!</span> <span class="nf">HasErrors</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nf">ExistArticleByID</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">DeleteArticle</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
		<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_NOT_EXIST_ARTICLE</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">valid</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">{</span>
		<span class="nx">logging</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
	<span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
	<span class="s">&#34;msg&#34;</span><span class="p">:</span>  <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
	<span class="s">&#34;data&#34;</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
<span class="p">})</span>
</code></pre></div><p>如果加上规划内的功能逻辑呢，伪代码会变成：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="p">!</span> <span class="nf">HasErrors</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">exists</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">ExistArticleByID</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">exists</span> <span class="p">{</span>
    		<span class="nx">err</span> <span class="p">=</span> <span class="nf">DeleteArticle</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
    		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    		    <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
    		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    		    <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_XXX</span>
    		<span class="p">}</span>
    	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    		<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_NOT_EXIST_ARTICLE</span>
    	<span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_XXX</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">valid</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">{</span>
		<span class="nx">logging</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
	<span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
	<span class="s">&#34;msg&#34;</span><span class="p">:</span>  <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
	<span class="s">&#34;data&#34;</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
<span class="p">})</span>
</code></pre></div><p>如果缓存的逻辑也加进来，后面慢慢不断的迭代，岂不是会变成如下图一样？</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2017/04/IMG_7411.jpg" alt="image"></p>
<p>现在我们发现了问题，应及时解决这个代码结构问题，同时把代码写的清晰、漂亮、易读易改也是一个重要指标</p>
<h2 id="如何改">如何改？</h2>
<p>在左耳朵耗子的文章中，这类代码被称为 “箭头型” 代码，有如下几个问题：</p>
<p>1、我的显示器不够宽，箭头型代码缩进太狠了，需要我来回拉水平滚动条，这让我在读代码的时候，相当的不舒服</p>
<p>2、除了宽度外还有长度，有的代码的 if-else 里的 if-else 里的 if-else 的代码太多，读到中间你都不知道中间的代码是经过了什么样的层层检查才来到这里的</p>
<p>总而言之，“箭头型代码”如果嵌套太多，代码太长的话，会相当容易让维护代码的人（包括自己）迷失在代码中，因为看到最内层的代码时，你已经不知道前面的那一层一层的条件判断是什么样的，代码是怎么运行到这里的，所以，箭头型代码是非常难以维护和 Debug 的。</p>
<p>简单的来说，就是<strong>让出错的代码先返回，前面把所有的错误判断全判断掉，然后就剩下的就是正常的代码了</strong></p>
<p>（注意：本段引用自耗子哥的 <a href="https://coolshell.cn/articles/17757.html">如何重构“箭头型”代码</a>，建议细细品尝）</p>
<h2 id="落实">落实</h2>
<p>本项目将对既有代码进行优化和实现缓存，希望你习得方法并对其他地方也进行优化</p>
<p>第一步：完成 Redis 的基础设施建设（需要你先装好 Redis）</p>
<p>第二步：对现有代码进行拆解、分层（不会贴上具体步骤的代码，希望你能够实操一波，加深理解 🤔）</p>
<h3 id="redis">Redis</h3>
<h4 id="一配置">一、配置</h4>
<p>打开 conf/app.ini 文件，新增配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="na">...</span>
<span class="k">[redis]</span>
<span class="na">Host</span> <span class="o">=</span> <span class="s">127.0.0.1:6379</span>
<span class="na">Password</span> <span class="o">=</span>
<span class="na">MaxIdle</span> <span class="o">=</span> <span class="s">30</span>
<span class="na">MaxActive</span> <span class="o">=</span> <span class="s">30</span>
<span class="na">IdleTimeout</span> <span class="o">=</span> <span class="s">200</span>
</code></pre></div><h4 id="二缓存-prefix">二、缓存 Prefix</h4>
<p>打开 pkg/e 目录，新建 cache.go，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">e</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">CACHE_ARTICLE</span> <span class="p">=</span> <span class="s">&#34;ARTICLE&#34;</span>
	<span class="nx">CACHE_TAG</span>     <span class="p">=</span> <span class="s">&#34;TAG&#34;</span>
<span class="p">)</span>
</code></pre></div><h4 id="三缓存-key">三、缓存 Key</h4>
<p>（1）、打开 service 目录，新建 cache_service/article.go</p>
<p>写入内容：<a href="https://github.com/EDDYCJY/go-gin-example/blob/master/service/cache_service/article.go">传送门</a></p>
<p>（2）、打开 service 目录，新建 cache_service/tag.go</p>
<p>写入内容：<a href="https://github.com/EDDYCJY/go-gin-example/blob/master/service/cache_service/tag.go">传送门</a></p>
<p>这一部分主要是编写获取缓存 KEY 的方法，直接参考传送门即可</p>
<h4 id="四redis-工具包">四、Redis 工具包</h4>
<p>打开 pkg 目录，新建 gredis/redis.go，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">gredis</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/gomodule/redigo/redis&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">RedisConn</span> <span class="o">*</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Pool</span>

<span class="kd">func</span> <span class="nf">Setup</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">RedisConn</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Pool</span><span class="p">{</span>
		<span class="nx">MaxIdle</span><span class="p">:</span>     <span class="nx">setting</span><span class="p">.</span><span class="nx">RedisSetting</span><span class="p">.</span><span class="nx">MaxIdle</span><span class="p">,</span>
		<span class="nx">MaxActive</span><span class="p">:</span>   <span class="nx">setting</span><span class="p">.</span><span class="nx">RedisSetting</span><span class="p">.</span><span class="nx">MaxActive</span><span class="p">,</span>
		<span class="nx">IdleTimeout</span><span class="p">:</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">RedisSetting</span><span class="p">.</span><span class="nx">IdleTimeout</span><span class="p">,</span>
		<span class="nx">Dial</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="nx">redis</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">RedisSetting</span><span class="p">.</span><span class="nx">Host</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">RedisSetting</span><span class="p">.</span><span class="nx">Password</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;AUTH&#34;</span><span class="p">,</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">RedisSetting</span><span class="p">.</span><span class="nx">Password</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
					<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">},</span>
		<span class="nx">TestOnBorrow</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">redis</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;PING&#34;</span><span class="p">)</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">},</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">time</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">RedisConn</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">value</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;SET&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;EXPIRE&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">time</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Exists</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">RedisConn</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">exists</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">Bool</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;EXISTS&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">exists</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">RedisConn</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">reply</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">reply</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">RedisConn</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="k">return</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">Bool</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;DEL&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">LikeDeletes</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">conn</span> <span class="o">:=</span> <span class="nx">RedisConn</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">keys</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">redis</span><span class="p">.</span><span class="nf">Strings</span><span class="p">(</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="s">&#34;KEYS&#34;</span><span class="p">,</span> <span class="s">&#34;*&#34;</span><span class="o">+</span><span class="nx">key</span><span class="o">+</span><span class="s">&#34;*&#34;</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">keys</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>在这里我们做了一些基础功能封装</p>
<p>1、设置 RedisConn 为 redis.Pool（连接池）并配置了它的一些参数：</p>
<ul>
<li>
<p>Dial：提供创建和配置应用程序连接的一个函数</p>
</li>
<li>
<p>TestOnBorrow：可选的应用程序检查健康功能</p>
</li>
<li>
<p>MaxIdle：最大空闲连接数</p>
</li>
<li>
<p>MaxActive：在给定时间内，允许分配的最大连接数（当为零时，没有限制）</p>
</li>
<li>
<p>IdleTimeout：在给定时间内将会保持空闲状态，若到达时间限制则关闭连接（当为零时，没有限制）</p>
</li>
</ul>
<p>2、封装基础方法</p>
<p>文件内包含 Set、Exists、Get、Delete、LikeDeletes 用于支撑目前的业务逻辑，而在里面涉及到了如方法：</p>
<p>（1）<code>RedisConn.Get()</code>：在连接池中获取一个活跃连接</p>
<p>（2）<code>conn.Do(commandName string, args ...interface{})</code>：向 Redis 服务器发送命令并返回收到的答复</p>
<p>（3）<code>redis.Bool(reply interface{}, err error)</code>：将命令返回转为布尔值</p>
<p>（4）<code>redis.Bytes(reply interface{}, err error)</code>：将命令返回转为 Bytes</p>
<p>（5）<code>redis.Strings(reply interface{}, err error)</code>：将命令返回转为 []string</p>
<p>在 <a href="https://godoc.org/github.com/gomodule/redigo/redis">redigo</a> 中包含大量类似的方法，万变不离其宗，建议熟悉其使用规则和 <a href="http://doc.redisfans.com/index.html">Redis 命令</a> 即可</p>
<p>到这里为止，Redis 就可以愉快的调用啦。另外受篇幅限制，这块的深入讲解会另外开设！</p>
<h3 id="拆解分层">拆解、分层</h3>
<p>在先前规划中，引出几个方法去优化我们的应用结构</p>
<ul>
<li>错误提前返回</li>
<li>统一返回方法</li>
<li>抽离 Service，减轻 routers/api 的逻辑，进行分层</li>
<li>增加 gorm 错误判断，让错误提示更明确（增加内部错误码）</li>
</ul>
<h4 id="编写返回方法">编写返回方法</h4>
<p>要让错误提前返回，c.JSON 的侵入是不可避免的，但是可以让其更具可变性，指不定哪天就变 XML 了呢？</p>
<p>1、打开 pkg 目录，新建 app/request.go，写入文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">app</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/astaxie/beego/validation&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/logging&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">MarkErrors</span><span class="p">(</span><span class="nx">errors</span> <span class="p">[]</span><span class="o">*</span><span class="nx">validation</span><span class="p">.</span><span class="nx">Error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">errors</span> <span class="p">{</span>
		<span class="nx">logging</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>2、打开 pkg 目录，新建 app/response.go，写入文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">app</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/e&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Gin</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">C</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Gin</span><span class="p">)</span> <span class="nf">Response</span><span class="p">(</span><span class="nx">httpCode</span><span class="p">,</span> <span class="nx">errCode</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">C</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">httpCode</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
		<span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="nx">errCode</span><span class="p">,</span>
		<span class="s">&#34;msg&#34;</span><span class="p">:</span>  <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">errCode</span><span class="p">),</span>
		<span class="s">&#34;data&#34;</span><span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
	<span class="p">})</span>

	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>这样子以后如果要变动，直接改动 app 包内的方法即可</p>
<h4 id="修改既有逻辑">修改既有逻辑</h4>
<p>打开 routers/api/v1/article.go，查看修改 GetArticle 方法后的代码为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetArticle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">appG</span> <span class="o">:=</span> <span class="nx">app</span><span class="p">.</span><span class="nx">Gin</span><span class="p">{</span><span class="nx">c</span><span class="p">}</span>
	<span class="nx">id</span> <span class="o">:=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;id&#34;</span><span class="p">)).</span><span class="nf">MustInt</span><span class="p">()</span>
	<span class="nx">valid</span> <span class="o">:=</span> <span class="nx">validation</span><span class="p">.</span><span class="nx">Validation</span><span class="p">{}</span>
	<span class="nx">valid</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;id&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;ID必须大于0&#34;</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">HasErrors</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">app</span><span class="p">.</span><span class="nf">MarkErrors</span><span class="p">(</span><span class="nx">valid</span><span class="p">.</span><span class="nx">Errors</span><span class="p">)</span>
		<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">articleService</span> <span class="o">:=</span> <span class="nx">article_service</span><span class="p">.</span><span class="nx">Article</span><span class="p">{</span><span class="nx">ID</span><span class="p">:</span> <span class="nx">id</span><span class="p">}</span>
	<span class="nx">exists</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">articleService</span><span class="p">.</span><span class="nf">ExistByID</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_CHECK_EXIST_ARTICLE_FAIL</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">exists</span> <span class="p">{</span>
		<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_NOT_EXIST_ARTICLE</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">article</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">articleService</span><span class="p">.</span><span class="nf">Get</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_GET_ARTICLE_FAIL</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">appG</span><span class="p">.</span><span class="nf">Response</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span><span class="p">,</span> <span class="nx">article</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这里有几个值得变动点，主要是在内部增加了错误返回，如果存在错误则直接返回。另外进行了分层，业务逻辑内聚到了 service 层中去，而 routers/api（controller）显著减轻，代码会更加的直观</p>
<p>例如 service/article_service 下的 <code>articleService.Get()</code> 方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">Article</span><span class="p">)</span> <span class="nf">Get</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">models</span><span class="p">.</span><span class="nx">Article</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">cacheArticle</span> <span class="o">*</span><span class="nx">models</span><span class="p">.</span><span class="nx">Article</span>

	<span class="nx">cache</span> <span class="o">:=</span> <span class="nx">cache_service</span><span class="p">.</span><span class="nx">Article</span><span class="p">{</span><span class="nx">ID</span><span class="p">:</span> <span class="nx">a</span><span class="p">.</span><span class="nx">ID</span><span class="p">}</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">cache</span><span class="p">.</span><span class="nf">GetArticleKey</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gredis</span><span class="p">.</span><span class="nf">Exists</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gredis</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">logging</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">cacheArticle</span><span class="p">)</span>
			<span class="k">return</span> <span class="nx">cacheArticle</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">article</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">models</span><span class="p">.</span><span class="nf">GetArticle</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">gredis</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">article</span><span class="p">,</span> <span class="mi">3600</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">article</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>而对于 gorm 的 错误返回设置，只需要修改 models/article.go 如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetArticle</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Article</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">article</span> <span class="nx">Article</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;id = ? AND deleted_on = ? &#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">article</span><span class="p">).</span><span class="nf">Related</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">article</span><span class="p">.</span><span class="nx">Tag</span><span class="p">).</span><span class="nx">Error</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nx">ErrRecordNotFound</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">article</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>习惯性增加 .Error，把控绝大部分的错误。另外需要注意一点，在 gorm 中，查找不到记录也算一种 “错误” 哦</p>
<h2 id="最后">最后</h2>
<p>显然，本章节并不是你跟着我敲系列。我给你的课题是 “实现 Redis 缓存并优化既有的业务逻辑代码”</p>
<p>让其能够不断地适应业务的发展，让代码更清晰易读，且呈层级和结构性</p>
<p>如果有疑惑，可以到 <a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a> 看看我是怎么写的，你是怎么写的，又分别有什么优势、劣势，取长补短一波？</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h3 id="推荐阅读">推荐阅读</h3>
<ul>
<li><a href="https://coolshell.cn/articles/17757.html">如何重构“箭头型”代码</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「连载十二」优化配置结构及实现图片上传</title>
			<link>https://eddycjy.com/posts/go/gin/2018-05-27-config-upload/</link>
			<pubDate>Sun, 27 May 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-05-27-config-upload/</guid>
			<description>知识点  重构、调整结构  本文目标 这个应用程序跑了那么久了，越来越大，越来越壮，仿佛我们的产品一样，现在它需要进行小范围重构了，以便于后续的使用，这非常重要。
前言 一天，产品经理突然跟你说文章列表，没有封面图，不够美观，！）&amp;amp;￥*！&amp;amp;）#&amp;amp;￥*！加一个吧，几分钟的事
你打开你的程序，分析了一波写了个清单：
 优化配置结构（因为配置项越来越多） 抽离 原 logging 的 File 便于公用（logging、upload 各保有一份并不合适） 实现上传图片接口（需限制文件格式、大小） 修改文章接口（需支持封面地址参数） 增加 blog_article （文章）的数据库字段 实现 http.FileServer  嗯，你发现要较优的话，需要调整部分的应用程序结构，因为功能越来越多，原本的设计也要跟上节奏
也就是在适当的时候，及时优化
优化配置结构 一、讲解 在先前章节中，采用了直接读取 KEY 的方式去存储配置项，而本次需求中，需要增加图片的配置项，总体就有些冗余了
我们采用以下解决方法：
 映射结构体：使用 MapTo 来设置配置参数 配置统管：所有的配置项统管到 setting 中  映射结构体（示例） 在 go-ini 中可以采用 MapTo 的方式来映射结构体，例如：
type Server struct { RunMode string HttpPort int ReadTimeout time.Duration WriteTimeout time.Duration } var ServerSetting = &amp;amp;Server{} func main() { Cfg, err := ini.</description>
			<content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<ul>
<li>重构、调整结构</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>这个应用程序跑了那么久了，越来越大，越来越壮，仿佛我们的产品一样，现在它需要进行小范围重构了，以便于后续的使用，这非常重要。</p>
<h2 id="前言">前言</h2>
<p>一天，产品经理突然跟你说文章列表，没有封面图，不够美观，！）&amp;￥*！&amp;）#&amp;￥*！加一个吧，几分钟的事</p>
<p>你打开你的程序，分析了一波写了个清单：</p>
<ul>
<li>优化配置结构（因为配置项越来越多）</li>
<li>抽离 原 logging 的 File 便于公用（logging、upload 各保有一份并不合适）</li>
<li>实现上传图片接口（需限制文件格式、大小）</li>
<li>修改文章接口（需支持封面地址参数）</li>
<li>增加 blog_article （文章）的数据库字段</li>
<li>实现 http.FileServer</li>
</ul>
<p>嗯，你发现要较优的话，需要调整部分的应用程序结构，因为功能越来越多，原本的设计也要跟上节奏</p>
<p>也就是在适当的时候，及时优化</p>
<h2 id="优化配置结构">优化配置结构</h2>
<h3 id="一讲解">一、讲解</h3>
<p>在先前章节中，采用了直接读取 KEY 的方式去存储配置项，而本次需求中，需要增加图片的配置项，总体就有些冗余了</p>
<p>我们采用以下解决方法：</p>
<ul>
<li>映射结构体：使用 MapTo 来设置配置参数</li>
<li>配置统管：所有的配置项统管到 setting 中</li>
</ul>
<h4 id="映射结构体示例">映射结构体（示例）</h4>
<p>在 go-ini 中可以采用 MapTo 的方式来映射结构体，例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Server</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">RunMode</span> <span class="kt">string</span>
	<span class="nx">HttpPort</span> <span class="kt">int</span>
	<span class="nx">ReadTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
	<span class="nx">WriteTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">ServerSetting</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">Cfg</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ini</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="s">&#34;conf/app.ini&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Fail to parse &#39;conf/app.ini&#39;: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">Cfg</span><span class="p">.</span><span class="nf">Section</span><span class="p">(</span><span class="s">&#34;server&#34;</span><span class="p">).</span><span class="nf">MapTo</span><span class="p">(</span><span class="nx">ServerSetting</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Cfg.MapTo ServerSetting err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这段代码中，可以注意 ServerSetting 取了地址，为什么 MapTo 必须地址入参呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// MapTo maps section to given struct.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Section</span><span class="p">)</span> <span class="nf">MapTo</span><span class="p">(</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">typ</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="nx">val</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">typ</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">==</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span> <span class="p">{</span>
		<span class="nx">typ</span> <span class="p">=</span> <span class="nx">typ</span><span class="p">.</span><span class="nf">Elem</span><span class="p">()</span>
		<span class="nx">val</span> <span class="p">=</span> <span class="nx">val</span><span class="p">.</span><span class="nf">Elem</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;cannot map to non-pointer struct&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">mapTo</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在 MapTo 中 <code>typ.Kind() == reflect.Ptr</code> 约束了必须使用指针，否则会返回 <code>cannot map to non-pointer struct</code> 的错误。这个是表面原因</p>
<p>更往内探究，可以认为是 <code>field.Set</code> 的原因，当执行 <code>val := reflect.ValueOf(v)</code> ，函数通过传递 <code>v</code> 拷贝创建了 <code>val</code>，但是 <code>val</code> 的改变并不能更改原始的 <code>v</code>，要想 <code>val</code> 的更改能作用到 <code>v</code>，则必须传递 <code>v</code> 的地址</p>
<p>显然 go-ini 里也是包含修改原始值这一项功能的，你觉得是什么原因呢？</p>
<h4 id="配置统管">配置统管</h4>
<p>在先前的版本中，models 和 file 的配置是在自己的文件中解析的，而其他在 setting.go 中，因此我们需要将其在 setting 中统一接管</p>
<p>你可能会想，直接把两者的配置项复制粘贴到 setting.go 的 init 中，一下子就完事了，搞那么麻烦？</p>
<p>但你在想想，先前的代码中存在多个 init 函数，执行顺序存在问题，无法达到我们的要求，你可以试试</p>
<p>（此处是一个基础知识点）</p>
<p>在 Go 中，当存在多个 init 函数时，执行顺序为：</p>
<ul>
<li>相同包下的 init 函数：按照源文件编译顺序决定执行顺序（默认按文件名排序）</li>
<li>不同包下的 init 函数：按照包导入的依赖关系决定先后顺序</li>
</ul>
<p>所以要避免多 init 的情况，<strong>尽量由程序把控初始化的先后顺序</strong></p>
<h3 id="二落实">二、落实</h3>
<h4 id="修改配置文件">修改配置文件</h4>
<p>打开 conf/app.ini 将配置文件修改为大驼峰命名，另外我们增加了 5 个配置项用于上传图片的功能，4 个文件日志方面的配置项</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="k">[app]</span>
<span class="na">PageSize</span> <span class="o">=</span> <span class="s">10</span>
<span class="na">JwtSecret</span> <span class="o">=</span> <span class="s">233</span>

<span class="na">RuntimeRootPath</span> <span class="o">=</span> <span class="s">runtime/</span>

<span class="na">ImagePrefixUrl</span> <span class="o">=</span> <span class="s">http://127.0.0.1:8000</span>
<span class="na">ImageSavePath</span> <span class="o">=</span> <span class="s">upload/images/</span>
<span class="c1"># MB</span>
<span class="na">ImageMaxSize</span> <span class="o">=</span> <span class="s">5</span>
<span class="na">ImageAllowExts</span> <span class="o">=</span> <span class="s">.jpg,.jpeg,.png</span>

<span class="na">LogSavePath</span> <span class="o">=</span> <span class="s">logs/</span>
<span class="na">LogSaveName</span> <span class="o">=</span> <span class="s">log</span>
<span class="na">LogFileExt</span> <span class="o">=</span> <span class="s">log</span>
<span class="na">TimeFormat</span> <span class="o">=</span> <span class="s">20060102</span>

<span class="k">[server]</span>
<span class="c1">#debug or release</span>
<span class="na">RunMode</span> <span class="o">=</span> <span class="s">debug</span>
<span class="na">HttpPort</span> <span class="o">=</span> <span class="s">8000</span>
<span class="na">ReadTimeout</span> <span class="o">=</span> <span class="s">60</span>
<span class="na">WriteTimeout</span> <span class="o">=</span> <span class="s">60</span>

<span class="k">[database]</span>
<span class="na">Type</span> <span class="o">=</span> <span class="s">mysql</span>
<span class="na">User</span> <span class="o">=</span> <span class="s">root</span>
<span class="na">Password</span> <span class="o">=</span> <span class="s">rootroot</span>
<span class="na">Host</span> <span class="o">=</span> <span class="s">127.0.0.1:3306</span>
<span class="na">Name</span> <span class="o">=</span> <span class="s">blog</span>
<span class="na">TablePrefix</span> <span class="o">=</span> <span class="s">blog_</span>
</code></pre></div><h4 id="优化配置读取及设置初始化顺序">优化配置读取及设置初始化顺序</h4>
<h5 id="第一步">第一步</h5>
<p>将散落在其他文件里的配置都删掉，<strong>统一在 setting 中处理</strong>以及<strong>修改 init 函数为 Setup 方法</strong></p>
<p>打开 pkg/setting/setting.go 文件，修改如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">setting</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/go-ini/ini&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">App</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">JwtSecret</span> <span class="kt">string</span>
	<span class="nx">PageSize</span> <span class="kt">int</span>
	<span class="nx">RuntimeRootPath</span> <span class="kt">string</span>

	<span class="nx">ImagePrefixUrl</span> <span class="kt">string</span>
	<span class="nx">ImageSavePath</span> <span class="kt">string</span>
	<span class="nx">ImageMaxSize</span> <span class="kt">int</span>
	<span class="nx">ImageAllowExts</span> <span class="p">[]</span><span class="kt">string</span>

	<span class="nx">LogSavePath</span> <span class="kt">string</span>
	<span class="nx">LogSaveName</span> <span class="kt">string</span>
	<span class="nx">LogFileExt</span> <span class="kt">string</span>
	<span class="nx">TimeFormat</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">AppSetting</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">App</span><span class="p">{}</span>

<span class="kd">type</span> <span class="nx">Server</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">RunMode</span> <span class="kt">string</span>
	<span class="nx">HttpPort</span> <span class="kt">int</span>
	<span class="nx">ReadTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
	<span class="nx">WriteTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">ServerSetting</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Server</span><span class="p">{}</span>

<span class="kd">type</span> <span class="nx">Database</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Type</span> <span class="kt">string</span>
	<span class="nx">User</span> <span class="kt">string</span>
	<span class="nx">Password</span> <span class="kt">string</span>
	<span class="nx">Host</span> <span class="kt">string</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">TablePrefix</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">DatabaseSetting</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Database</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">Setup</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">Cfg</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ini</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="s">&#34;conf/app.ini&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Fail to parse &#39;conf/app.ini&#39;: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">Cfg</span><span class="p">.</span><span class="nf">Section</span><span class="p">(</span><span class="s">&#34;app&#34;</span><span class="p">).</span><span class="nf">MapTo</span><span class="p">(</span><span class="nx">AppSetting</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Cfg.MapTo AppSetting err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">AppSetting</span><span class="p">.</span><span class="nx">ImageMaxSize</span> <span class="p">=</span> <span class="nx">AppSetting</span><span class="p">.</span><span class="nx">ImageMaxSize</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">Cfg</span><span class="p">.</span><span class="nf">Section</span><span class="p">(</span><span class="s">&#34;server&#34;</span><span class="p">).</span><span class="nf">MapTo</span><span class="p">(</span><span class="nx">ServerSetting</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Cfg.MapTo ServerSetting err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">ServerSetting</span><span class="p">.</span><span class="nx">ReadTimeout</span> <span class="p">=</span> <span class="nx">ServerSetting</span><span class="p">.</span><span class="nx">ReadTimeout</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>
	<span class="nx">ServerSetting</span><span class="p">.</span><span class="nx">WriteTimeout</span> <span class="p">=</span> <span class="nx">ServerSetting</span><span class="p">.</span><span class="nx">WriteTimeout</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">Cfg</span><span class="p">.</span><span class="nf">Section</span><span class="p">(</span><span class="s">&#34;database&#34;</span><span class="p">).</span><span class="nf">MapTo</span><span class="p">(</span><span class="nx">DatabaseSetting</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Cfg.MapTo DatabaseSetting err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这里，我们做了如下几件事：</p>
<ul>
<li>编写与配置项保持一致的结构体（App、Server、Database）</li>
<li>使用 MapTo 将配置项映射到结构体上</li>
<li>对一些需特殊设置的配置项进行再赋值</li>
</ul>
<p><strong>需要你去做的事：</strong></p>
<ul>
<li>将 <a href="https://github.com/EDDYCJY/go-gin-example/blob/a338ddec103c9506b4c7ed16d9f5386040d99b4b/models/models.go#L23">models.go</a>、<a href="https://github.com/EDDYCJY/go-gin-example/blob/a338ddec103c9506b4c7ed16d9f5386040d99b4b/pkg/setting/setting.go#L23">setting.go</a>、<a href="https://github.com/EDDYCJY/go-gin-example/blob/a338ddec103c9506b4c7ed16d9f5386040d99b4b/pkg/logging/log.go#L32-L37">pkg/logging/log.go</a> 的 init 函数修改为 Setup 方法</li>
<li>将 <a href="https://github.com/EDDYCJY/go-gin-example/blob/a338ddec103c9506b4c7ed16d9f5386040d99b4b/models/models.go#L23-L39">models/models.go</a> 独立读取的 DB 配置项删除，改为统一读取 setting</li>
<li>将 <a href="https://github.com/EDDYCJY/go-gin-example/blob/a338ddec103c9506b4c7ed16d9f5386040d99b4b/pkg/logging/file.go#L10-L15">pkg/logging/file</a> 独立的 LOG 配置项删除，改为统一读取 setting</li>
</ul>
<p>这几项比较基础，并没有贴出来，我希望你可以自己动手，有问题的话可右拐 <a href="https://github.com/EDDYCJY/go-gin-example">项目地址</a></p>
<h5 id="第二步">第二步</h5>
<p>在这一步我们要设置初始化的流程，打开 main.go 文件，修改内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">setting</span><span class="p">.</span><span class="nf">Setup</span><span class="p">()</span>
	<span class="nx">models</span><span class="p">.</span><span class="nf">Setup</span><span class="p">()</span>
	<span class="nx">logging</span><span class="p">.</span><span class="nf">Setup</span><span class="p">()</span>

	<span class="nx">endless</span><span class="p">.</span><span class="nx">DefaultReadTimeOut</span> <span class="p">=</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">ServerSetting</span><span class="p">.</span><span class="nx">ReadTimeout</span>
	<span class="nx">endless</span><span class="p">.</span><span class="nx">DefaultWriteTimeOut</span> <span class="p">=</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">ServerSetting</span><span class="p">.</span><span class="nx">WriteTimeout</span>
	<span class="nx">endless</span><span class="p">.</span><span class="nx">DefaultMaxHeaderBytes</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>
	<span class="nx">endPoint</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;:%d&#34;</span><span class="p">,</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">ServerSetting</span><span class="p">.</span><span class="nx">HttpPort</span><span class="p">)</span>

	<span class="nx">server</span> <span class="o">:=</span> <span class="nx">endless</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">(</span><span class="nx">endPoint</span><span class="p">,</span> <span class="nx">routers</span><span class="p">.</span><span class="nf">InitRouter</span><span class="p">())</span>
	<span class="nx">server</span><span class="p">.</span><span class="nx">BeforeBegin</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">add</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Actual pid is %d&#34;</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Getpid</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Server err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>修改完毕后，就成功将多模块的初始化函数放到启动流程中了（先后顺序也可以控制）</p>
<h5 id="验证">验证</h5>
<p>在这里为止，针对本需求的配置优化就完毕了，你需要执行 <code>go run main.go</code> 验证一下你的功能是否正常哦</p>
<p>顺带留个基础问题，大家可以思考下</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ServerSetting</span><span class="p">.</span><span class="nx">ReadTimeout</span> <span class="p">=</span> <span class="nx">ServerSetting</span><span class="p">.</span><span class="nx">ReadTimeout</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>
<span class="nx">ServerSetting</span><span class="p">.</span><span class="nx">WriteTimeout</span> <span class="p">=</span> <span class="nx">ServerSetting</span><span class="p">.</span><span class="nx">ReadTimeout</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>
</code></pre></div><p>若将 setting.go 文件中的这两行删除，会出现什么问题，为什么呢？</p>
<h2 id="抽离-file">抽离 File</h2>
<p>在先前版本中，在 <a href="https://github.com/EDDYCJY/go-gin-example/blob/a338ddec103c9506b4c7ed16d9f5386040d99b4b/pkg/logging/file.go">logging/file.go</a> 中使用到了 os 的一些方法，我们通过前期规划发现，这部分在上传图片功能中可以复用</p>
<h3 id="第一步-1">第一步</h3>
<p>在 pkg 目录下新建 file/file.go ，写入文件内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">file</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;path&#34;</span>
	<span class="s">&#34;mime/multipart&#34;</span>
	<span class="s">&#34;io/ioutil&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">GetSize</span><span class="p">(</span><span class="nx">f</span> <span class="nx">multipart</span><span class="p">.</span><span class="nx">File</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">content</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">content</span><span class="p">),</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetExt</span><span class="p">(</span><span class="nx">fileName</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Ext</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CheckNotExist</span><span class="p">(</span><span class="nx">src</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Stat</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CheckPermission</span><span class="p">(</span><span class="nx">src</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Stat</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsPermission</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">IsNotExistMkDir</span><span class="p">(</span><span class="nx">src</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">notExist</span> <span class="o">:=</span> <span class="nf">CheckNotExist</span><span class="p">(</span><span class="nx">src</span><span class="p">);</span> <span class="nx">notExist</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">MkDir</span><span class="p">(</span><span class="nx">src</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">MkDir</span><span class="p">(</span><span class="nx">src</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">MkdirAll</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">ModePerm</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Open</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">flag</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">perm</span> <span class="nx">os</span><span class="p">.</span><span class="nx">FileMode</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">flag</span><span class="p">,</span> <span class="nx">perm</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">f</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>在这里我们一共封装了 7 个 方法</p>
<ul>
<li>GetSize：获取文件大小</li>
<li>GetExt：获取文件后缀</li>
<li>CheckNotExist：检查文件是否存在</li>
<li>CheckPermission：检查文件权限</li>
<li>IsNotExistMkDir：如果不存在则新建文件夹</li>
<li>MkDir：新建文件夹</li>
<li>Open：打开文件</li>
</ul>
<p>在这里我们用到了 <code>mime/multipart</code> 包，它主要实现了 MIME 的 multipart 解析，主要适用于 <a href="https://tools.ietf.org/html/rfc2388">HTTP</a> 和常见浏览器生成的 multipart 主体</p>
<p>multipart 又是什么，<a href="https://tools.ietf.org/html/rfc2388">rfc2388</a> 的 multipart/form-data 了解一下</p>
<h3 id="第二步-1">第二步</h3>
<p>我们在第一步已经将 file 重新封装了一层，在这一步我们将原先 logging 包的方法都修改掉</p>
<p>1、打开 pkg/logging/file.go 文件，修改文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">logging</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/file&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">getLogFilePath</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s%s&#34;</span><span class="p">,</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">RuntimeRootPath</span><span class="p">,</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">LogSavePath</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getLogFileName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s%s.%s&#34;</span><span class="p">,</span>
		<span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">LogSaveName</span><span class="p">,</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">TimeFormat</span><span class="p">),</span>
		<span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">LogFileExt</span><span class="p">,</span>
	<span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">openLogFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">filePath</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">dir</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getwd</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;os.Getwd err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">src</span> <span class="o">:=</span> <span class="nx">dir</span> <span class="o">+</span> <span class="s">&#34;/&#34;</span> <span class="o">+</span> <span class="nx">filePath</span>
	<span class="nx">perm</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">CheckPermission</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">perm</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;file.CheckPermission Permission denied src: %s&#34;</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">IsNotExistMkDir</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;file.IsNotExistMkDir src: %s, err: %v&#34;</span><span class="p">,</span> <span class="nx">src</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">src</span> <span class="o">+</span> <span class="nx">fileName</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_APPEND</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">,</span> <span class="mo">0644</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Fail to OpenFile :%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">f</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>我们将引用都改为了 file/file.go 包里的方法</p>
<p>2、打开 pkg/logging/log.go 文件，修改文件内容:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">logging</span>

<span class="o">...</span>

<span class="kd">func</span> <span class="nf">Setup</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="nx">filePath</span> <span class="o">:=</span> <span class="nf">getLogFilePath</span><span class="p">()</span>
	<span class="nx">fileName</span> <span class="o">:=</span> <span class="nf">getLogFileName</span><span class="p">()</span>
	<span class="nx">F</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">openLogFile</span><span class="p">(</span><span class="nx">fileName</span><span class="p">,</span> <span class="nx">filePath</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">logger</span> <span class="p">=</span> <span class="nx">log</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">F</span><span class="p">,</span> <span class="nx">DefaultPrefix</span><span class="p">,</span> <span class="nx">log</span><span class="p">.</span><span class="nx">LstdFlags</span><span class="p">)</span>
<span class="p">}</span>

<span class="o">...</span>
</code></pre></div><p>由于原方法形参改变了，因此 openLogFile 也需要调整</p>
<h2 id="实现上传图片接口">实现上传图片接口</h2>
<p>这一小节，我们开始实现上次图片相关的一些方法和功能</p>
<p>首先需要在 blog_article 中增加字段 <code>cover_image_url</code>，格式为 <code>varchar(255) DEFAULT '' COMMENT '封面图片地址'</code></p>
<h3 id="第零步">第零步</h3>
<p>一般不会直接将上传的图片名暴露出来，因此我们对图片名进行 MD5 来达到这个效果</p>
<p>在 util 目录下新建 md5.go，写入文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">util</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;crypto/md5&#34;</span>
	<span class="s">&#34;encoding/hex&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">EncodeMD5</span><span class="p">(</span><span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">md5</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">m</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span>

	<span class="k">return</span> <span class="nx">hex</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div><h3 id="第一步-2">第一步</h3>
<p>在先前我们已经把底层方法给封装好了，实质这一步为封装 image 的处理逻辑</p>
<p>在 pkg 目录下新建 upload/image.go 文件，写入文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">upload</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;path&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;mime/multipart&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/file&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/logging&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/util&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">GetImageFullUrl</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">ImagePrefixUrl</span> <span class="o">+</span> <span class="s">&#34;/&#34;</span> <span class="o">+</span> <span class="nf">GetImagePath</span><span class="p">()</span> <span class="o">+</span> <span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetImageName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">ext</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Ext</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
	<span class="nx">fileName</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSuffix</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">ext</span><span class="p">)</span>
	<span class="nx">fileName</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">EncodeMD5</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">fileName</span> <span class="o">+</span> <span class="nx">ext</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetImagePath</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">ImageSavePath</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetImageFullPath</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">RuntimeRootPath</span> <span class="o">+</span> <span class="nf">GetImagePath</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CheckImageExt</span><span class="p">(</span><span class="nx">fileName</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">ext</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">GetExt</span><span class="p">(</span><span class="nx">fileName</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">allowExt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">ImageAllowExts</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">(</span><span class="nx">allowExt</span><span class="p">)</span> <span class="o">==</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">(</span><span class="nx">ext</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CheckImageSize</span><span class="p">(</span><span class="nx">f</span> <span class="nx">multipart</span><span class="p">.</span><span class="nx">File</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">size</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">GetSize</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="nx">logging</span><span class="p">.</span><span class="nf">Warn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">AppSetting</span><span class="p">.</span><span class="nx">ImageMaxSize</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CheckImage</span><span class="p">(</span><span class="nx">src</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">dir</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getwd</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;os.Getwd err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">IsNotExistMkDir</span><span class="p">(</span><span class="nx">dir</span> <span class="o">+</span> <span class="s">&#34;/&#34;</span> <span class="o">+</span> <span class="nx">src</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;file.IsNotExistMkDir err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">perm</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nf">CheckPermission</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">perm</span> <span class="o">==</span> <span class="kc">true</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;file.CheckPermission Permission denied src: %s&#34;</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>在这里我们实现了 7 个方法，如下：</p>
<ul>
<li>GetImageFullUrl：获取图片完整访问 URL</li>
<li>GetImageName：获取图片名称</li>
<li>GetImagePath：获取图片路径</li>
<li>GetImageFullPath：获取图片完整路径</li>
<li>CheckImageExt：检查图片后缀</li>
<li>CheckImageSize：检查图片大小</li>
<li>CheckImage：检查图片</li>
</ul>
<p>这里基本是对底层代码的二次封装，为了更灵活的处理一些图片特有的逻辑，并且方便修改，不直接对外暴露下层</p>
<h3 id="第二步-2">第二步</h3>
<p>这一步将编写上传图片的业务逻辑，在 routers/api 目录下 新建 upload.go 文件，写入文件内容:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">api</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/e&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/logging&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/upload&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">UploadImage</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>

	<span class="nx">file</span><span class="p">,</span> <span class="nx">image</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">FormFile</span><span class="p">(</span><span class="s">&#34;image&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">logging</span><span class="p">.</span><span class="nf">Warn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
			<span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
			<span class="s">&#34;msg&#34;</span><span class="p">:</span>  <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
			<span class="s">&#34;data&#34;</span><span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">image</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">imageName</span> <span class="o">:=</span> <span class="nx">upload</span><span class="p">.</span><span class="nf">GetImageName</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">Filename</span><span class="p">)</span>
		<span class="nx">fullPath</span> <span class="o">:=</span> <span class="nx">upload</span><span class="p">.</span><span class="nf">GetImageFullPath</span><span class="p">()</span>
		<span class="nx">savePath</span> <span class="o">:=</span> <span class="nx">upload</span><span class="p">.</span><span class="nf">GetImagePath</span><span class="p">()</span>

		<span class="nx">src</span> <span class="o">:=</span> <span class="nx">fullPath</span> <span class="o">+</span> <span class="nx">imageName</span>
		<span class="k">if</span> <span class="p">!</span> <span class="nx">upload</span><span class="p">.</span><span class="nf">CheckImageExt</span><span class="p">(</span><span class="nx">imageName</span><span class="p">)</span> <span class="o">||</span> <span class="p">!</span> <span class="nx">upload</span><span class="p">.</span><span class="nf">CheckImageSize</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_UPLOAD_CHECK_IMAGE_FORMAT</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="o">:=</span> <span class="nx">upload</span><span class="p">.</span><span class="nf">CheckImage</span><span class="p">(</span><span class="nx">fullPath</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">logging</span><span class="p">.</span><span class="nf">Warn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_UPLOAD_CHECK_IMAGE_FAIL</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">SaveUploadedFile</span><span class="p">(</span><span class="nx">image</span><span class="p">,</span> <span class="nx">src</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">logging</span><span class="p">.</span><span class="nf">Warn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_UPLOAD_SAVE_IMAGE_FAIL</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">data</span><span class="p">[</span><span class="s">&#34;image_url&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">upload</span><span class="p">.</span><span class="nf">GetImageFullUrl</span><span class="p">(</span><span class="nx">imageName</span><span class="p">)</span>
				<span class="nx">data</span><span class="p">[</span><span class="s">&#34;image_save_url&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">savePath</span> <span class="o">+</span> <span class="nx">imageName</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
		<span class="s">&#34;code&#34;</span><span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
		<span class="s">&#34;msg&#34;</span><span class="p">:</span>  <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
		<span class="s">&#34;data&#34;</span><span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>所涉及的错误码（需在 pkg/e/code.go、msg.go 添加）：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 保存图片失败
</span><span class="c1"></span><span class="nx">ERROR_UPLOAD_SAVE_IMAGE_FAIL</span> <span class="p">=</span> <span class="mi">30001</span>
<span class="c1">// 检查图片失败
</span><span class="c1"></span><span class="nx">ERROR_UPLOAD_CHECK_IMAGE_FAIL</span> <span class="p">=</span> <span class="mi">30002</span>
<span class="c1">// 校验图片错误，图片格式或大小有问题
</span><span class="c1"></span><span class="nx">ERROR_UPLOAD_CHECK_IMAGE_FORMAT</span> <span class="p">=</span> <span class="mi">30003</span>
</code></pre></div><p>在这一大段的业务逻辑中，我们做了如下事情：</p>
<ul>
<li>c.Request.FormFile：获取上传的图片（返回提供的表单键的第一个文件）</li>
<li>CheckImageExt、CheckImageSize 检查图片大小，检查图片后缀</li>
<li>CheckImage：检查上传图片所需（权限、文件夹）</li>
<li>SaveUploadedFile：保存图片</li>
</ul>
<p>总的来说，就是 入参 -&gt; 检查 -》 保存 的应用流程</p>
<h3 id="第三步">第三步</h3>
<p>打开 routers/router.go 文件，增加路由 <code>r.POST(&quot;/upload&quot;, api.UploadImage)</code> ，如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="o">...</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/auth&#34;</span><span class="p">,</span> <span class="nx">api</span><span class="p">.</span><span class="nx">GetAuth</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/swagger/*any&#34;</span><span class="p">,</span> <span class="nx">ginSwagger</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">swaggerFiles</span><span class="p">.</span><span class="nx">Handler</span><span class="p">))</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/upload&#34;</span><span class="p">,</span> <span class="nx">api</span><span class="p">.</span><span class="nx">UploadImage</span><span class="p">)</span>

	<span class="nx">apiv1</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/api/v1&#34;</span><span class="p">)</span>
	<span class="nx">apiv1</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">jwt</span><span class="p">.</span><span class="nf">JWT</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></div><h3 id="验证-1">验证</h3>
<p>最后我们请求一下上传图片的接口，测试所编写的功能</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xumb8.jpg" alt="image"></p>
<p>检查目录下是否含文件（注意权限问题）</p>
<pre><code>$ pwd
$GOPATH/src/github.com/EDDYCJY/go-gin-example/runtime/upload/images

$ ll
... 96a3be3cf272e017046d1b2674a52bd3.jpg
... c39fa784216313cf2faa7c98739fc367.jpeg
</code></pre><p>在这里我们一共返回了 2 个参数，一个是完整的访问 URL，另一个为保存路径</p>
<h2 id="实现-httpfileserver">实现 http.FileServer</h2>
<p>在完成了上一小节后，我们还需要让前端能够访问到图片，一般是如下：</p>
<ul>
<li>CDN</li>
<li>http.FileSystem</li>
</ul>
<p>在公司的话，CDN 或自建分布式文件系统居多，也不需要过多关注。而在实践里的话肯定是本地搭建了，Go 本身对此就有很好的支持，而 Gin 更是再封装了一层，只需要在路由增加一行代码即可</p>
<h3 id="rstaticfs">r.StaticFS</h3>
<p>打开 routers/router.go 文件，增加路由 <code>r.StaticFS(&quot;/upload/images&quot;, http.Dir(upload.GetImageFullPath()))</code>，如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span> <span class="p">{</span>
    <span class="o">...</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">StaticFS</span><span class="p">(</span><span class="s">&#34;/upload/images&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="nx">upload</span><span class="p">.</span><span class="nf">GetImageFullPath</span><span class="p">()))</span>

	<span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/auth&#34;</span><span class="p">,</span> <span class="nx">api</span><span class="p">.</span><span class="nx">GetAuth</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/swagger/*any&#34;</span><span class="p">,</span> <span class="nx">ginSwagger</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">swaggerFiles</span><span class="p">.</span><span class="nx">Handler</span><span class="p">))</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/upload&#34;</span><span class="p">,</span> <span class="nx">api</span><span class="p">.</span><span class="nx">UploadImage</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h3 id="它做了什么">它做了什么</h3>
<p>当访问 $HOST/upload/images 时，将会读取到 $GOPATH/src/github.com/EDDYCJY/go-gin-example/runtime/upload/images 下的文件</p>
<p>而这行代码又做了什么事呢，我们来看看方法原型</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// StaticFS works just like `Static()` but a custom `http.FileSystem` can be used instead.
</span><span class="c1">// Gin by default user: gin.Dir()
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">group</span> <span class="o">*</span><span class="nx">RouterGroup</span><span class="p">)</span> <span class="nf">StaticFS</span><span class="p">(</span><span class="nx">relativePath</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fs</span> <span class="nx">http</span><span class="p">.</span><span class="nx">FileSystem</span><span class="p">)</span> <span class="nx">IRoutes</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">relativePath</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">relativePath</span><span class="p">,</span> <span class="s">&#34;*&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;URL parameters can not be used when serving a static folder&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">handler</span> <span class="o">:=</span> <span class="nx">group</span><span class="p">.</span><span class="nf">createStaticHandler</span><span class="p">(</span><span class="nx">relativePath</span><span class="p">,</span> <span class="nx">fs</span><span class="p">)</span>
	<span class="nx">urlPattern</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">relativePath</span><span class="p">,</span> <span class="s">&#34;/*filepath&#34;</span><span class="p">)</span>

	<span class="c1">// Register GET and HEAD handlers
</span><span class="c1"></span>	<span class="nx">group</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="nx">urlPattern</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
	<span class="nx">group</span><span class="p">.</span><span class="nf">HEAD</span><span class="p">(</span><span class="nx">urlPattern</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">group</span><span class="p">.</span><span class="nf">returnObj</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>首先在暴露的 URL 中禁止了 * 和 : 符号的使用，通过 <code>createStaticHandler</code> 创建了静态文件服务，实质最终调用的还是 <code>fileServer.ServeHTTP</code> 和一些处理逻辑了</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">group</span> <span class="o">*</span><span class="nx">RouterGroup</span><span class="p">)</span> <span class="nf">createStaticHandler</span><span class="p">(</span><span class="nx">relativePath</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fs</span> <span class="nx">http</span><span class="p">.</span><span class="nx">FileSystem</span><span class="p">)</span> <span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="nx">absolutePath</span> <span class="o">:=</span> <span class="nx">group</span><span class="p">.</span><span class="nf">calculateAbsolutePath</span><span class="p">(</span><span class="nx">relativePath</span><span class="p">)</span>
	<span class="nx">fileServer</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">StripPrefix</span><span class="p">(</span><span class="nx">absolutePath</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">fs</span><span class="p">))</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">nolisting</span> <span class="o">:=</span> <span class="nx">fs</span><span class="p">.(</span><span class="o">*</span><span class="nx">onlyfilesFS</span><span class="p">)</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">nolisting</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">fileServer</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="httpstripprefix">http.StripPrefix</h4>
<p>我们可以留意下 <code>fileServer := http.StripPrefix(absolutePath, http.FileServer(fs))</code> 这段语句，在静态文件服务中很常见，它有什么作用呢？</p>
<p><code>http.StripPrefix</code> 主要作用是从请求 URL 的路径中删除给定的前缀，最终返回一个 <code>Handler</code></p>
<p>通常 http.FileServer 要与 http.StripPrefix 相结合使用，否则当你运行：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/upload/images&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="s">&#34;upload/images&#34;</span><span class="p">)))</span>
</code></pre></div><p>会无法正确的访问到文件目录，因为 <code>/upload/images</code> 也包含在了 URL 路径中，必须使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/upload/images&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">StripPrefix</span><span class="p">(</span><span class="s">&#34;upload/images&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="s">&#34;upload/images&#34;</span><span class="p">))))</span>
</code></pre></div><h4 id="filepath">/*filepath</h4>
<p>到下面可以看到 <code>urlPattern := path.Join(relativePath, &quot;/*filepath&quot;)</code>，<code>/*filepath</code> 你是谁，你在这里有什么用，你是 Gin 的产物吗?</p>
<p>通过语义可得知是路由的处理逻辑，而 Gin 的路由是基于 httprouter 的，通过查阅文档可得到以下信息</p>
<pre><code>Pattern: /src/*filepath

 /src/                     match
 /src/somefile.go          match
 /src/subdir/somefile.go   match
</code></pre><p><code>*filepath</code> 将匹配所有文件路径，并且 <code>*filepath</code> 必须在 Pattern 的最后</p>
<h3 id="验证-2">验证</h3>
<p>重新执行 <code>go run main.go</code> ，去访问刚刚在 upload 接口得到的图片地址，检查 http.FileSystem 是否正常</p>
<p><img src="https://s2.ax1x.com/2020/02/15/1xu4Gd.jpg" alt="image"></p>
<h2 id="修改文章接口">修改文章接口</h2>
<p>接下来，需要你修改 routers/api/v1/article.go 的 AddArticle、EditArticle 两个接口</p>
<ul>
<li>新增、更新文章接口：支持入参 cover_image_url</li>
<li>新增、更新文章接口：增加对 cover_image_url 的非空、最长长度校验</li>
</ul>
<p>这块前面文章讲过，如果有问题可以参考项目的代码 👌</p>
<h2 id="总结">总结</h2>
<p>在这章节中，我们简单的分析了下需求，对应用做出了一个小规划并实施</p>
<p>完成了清单中的功能点和优化，在实际项目中也是常见的场景，希望你能够细细品尝并针对一些点进行深入学习</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 02 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>Go 的 fake-useragent 了解一下</title>
			<link>https://eddycjy.com/posts/go/talk/2018-05-21-go-fake-useragent/</link>
			<pubDate>Mon, 21 May 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2018-05-21-go-fake-useragent/</guid>
			<description>有的网站会根据 User-Agent 的不同，跳转到不同（PC、M）的站点，也有根据版本的不同给出不一样的提示等等，而 User-Agent 的变化更是爬虫里的基础姿势
使用 Go 编写网络爬虫或需要模拟浏览器头（User-Agent）的时候，你是否会觉得很麻烦，获取请求头（Request Headers）的 User-Agent 还得找来找去，挺繁琐。先前我也遇到了这个问题，因此有了这个项目 fake-useragent，用来解决你我的痛点
项目地址：https://github.com/EDDYCJY/fake-useragent
支持  All User-Agent Random Chrome InternetExplorer (IE) Firefox Safari Android MacOSX IOS Linux IPhone IPad Computer Mobile  安装 $ go get github.com/EDDYCJY/fake-useragent 用法 package main import ( &amp;#34;log&amp;#34; &amp;#34;github.com/EDDYCJY/fake-useragent&amp;#34; ) func main() { // 推荐使用 	random := browser.Random() log.Printf(&amp;#34;Random: %s&amp;#34;, random) chrome := browser.Chrome() log.Printf(&amp;#34;Chrome: %s&amp;#34;, chrome) internetExplorer := browser.InternetExplorer() log.Printf(&amp;#34;IE: %s&amp;#34;, internetExplorer) firefox := browser.</description>
			<content type="html"><![CDATA[<p>有的网站会根据 User-Agent 的不同，跳转到不同（PC、M）的站点，也有根据版本的不同给出不一样的提示等等，而 User-Agent 的变化更是爬虫里的基础姿势</p>
<p>使用 Go 编写网络爬虫或需要模拟浏览器头（User-Agent）的时候，你是否会觉得很麻烦，获取请求头（Request Headers）的 User-Agent 还得找来找去，挺繁琐。先前我也遇到了这个问题，因此有了这个项目 <a href="https://github.com/EDDYCJY/fake-useragent">fake-useragent</a>，用来解决你我的痛点</p>
<p>项目地址：https://github.com/EDDYCJY/fake-useragent</p>
<h2 id="支持">支持</h2>
<ul>
<li>All User-Agent Random</li>
<li>Chrome</li>
<li>InternetExplorer (IE)</li>
<li>Firefox</li>
<li>Safari</li>
<li>Android</li>
<li>MacOSX</li>
<li>IOS</li>
<li>Linux</li>
<li>IPhone</li>
<li>IPad</li>
<li>Computer</li>
<li>Mobile</li>
</ul>
<h2 id="安装">安装</h2>
<pre><code>$ go get github.com/EDDYCJY/fake-useragent
</code></pre><h2 id="用法">用法</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/fake-useragent&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 推荐使用
</span><span class="c1"></span>	<span class="nx">random</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">Random</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Random: %s&#34;</span><span class="p">,</span> <span class="nx">random</span><span class="p">)</span>

	<span class="nx">chrome</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">Chrome</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Chrome: %s&#34;</span><span class="p">,</span> <span class="nx">chrome</span><span class="p">)</span>

	<span class="nx">internetExplorer</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">InternetExplorer</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;IE: %s&#34;</span><span class="p">,</span> <span class="nx">internetExplorer</span><span class="p">)</span>

	<span class="nx">firefox</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">Firefox</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Firefox: %s&#34;</span><span class="p">,</span> <span class="nx">firefox</span><span class="p">)</span>

	<span class="nx">safari</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">Safari</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Safari: %s&#34;</span><span class="p">,</span> <span class="nx">safari</span><span class="p">)</span>

	<span class="nx">android</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">Android</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Android: %s&#34;</span><span class="p">,</span> <span class="nx">android</span><span class="p">)</span>

	<span class="nx">macOSX</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">MacOSX</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;MacOSX: %s&#34;</span><span class="p">,</span> <span class="nx">macOSX</span><span class="p">)</span>

	<span class="nx">ios</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">IOS</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;IOS: %s&#34;</span><span class="p">,</span> <span class="nx">ios</span><span class="p">)</span>

	<span class="nx">linux</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">Linux</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Linux: %s&#34;</span><span class="p">,</span> <span class="nx">linux</span><span class="p">)</span>

	<span class="nx">iphone</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">IPhone</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;IPhone: %s&#34;</span><span class="p">,</span> <span class="nx">iphone</span><span class="p">)</span>

	<span class="nx">ipad</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">IPad</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;IPad: %s&#34;</span><span class="p">,</span> <span class="nx">ipad</span><span class="p">)</span>

	<span class="nx">computer</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">Computer</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Computer: %s&#34;</span><span class="p">,</span> <span class="nx">computer</span><span class="p">)</span>

	<span class="nx">mobile</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">Mobile</span><span class="p">()</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Mobile: %s&#34;</span><span class="p">,</span> <span class="nx">mobile</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="定制">定制</h3>
<p>你可以调整抓取数据源的最大页数、时间间隔以及最大超时时间。 如果不填写，则为默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">client</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nx">Client</span><span class="p">{</span>
	<span class="nx">MaxPage</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
	<span class="nx">Delay</span><span class="p">:</span> <span class="mi">200</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">,</span>
	<span class="nx">Timeout</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">cache</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nx">Cache</span><span class="p">{}</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">NewBrowser</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">cache</span><span class="p">)</span>

<span class="nx">random</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Random</span><span class="p">()</span>
</code></pre></div><p>更新浏览器头的临时文件缓存</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">client</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
<span class="nx">cache</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nx">Cache</span><span class="p">{</span>
	<span class="nx">UpdateFile</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="nx">browser</span><span class="p">.</span><span class="nf">NewBrowser</span><span class="p">(</span><span class="nx">client</span><span class="p">,</span> <span class="nx">cache</span><span class="p">)</span>
</code></pre></div><p><strong>最后，建议常规用法就好，默认参数能够满足日常需求</strong></p>
<h2 id="输出">输出</h2>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Random: Mozilla/5.0 <span class="o">(</span>Macintosh<span class="p">;</span> Intel Mac OS X 10_13_2<span class="o">)</span> AppleWebKit/537.36 <span class="o">(</span>KHTML, like Gecko<span class="o">)</span> Chrome/63.0.3239.132 Safari/537.36

Chrome: Mozilla/5.0 <span class="o">(</span>Windows NT 10.0<span class="p">;</span> Win64<span class="p">;</span> x64<span class="o">)</span> AppleWebKit/537.36 <span class="o">(</span>KHTML, like Gecko<span class="o">)</span> Chrome/60.0.3112.113 Safari/537.36

IE: Mozilla/5.0 <span class="o">(</span>compatible<span class="p">;</span> MSIE 9.0<span class="p">;</span> Windows NT 6.1<span class="p">;</span> WOW64<span class="p">;</span> Trident/5.0<span class="o">)</span>

Firefox: Mozilla/5.0 <span class="o">(</span>Windows NT 6.3<span class="p">;</span> WOW64<span class="p">;</span> rv:41.0<span class="o">)</span> Gecko/20100101 Firefox/41.0

Safari: Mozilla/5.0 <span class="o">(</span>iPhone<span class="p">;</span> CPU iPhone OS 11_2_5 like Mac OS X<span class="o">)</span> AppleWebKit/604.5.6 <span class="o">(</span>KHTML, like Gecko<span class="o">)</span> Version/11.0 Mobile/15D60 Safari/604.1

Android: Mozilla/5.0 <span class="o">(</span>Linux<span class="p">;</span> Android 6.0<span class="p">;</span> MYA-L22 Build/HUAWEIMYA-L22<span class="o">)</span> AppleWebKit/537.36 <span class="o">(</span>KHTML, like Gecko<span class="o">)</span> Chrome/62.0.3202.84 Mobile Safari/537.36

MacOSX: Mozilla/5.0 <span class="o">(</span>Macintosh<span class="p">;</span> Intel Mac OS X 10_10_5<span class="o">)</span> AppleWebKit/602.2.14 <span class="o">(</span>KHTML, like Gecko<span class="o">)</span> Version/10.0.1 Safari/602.2.14

IOS: Mozilla/5.0 <span class="o">(</span>iPhone<span class="p">;</span> CPU iPhone OS 10_1 like Mac OS X<span class="o">)</span> AppleWebKit/602.2.14 <span class="o">(</span>KHTML, like Gecko<span class="o">)</span> Version/10.0 Mobile/14B72 Safari/602.1

Linux: Mozilla/5.0 <span class="o">(</span>X11<span class="p">;</span> Linux x86_64<span class="p">;</span> rv:42.0<span class="o">)</span> Gecko/20100101 Firefox/42.0

IPhone: Mozilla/5.0 <span class="o">(</span>iPhone<span class="p">;</span> CPU iPhone OS 10_2 like Mac OS X<span class="o">)</span> AppleWebKit/602.3.12 <span class="o">(</span>KHTML, like Gecko<span class="o">)</span> Version/10.0 Mobile/14C92 Safari/602.1

IPad: Mozilla/5.0 <span class="o">(</span>iPad<span class="p">;</span> CPU OS 5_0_1 like Mac OS X<span class="o">)</span> AppleWebKit/534.46 <span class="o">(</span>KHTML, like Gecko<span class="o">)</span> Version/5.1 Mobile/9A405 Safari/7534.48.3

Computer: Mozilla/5.0 <span class="o">(</span>Windows NT 10.0<span class="p">;</span> WOW64<span class="p">;</span> rv:54.0<span class="o">)</span> Gecko/20100101 Firefox/54.0

Mobile: Mozilla/5.0 <span class="o">(</span>Linux<span class="p">;</span> Android 7.0<span class="p">;</span> Redmi Note <span class="m">4</span> Build/NRD90M<span class="o">)</span> AppleWebKit/537.36 <span class="o">(</span>KHTML, like Gecko<span class="o">)</span> Chrome/63.0.3239.111 Mobile Safari/537.36
</code></pre></div><h2 id="注意">注意</h2>
<p>如果第一次使用，<a href="https://github.com/EDDYCJY/fake-useragent">fake-useragent</a> 将收集数据并在临时目录中创建一个文件作为文件缓存，请耐心等待几秒钟</p>
<h2 id="最后">最后</h2>
<p>如果在项目中发现了什么问题，欢迎提交 PR 或者 issue。希望你能够喜欢这个项目，根本目的还是为了解决痛点，欢迎 Star！😁</p>
<hr>
<p>项目地址：https://github.com/EDDYCJY/fake-useragent</p>
]]></content>
		</item>
		
		<item>
			<title>「连载十一」Cron定时任务</title>
			<link>https://eddycjy.com/posts/go/gin/2018-04-29-cron/</link>
			<pubDate>Sun, 29 Apr 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-04-29-cron/</guid>
			<description>知识点  完成定时任务的功能  本文目标 在实际的应用项目中，定时任务的使用是很常见的。你是否有过 Golang 如何做定时任务的疑问，莫非是轮询，在本文中我们将结合我们的项目讲述 Cron。
介绍 我们将使用 cron 这个包，它实现了 cron 规范解析器和任务运行器，简单来讲就是包含了定时任务所需的功能
Cron 表达式格式    字段名 是否必填 允许的值 允许的特殊字符     秒（Seconds） Yes 0-59 * / , -   分（Minutes） Yes 0-59 * / , -   时（Hours） Yes 0-23 * / , -   一个月中的某天（Day of month） Yes 1-31 * / , - ?   月（Month） Yes 1-12 or JAN-DEC * / , -   星期几（Day of week） Yes 0-6 or SUN-SAT * / , - ?</description>
			<content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<ul>
<li>完成定时任务的功能</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>在实际的应用项目中，定时任务的使用是很常见的。你是否有过 Golang 如何做定时任务的疑问，莫非是轮询，在本文中我们将结合我们的项目讲述 Cron。</p>
<h2 id="介绍">介绍</h2>
<p>我们将使用 <a href="https://github.com/robfig/cron">cron</a> 这个包，它实现了 cron 规范解析器和任务运行器，简单来讲就是包含了定时任务所需的功能</p>
<h3 id="cron-表达式格式">Cron 表达式格式</h3>
<table>
<thead>
<tr>
<th>字段名</th>
<th>是否必填</th>
<th>允许的值</th>
<th>允许的特殊字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>秒（Seconds）</td>
<td>Yes</td>
<td>0-59</td>
<td>* / , -</td>
</tr>
<tr>
<td>分（Minutes）</td>
<td>Yes</td>
<td>0-59</td>
<td>* / , -</td>
</tr>
<tr>
<td>时（Hours）</td>
<td>Yes</td>
<td>0-23</td>
<td>* / , -</td>
</tr>
<tr>
<td>一个月中的某天（Day of month）</td>
<td>Yes</td>
<td>1-31</td>
<td>* / , - ?</td>
</tr>
<tr>
<td>月（Month）</td>
<td>Yes</td>
<td>1-12 or JAN-DEC</td>
<td>* / , -</td>
</tr>
<tr>
<td>星期几（Day of week）</td>
<td>Yes</td>
<td>0-6 or SUN-SAT</td>
<td>* / , - ?</td>
</tr>
</tbody>
</table>
<p>Cron 表达式表示一组时间，使用 6 个空格分隔的字段</p>
<p>可以留意到 Golang 的 Cron 比 Crontab 多了一个秒级，以后遇到秒级要求的时候就省事了</p>
<h3 id="cron-特殊字符">Cron 特殊字符</h3>
<p>1、星号 ( * )</p>
<p>星号表示将匹配字段的所有值</p>
<p>2、斜线 ( / )</p>
<p>斜线用户 描述范围的增量，表现为 “N-MAX/x”，first-last/x 的形式，例如 3-59/15 表示此时的第三分钟和此后的每 15 分钟，到 59 分钟为止。即从 N 开始，使用增量直到该特定范围结束。它不会重复</p>
<p>3、逗号 ( , )</p>
<p>逗号用于分隔列表中的项目。例如，在 Day of week 使用“MON，WED，FRI”将意味着星期一，星期三和星期五</p>
<p>4、连字符 ( - )</p>
<p>连字符用于定义范围。例如，9 - 17 表示从上午 9 点到下午 5 点的每个小时</p>
<p>5、问号 ( ? )</p>
<p>不指定值，用于代替 “ * ”，类似 “ _ ” 的存在，不难理解</p>
<h3 id="预定义的-cron-时间表">预定义的 Cron 时间表</h3>
<table>
<thead>
<tr>
<th>输入</th>
<th>简述</th>
<th>相当于</th>
</tr>
</thead>
<tbody>
<tr>
<td>@yearly (or @annually)</td>
<td>1 月 1 日午夜运行一次</td>
<td>0 0 0 1 1 *</td>
</tr>
<tr>
<td>@monthly</td>
<td>每个月的午夜，每个月的第一个月运行一次</td>
<td>0 0 0 1 * *</td>
</tr>
<tr>
<td>@weekly</td>
<td>每周一次，周日午夜运行一次</td>
<td>0 0 0 * * 0</td>
</tr>
<tr>
<td>@daily (or @midnight)</td>
<td>每天午夜运行一次</td>
<td>0 0 0 * * *</td>
</tr>
<tr>
<td>@hourly</td>
<td>每小时运行一次</td>
<td>0 0 * * * *</td>
</tr>
</tbody>
</table>
<h2 id="安装">安装</h2>
<pre><code>$ go get -u github.com/robfig/cron
</code></pre><h2 id="实践">实践</h2>
<p>在上一章节 <a href="https://segmentfault.com/a/1190000014393602">Gin 实践 连载十 定制 GORM Callbacks</a> 中，我们使用了 GORM 的回调实现了软删除，同时也引入了另外一个问题</p>
<p>就是我怎么硬删除，我什么时候硬删除？这个往往与业务场景有关系，大致为</p>
<ul>
<li>另外有一套硬删除接口</li>
<li>定时任务清理（或转移、backup）无效数据</li>
</ul>
<p>在这里我们选用第二种解决方案来进行实践</p>
<h3 id="编写硬删除代码">编写硬删除代码</h3>
<p>打开 models 目录下的 tag.go、article.go 文件，分别添加以下代码</p>
<p>1、tag.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CleanAllTag</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">Unscoped</span><span class="p">().</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;deleted_on != ? &#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="nf">Delete</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Tag</span><span class="p">{})</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><p>2、article.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CleanAllArticle</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">Unscoped</span><span class="p">().</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;deleted_on != ? &#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="nf">Delete</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Article</span><span class="p">{})</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

</code></pre></div><p>注意硬删除要使用 <code>Unscoped()</code>，这是 GORM 的约定</p>
<h3 id="编写-cron">编写 Cron</h3>
<p>在 项目根目录下新建 cron.go 文件，用于编写定时任务的代码，写入文件内容</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;time&#34;</span>
	<span class="s">&#34;log&#34;</span>

	<span class="s">&#34;github.com/robfig/cron&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/models&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Starting...&#34;</span><span class="p">)</span>

	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">cron</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">AddFunc</span><span class="p">(</span><span class="s">&#34;* * * * * *&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Run models.CleanAllTag...&#34;</span><span class="p">)</span>
		<span class="nx">models</span><span class="p">.</span><span class="nf">CleanAllTag</span><span class="p">()</span>
	<span class="p">})</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">AddFunc</span><span class="p">(</span><span class="s">&#34;* * * * * *&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Run models.CleanAllArticle...&#34;</span><span class="p">)</span>
		<span class="nx">models</span><span class="p">.</span><span class="nf">CleanAllArticle</span><span class="p">()</span>
	<span class="p">})</span>

	<span class="nx">c</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>

	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">t1</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
			<span class="nx">t1</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这段程序中，我们做了如下的事情</p>
<h4 id="cronnew">cron.New()</h4>
<p>会根据本地时间创建一个新（空白）的 Cron job runner</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">()</span> <span class="o">*</span><span class="nx">Cron</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">NewWithLocation</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Location</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// NewWithLocation returns a new Cron job runner.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewWithLocation</span><span class="p">(</span><span class="nx">location</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Location</span><span class="p">)</span> <span class="o">*</span><span class="nx">Cron</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Cron</span><span class="p">{</span>
		<span class="nx">entries</span><span class="p">:</span>  <span class="kc">nil</span><span class="p">,</span>
		<span class="nx">add</span><span class="p">:</span>      <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Entry</span><span class="p">),</span>
		<span class="nx">stop</span><span class="p">:</span>     <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
		<span class="nx">snapshot</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Entry</span><span class="p">),</span>
		<span class="nx">running</span><span class="p">:</span>  <span class="kc">false</span><span class="p">,</span>
		<span class="nx">ErrorLog</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
		<span class="nx">location</span><span class="p">:</span> <span class="nx">location</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="caddfunc">c.AddFunc()</h4>
<p>AddFunc 会向 Cron job runner 添加一个 func ，以按给定的时间表运行</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">AddJob</span><span class="p">(</span><span class="nx">spec</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cmd</span> <span class="nx">Job</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">schedule</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Parse</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Schedule</span><span class="p">(</span><span class="nx">schedule</span><span class="p">,</span> <span class="nx">cmd</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>会首先解析时间表，如果填写有问题会直接 err，无误则将 func 添加到 Schedule 队列中等待执行</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">Schedule</span><span class="p">(</span><span class="nx">schedule</span> <span class="nx">Schedule</span><span class="p">,</span> <span class="nx">cmd</span> <span class="nx">Job</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">entry</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Entry</span><span class="p">{</span>
		<span class="nx">Schedule</span><span class="p">:</span> <span class="nx">schedule</span><span class="p">,</span>
		<span class="nx">Job</span><span class="p">:</span>      <span class="nx">cmd</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">running</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">entries</span><span class="p">,</span> <span class="nx">entry</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">add</span> <span class="o">&lt;-</span> <span class="nx">entry</span>
<span class="p">}</span>
</code></pre></div><p>3、c.Start()</p>
<p>在当前执行的程序中启动 Cron 调度程序。其实这里的主体是 goroutine + for + select + timer 的调度控制哦</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cron</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">running</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">running</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h4 id="timenewtimer--for--select--t1reset">time.NewTimer + for + select + t1.Reset</h4>
<p>如果你是初学者，大概会有疑问，这是干嘛用的？</p>
<p>**（1）time.NewTimer **</p>
<p>会创建一个新的定时器，持续你设定的时间 d 后发送一个 channel 消息</p>
<p><strong>（2）for + select</strong></p>
<p>阻塞 select 等待 channel</p>
<p><strong>（3）t1.Reset</strong></p>
<p>会重置定时器，让它重新开始计时</p>
<p>注：本文适用于 “t.C 已经取走，可直接使用 Reset”。</p>
<hr>
<p>总的来说，这段程序是为了阻塞主程序而编写的，希望你带着疑问来想，有没有别的办法呢？</p>
<p>有的，你直接 <code>select{}</code> 也可以完成这个需求 :)</p>
<h2 id="验证">验证</h2>
<pre><code>$ go run cron.go
2018/04/29 17:03:34 [info] replacing callback `gorm:update_time_stamp` from /Users/eddycjy/go/src/github.com/EDDYCJY/go-gin-example/models/models.go:56
2018/04/29 17:03:34 [info] replacing callback `gorm:update_time_stamp` from /Users/eddycjy/go/src/github.com/EDDYCJY/go-gin-example/models/models.go:57
2018/04/29 17:03:34 [info] replacing callback `gorm:delete` from /Users/eddycjy/go/src/github.com/EDDYCJY/go-gin-example/models/models.go:58
2018/04/29 17:03:34 Starting...
2018/04/29 17:03:35 Run models.CleanAllArticle...
2018/04/29 17:03:35 Run models.CleanAllTag...
2018/04/29 17:03:36 Run models.CleanAllArticle...
2018/04/29 17:03:36 Run models.CleanAllTag...
2018/04/29 17:03:37 Run models.CleanAllTag...
2018/04/29 17:03:37 Run models.CleanAllArticle...
</code></pre><p>检查输出日志正常，模拟已软删除的数据，定时任务工作 OK</p>
<h2 id="小结">小结</h2>
<p>定时任务很常见，希望你通过本文能够熟知 Golang 怎么实现一个简单的定时任务调度管理</p>
<p>可以不依赖系统的 Crontab 设置，指不定哪一天就用上了呢</p>
<h2 id="问题">问题</h2>
<p>如果你手动修改计算机的系统时间，是会导致定时任务错乱的，所以一般不要乱来。</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 02 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>了解一下Golang的市场行情</title>
			<link>https://eddycjy.com/posts/go/crawler/2018-04-28-go2018/</link>
			<pubDate>Sat, 28 Apr 2018 12:30:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/crawler/2018-04-28-go2018/</guid>
			<description>项目地址：https://github.com/go-crawler/lagou_jobs
如果对你有所帮助，欢迎 Star，给文章来波赞，这样可以让更多的人看见 :)
目标 在工作中 Golang 已是一份子，想让大家了解一下 Golang 的市场行情，也想让更多的人熟悉它。因此主要是展示数据分析的结果
目标站点是 某招聘网站 的职位数据抓取和分析，爬取城市分别为 北京、上海、广州、深圳、杭州、成都，再得出一个结论
分析 首先需要进行页面分析，找到我们的抓取方向
搜索 golang 关键字，打开页面 F12 就能看到它发送了四个请求，留意 positionAjax.json 这个请求
我们仔细研判这个接口的入参和出参
入参 1、Query String Param
  city：请求的城市
  needAddtionalResult：是否需要补充额外的参数，这里默认 false
  2、Form Data
 first：是否首页 pn：页码 kd：关键字  出参 就是它了，从返回结果可得出许多有用的信息
 companyFullName：公司全称 companyLabelList：公司标签 companyShortName：公司简称 companySize：公司规模 education：学历要求 financeStage：融资阶段  等等~
分页 在上面两张图中，可以发现在 content 节点中包含 pageNo、pageSize 字段，content.positionResult 节点有 totalCount 字段，可以得知当前是第几页，每页显示多少条，当前的职位总条数
需要注意一下，分页的计算是要向上取整的
模拟浏览器头 User-Agent 可以用 fake-useragent 这个项目来随机生成 UA 头 😄</description>
			<content type="html"><![CDATA[<p>项目地址：https://github.com/go-crawler/lagou_jobs</p>
<p>如果对你有所帮助，欢迎 Star，给文章来波赞，这样可以让更多的人看见  :)</p>
<h2 id="目标">目标</h2>
<p>在工作中 Golang 已是一份子，想让大家了解一下 Golang 的市场行情，也想让更多的人熟悉它。因此主要是展示数据分析的结果</p>
<p>目标站点是 <a href="https://www.lagou.com/">某招聘网站</a> 的职位数据抓取和分析，爬取城市分别为 北京、上海、广州、深圳、杭州、成都，再得出一个结论</p>
<h3 id="分析">分析</h3>
<p>首先需要进行页面分析，找到我们的抓取方向</p>
<p><img src="https://i.loli.net/2018/04/26/5ae1e28a3412a.jpeg" alt="image"></p>
<p>搜索 golang 关键字，打开页面 F12 就能看到它发送了四个请求，留意 positionAjax.json 这个请求</p>
<p><img src="https://i.loli.net/2018/04/26/5ae1efe538791.jpeg" alt="image"></p>
<p>我们仔细研判这个接口的入参和出参</p>
<h3 id="入参">入参</h3>
<p>1、Query String Param</p>
<ul>
<li>
<p>city：请求的城市</p>
</li>
<li>
<p>needAddtionalResult：是否需要补充额外的参数，这里默认 false</p>
</li>
</ul>
<p>2、Form Data</p>
<ul>
<li>first：是否首页</li>
<li>pn：页码</li>
<li>kd：关键字</li>
</ul>
<h3 id="出参">出参</h3>
<p><img src="https://i.loli.net/2018/04/26/5ae1f4c9920a9.jpeg" alt="image"></p>
<p>就是它了，从返回结果可得出许多有用的信息</p>
<ul>
<li>companyFullName：公司全称</li>
<li>companyLabelList：公司标签</li>
<li>companyShortName：公司简称</li>
<li>companySize：公司规模</li>
<li>education：学历要求</li>
<li>financeStage：融资阶段</li>
</ul>
<p>等等~</p>
<h3 id="分页">分页</h3>
<p>在上面两张图中，可以发现在 content 节点中包含 pageNo、pageSize 字段，content.positionResult 节点有 totalCount 字段，可以得知当前是第几页，每页显示多少条，当前的职位总条数</p>
<p>需要注意一下，分页的计算是要向上取整的</p>
<h2 id="模拟浏览器头">模拟浏览器头</h2>
<p>User-Agent 可以用 <a href="https://github.com/EDDYCJY/fake-useragent">fake-useragent</a> 这个项目来随机生成 UA 头 😄</p>
<h2 id="数据">数据</h2>
<h3 id="一分布图">一、分布图</h3>
<p>不同工作、工种，自然也会遍布在不同的工作区域，我们先了解一下各个城市的 Golang 工程师都主要在哪个区上班，心里留个底</p>
<h4 id="北京">北京</h4>
<p><img src="https://i.loli.net/2018/04/27/5ae291859667c.jpeg" alt="image"></p>
<h4 id="上海">上海</h4>
<p><img src="https://i.loli.net/2018/04/27/5ae290856b774.jpeg" alt="image"></p>
<h4 id="广州">广州</h4>
<p><img src="https://i.loli.net/2018/04/27/5ae28f1ab3e0c.jpeg" alt="image"></p>
<h4 id="深圳">深圳</h4>
<p><img src="https://i.loli.net/2018/04/27/5ae1fbebb1784.jpeg" alt="image"></p>
<h4 id="杭州">杭州</h4>
<p><img src="https://i.loli.net/2018/04/27/5ae29218c91dc.jpeg" alt="image"></p>
<h4 id="成都">成都</h4>
<p><img src="https://i.loli.net/2018/04/27/5ae295b1059ed.jpeg" alt="image"></p>
<h3 id="二招聘与职位数量对比">二、招聘与职位数量对比</h3>
<p><img src="https://i.loli.net/2018/04/27/5ae296b750dd8.png" alt="image"></p>
<p>通过分析图中的数据，我们可以得知各城市的招聘职位数量</p>
<ul>
<li>北京：348</li>
<li>上海：145</li>
<li>广州：37</li>
<li>成都：49</li>
<li>杭州：45</li>
<li>深圳：108</li>
</ul>
<p>总共招聘的职位数量为 732 个，数量顺序分别为 北京 &gt; 上海 &gt; 深圳 &gt; 成都 &gt; 杭州 &gt; 广州</p>
<p>还有另外一个关注点，就是招聘公司数量与职位的数量对比，可以看到 北京 招聘的职位数量为 348 个，而招聘的公司数量为 191 个，约为 1.82 的比例，也就是一家公司能提供两个 Golang 职位，它可能类别不同、（中级、中高级、高级）级别不同，具有一定可能性。而在广州，为 31 对比 37，虽然差额不大，但仍然存在这种现象</p>
<p>可以得出结果，Golang 在市场上具有一定的伸缩空间，也就是具有上升空间，一家公司会将 Golang 应用在多个不同的应用场景，也就是方向不同，需要的级别人才也就不同了</p>
<p>但是需要注意的是，Golang 的市场招聘人数目前份额还是较低，六个城市总数仅为 732 个，与其他大热语言相差有一定距离，需要谨慎</p>
<p>同时，面试 Golang 的人与其他大热语言相比会少些，职位的争夺是否小点呢？</p>
<h3 id="三招聘公司规模">三、招聘公司规模</h3>
<p><img src="https://i.loli.net/2018/04/27/5ae2ab2babbd9.png" alt="image"></p>
<p>通过查看招聘 Golang 工程师的公司规模，可以很直观的发现，微型公司使用 Golang 较少，其他类别的规模都有一定程度的应用，且差距不大。在 2000 人以上、50 - 150 人的公司规模中最受青睐</p>
<p>为什么呢，我认为有以下可能</p>
<ul>
<li>大型公司结合场景，想通过 Golang 的特性来解决一些痛点问题</li>
<li>在小型公司 Golang 这颗新星实施起来更便捷，有一定的应用场景</li>
</ul>
<p>你觉得呢，是不是应该有更多的选择它的原因？</p>
<h3 id="四学历要求">四、学历要求</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3dbTdP.png" alt="image"></p>
<p>在招聘市场上，Golang 的招聘者更希望你是本科学历，大专和不限也有一定的份额，但市场份额相差较大</p>
<p>硕士学历要求的为两个，可以得出，在市场上 Golang 招聘者们对高学历的需求并不高，或者并不强制高学历</p>
<h3 id="五行业领域">五、行业领域</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3dqPiT.png" alt="image"></p>
<p>在这里，重点关注 Golang 工程师的招聘公司都分别在什么行业领域，大头移动互联网是不容置疑的了，还可以惊喜的发现</p>
<ul>
<li>数据服务</li>
<li>电子商务</li>
<li>金融</li>
<li>企业服务</li>
<li>游戏</li>
</ul>
<p>Golang 在这几个方面都有所应用，说明了在市场上，Golang 的路子是比较广阔的，前景不错</p>
<p>同时，如果可以涉及多个领域的内容，想必身为工程师的你，肯定很激动</p>
<h3 id="六职位诱惑">六、职位诱惑</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3dqEQJ.png" alt="image"></p>
<p>职位诱惑是投简历时必看的一点了，可以看到高频词条基本都是 IT 从业者关心的话题了，这里你懂的&hellip;</p>
<p>重点，我看到了一个 “免费三餐” 的词条命中 7 次，分别来自北京的海淀区、东城区、朝阳区，上海的黄浦区的七家不同的公司，辛苦了</p>
<h3 id="七行业职位标签">七、行业、职位标签</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3dqlWD.png" alt="image"></p>
<p>在招聘 JD 中，描述和标签常用于给求职者了解这一职业的具体工作内容和其关联性</p>
<p>在图中你可以看到 Golang 常常和什么内容搭上边，这点很有意义哦</p>
<p>1、语言</p>
<ul>
<li>Java</li>
<li>Python</li>
<li>C/C++</li>
<li>PHP</li>
</ul>
<p>在图中可以看出，Golang 与以上四种语言有一定关联性，而 Java 和 Python 分别第一、第二名，可以说明市场上对复合型人才的渴望度更高，也许你不懂也行，但你懂了就最好（加分项）。需要你自身有多语言的经验，也便于和其他人对接</p>
<p>同时 Golang 目前存在许多内部转语言写的情况，所以这一点可以参考</p>
<p>2、职称</p>
<ul>
<li>高级</li>
<li>资深</li>
<li>中级</li>
</ul>
<p>特意将职称放在第二位，可以发现在市场上 Golang 标签的需求是 高级 &gt; 资深 &gt; 中级，关联第一项 “语言关联” 不难得出这个结论，因为语言只是解决问题的工具，到了中级及以上的工程师都是懂多门语言的居多，再采取不同的方案去解决应用场景上的问题</p>
<p>可得出结论，市场目前对 Golang 更期望是中高、高级、资深的人才，而中级的反而少一点点</p>
<p>大家可以努力再往上冲击冲击</p>
<p>3、组件</p>
<ul>
<li>Linux</li>
<li>Redis</li>
<li>Mysql</li>
</ul>
<p>4、行业</p>
<ul>
<li>云计算</li>
<li>信息安全</li>
<li>大数据</li>
<li>金融</li>
<li>软件开发</li>
</ul>
<h4 id="八薪资与工作年限">八、薪资与工作年限</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3dq3Se.jpg" alt="image"></p>
<p>1、1-3 年</p>
<p>一个（成长）特殊的阶段，有个位数也有双位数的，大头可以到 15-30k，20-40k，而初级的也有 8-16k</p>
<p>2、3-5 年</p>
<p>厚积待发的阶段，薪酬范畴的跨度是较大，10-60k 的薪酬都有，这充分说明能力决定你的上下</p>
<p>3、5-10 年</p>
<p>核心，招聘网站上的招聘数量反而少，都会走内推或猎头，不需要特别介绍了</p>
<h5 id="小结">小结</h5>
<p>这一部分，相信是很多人关注的地方</p>
<p>在有的文章中会看到，他们的薪资部分是以平均值来展示的。我就很纳闷，因为对平均值并不是很关心，<strong>重点是无法体现薪资幅度</strong>。因此这里我会尽可能的把数据展现给你们看</p>
<p>（正文）从图表来看，Golang 当前的薪酬水平还是很不错的，市场能根据不同阶段（水平）的人给出一个好的价位</p>
<p>（题外话）看完之后希望你能知道以下内容</p>
<ul>
<li>你当前工作年限的最高、最低薪资范畴</li>
<li>你的下一阶段的薪资范畴</li>
<li>为什么有的人高，有的人低</li>
<li>在大头部队还是小头，为什么</li>
<li>不要满足于平均值</li>
</ul>
<h3 id="九融资阶段">九、融资阶段</h3>
<p><img src="https://s2.ax1x.com/2020/02/27/3dqteI.png" alt="image"></p>
<p>选用 Golang 的公司大多数都较为稳定，有一部分比较刺激 :)</p>
<h4 id="融资阶段与薪资范畴对比">融资阶段与薪资范畴对比</h4>
<h5 id="不需要融资">不需要融资</h5>
<p><img src="https://s2.ax1x.com/2020/02/27/3dqyOs.png" alt="image"></p>
<h5 id="上市公司">上市公司</h5>
<p><img src="https://s2.ax1x.com/2020/02/27/3dqWkV.png" alt="image"></p>
<h5 id="a-轮">A 轮</h5>
<p><img src="https://s2.ax1x.com/2020/02/27/3dqfYT.png" alt="image"></p>
<h5 id="b-轮">B 轮</h5>
<p><img src="https://s2.ax1x.com/2020/02/27/3dqTX9.png" alt="image"></p>
<h5 id="c-轮">C 轮</h5>
<p><img src="https://s2.ax1x.com/2020/02/27/3dqOk6.png" alt="image"></p>
<h5 id="d-轮以上">D 轮以上</h5>
<p><img src="https://s2.ax1x.com/2020/02/27/3dqz1e.png" alt="image"></p>
<h3 id="十附近的地铁">十、附近的地铁</h3>
<p>Golang 工程师都驻扎在什么地铁站附近呢</p>
<p>经常在地铁上看到同行在看代码，来了解一下都分布在哪 :)</p>
<h4 id="北京-1">北京</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLCnA.png" alt="image"></p>
<h4 id="上海-1">上海</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLkAP.png" alt="image"></p>
<h4 id="广州-1">广州</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLAtf.png" alt="image"></p>
<h4 id="深圳-1">深圳</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLZ9S.png" alt="image"></p>
<h4 id="杭州-1">杭州</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLKns.png" alt="image"></p>
<h4 id="成都-1">成都</h4>
<p><img src="https://s2.ax1x.com/2020/02/27/3dL3NV.png" alt="image"></p>
<h2 id="结论">结论</h2>
<p>如同官方所说 &ldquo;Go has been on an amazing journey over the last 8+ years&rdquo;，作为一门新生语言，一直在不断地发展，<strong>缺点肯定是有的，你要去识别它</strong></p>
<h3 id="从数量来看">从数量来看</h3>
<p>单从这个招聘网站上来看，数量方面，与大热语言的招聘职位数量仍然有一定的差距，但 Golang 存在许多内部转语言开发的情况，当前展现出来的数据，<strong>招聘数量不多，但质量不错</strong></p>
<h3 id="从分布图来看">从分布图来看</h3>
<p>一线城市基本都有 Golang 的职位，虽然其他城市较少，但对于新语言来说是需要持续关注的过程，不能一刀切</p>
<h3 id="从职称级别来看">从职称级别来看</h3>
<p>Golang 中高、高级、资深仍然是占大头，给的薪资也基本符合市场行情</p>
<h3 id="从方向来看">从方向来看</h3>
<p>Golang 涉及的行业领域广泛，移动互联网、数据服务、电子商务、金融、企业服务、云计算等都是它的战场之一</p>
<h3 id="从开源项目来看">从开源项目来看</h3>
<p>docker、k8s、etcd、consul 都挺稳</p>
<hr>
<p>总的来说，Golang 处于一个发展的阶段，市场行情也还行、应用场景较广，不过招聘数量不多，你又怎么看呢？</p>
<p>最后放上今天新发布的 Logo :)</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLY3F.jpg" alt="image"></p>
<p>如果对你有所帮助，欢迎 Star，给文章点个赞，这样可以让更多的人看见这篇文章</p>
<h2 id="参考">参考</h2>
<ul>
<li>项目地址：https://github.com/go-crawler/lagou_jobs</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载十」定制 GORM Callbacks</title>
			<link>https://eddycjy.com/posts/go/gin/2018-04-15-gorm-callback/</link>
			<pubDate>Sun, 15 Apr 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-04-15-gorm-callback/</guid>
			<description>涉及知识点  GORM  本文目标  GORM itself is powered by Callbacks, so you could fully customize GORM as you want
 GORM 本身是由回调驱动的，所以我们可以根据需要完全定制 GORM，以此达到我们的目的，如下：
 注册一个新的回调 删除现有的回调 替换现有的回调 注册回调的顺序  在 GORM 中包含以上四类 Callbacks，我们结合项目选用 “替换现有的回调” 来解决一个小痛点。
问题 在 models 目录下，我们包含 tag.go 和 article.go 两个文件，他们有一个问题，就是 BeforeCreate、BeforeUpdate 重复出现了，那难道 100 个文件，就要写一百次吗？
1、tag.go
2、article.go
显然这是不可能的，如果先前你已经意识到这个问题，那挺 OK，但没有的话，现在开始就要改
解决 在这里我们通过 Callbacks 来实现功能，不需要一个个文件去编写
实现 Callbacks 打开 models 目录下的 models.go 文件，实现以下两个方法：
1、updateTimeStampForCreateCallback
// updateTimeStampForCreateCallback will set `CreatedOn`, `ModifiedOn` when creating func updateTimeStampForCreateCallback(scope *gorm.</description>
			<content type="html"><![CDATA[<h2 id="涉及知识点">涉及知识点</h2>
<ul>
<li>GORM</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<blockquote>
<p>GORM itself is powered by Callbacks, so you could fully customize GORM as you want</p>
</blockquote>
<p>GORM 本身是由回调驱动的，所以我们可以根据需要完全定制 GORM，以此达到我们的目的，如下：</p>
<ul>
<li>注册一个新的回调</li>
<li>删除现有的回调</li>
<li>替换现有的回调</li>
<li>注册回调的顺序</li>
</ul>
<p>在 GORM 中包含以上四类 Callbacks，我们结合项目选用 “替换现有的回调” 来解决一个小痛点。</p>
<h2 id="问题">问题</h2>
<p>在 models 目录下，我们包含 tag.go 和 article.go 两个文件，他们有一个问题，就是 BeforeCreate、BeforeUpdate 重复出现了，那难道 100 个文件，就要写一百次吗？</p>
<p>1、tag.go</p>
<p><img src="https://i.loli.net/2018/04/14/5ad20efdba409.jpg" alt="image"></p>
<p>2、article.go</p>
<p><img src="https://i.loli.net/2018/04/14/5ad20ebacc4c9.jpg" alt="image"></p>
<p>显然这是不可能的，如果先前你已经意识到这个问题，那挺 OK，但没有的话，现在开始就要改</p>
<h3 id="解决">解决</h3>
<p>在这里我们通过 Callbacks 来实现功能，不需要一个个文件去编写</p>
<h3 id="实现-callbacks">实现 Callbacks</h3>
<p>打开 models 目录下的 models.go 文件，实现以下两个方法：</p>
<p>1、updateTimeStampForCreateCallback</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// updateTimeStampForCreateCallback will set `CreatedOn`, `ModifiedOn` when creating
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">updateTimeStampForCreateCallback</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">scope</span><span class="p">.</span><span class="nf">HasError</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">nowTime</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">createTimeField</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">FieldByName</span><span class="p">(</span><span class="s">&#34;CreatedOn&#34;</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">createTimeField</span><span class="p">.</span><span class="nx">IsBlank</span> <span class="p">{</span>
                <span class="nx">createTimeField</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">nowTime</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">modifyTimeField</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">FieldByName</span><span class="p">(</span><span class="s">&#34;ModifiedOn&#34;</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">modifyTimeField</span><span class="p">.</span><span class="nx">IsBlank</span> <span class="p">{</span>
                <span class="nx">modifyTimeField</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">nowTime</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这段方法中，会完成以下功能</p>
<ul>
<li>检查是否有含有错误（db.Error）</li>
<li><code>scope.FieldByName</code> 通过 <code>scope.Fields()</code> 获取所有字段，判断当前是否包含所需字段</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">field</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">Fields</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">field</span><span class="p">.</span><span class="nx">Name</span> <span class="o">==</span> <span class="nx">name</span> <span class="o">||</span> <span class="nx">field</span><span class="p">.</span><span class="nx">DBName</span> <span class="o">==</span> <span class="nx">name</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">field</span><span class="p">,</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">field</span><span class="p">.</span><span class="nx">DBName</span> <span class="o">==</span> <span class="nx">dbName</span> <span class="p">{</span>
        <span class="nx">mostMatchedField</span> <span class="p">=</span> <span class="nx">field</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>field.IsBlank</code> 可判断该字段的值是否为空</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isBlank</span><span class="p">(</span><span class="nx">value</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">value</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">!</span><span class="nx">value</span><span class="p">.</span><span class="nf">Bool</span><span class="p">()</span>
    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int16</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int64</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nf">Int</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint8</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint16</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uint64</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Uintptr</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nf">Uint</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Float32</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Float64</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nf">Float</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Interface</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nf">IsNil</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nf">Interface</span><span class="p">(),</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">Zero</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nf">Type</span><span class="p">()).</span><span class="nf">Interface</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>若为空则 <code>field.Set</code> 用于给该字段设置值，参数为 <code>interface{}</code></li>
</ul>
<p>2、updateTimeStampForUpdateCallback</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// updateTimeStampForUpdateCallback will set `ModifyTime` when updating
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">updateTimeStampForUpdateCallback</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;gorm:update_column&#34;</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">scope</span><span class="p">.</span><span class="nf">SetColumn</span><span class="p">(</span><span class="s">&#34;ModifiedOn&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>scope.Get(...)</code> 根据入参获取设置了字面值的参数，例如本文中是 <code>gorm:update_column</code> ，它会去查找含这个字面值的字段属性</li>
<li><code>scope.SetColumn(...)</code> 假设没有指定 <code>update_column</code> 的字段，我们默认在更新回调设置 <code>ModifiedOn</code> 的值</li>
</ul>
<h3 id="注册-callbacks">注册 Callbacks</h3>
<p>在上面小节我已经把回调方法编写好了，接下来需要将其注册进 GORM 的钩子里，但其本身自带 Create 和 Update 回调，因此调用替换即可</p>
<p>在 models.go 的 init 函数中，增加以下语句</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">db</span><span class="p">.</span><span class="nf">Callback</span><span class="p">().</span><span class="nf">Create</span><span class="p">().</span><span class="nf">Replace</span><span class="p">(</span><span class="s">&#34;gorm:update_time_stamp&#34;</span><span class="p">,</span> <span class="nx">updateTimeStampForCreateCallback</span><span class="p">)</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Callback</span><span class="p">().</span><span class="nf">Update</span><span class="p">().</span><span class="nf">Replace</span><span class="p">(</span><span class="s">&#34;gorm:update_time_stamp&#34;</span><span class="p">,</span> <span class="nx">updateTimeStampForUpdateCallback</span><span class="p">)</span>
</code></pre></div><h3 id="验证">验证</h3>
<p>访问 AddTag 接口，成功后检查数据库，可发现 <code>created_on</code> 和 <code>modified_on</code> 字段都为当前执行时间</p>
<p>访问 EditTag 接口，可发现 <code>modified_on</code> 为最后一次执行更新的时间</p>
<h2 id="拓展">拓展</h2>
<p>我们想到，在实际项目中硬删除是较少存在的，那么是否可以通过 Callbacks 来完成这个功能呢？</p>
<p>答案是可以的，我们在先前 <code>Model struct</code> 增加 <code>DeletedOn</code> 变量</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Model</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span> <span class="kt">int</span> <span class="s">`gorm:&#34;primary_key&#34; json:&#34;id&#34;`</span>
    <span class="nx">CreatedOn</span> <span class="kt">int</span> <span class="s">`json:&#34;created_on&#34;`</span>
    <span class="nx">ModifiedOn</span> <span class="kt">int</span> <span class="s">`json:&#34;modified_on&#34;`</span>
    <span class="nx">DeletedOn</span> <span class="kt">int</span> <span class="s">`json:&#34;deleted_on&#34;`</span>
<span class="p">}</span>
</code></pre></div><h3 id="实现-callbacks-1">实现 Callbacks</h3>
<p>打开 models 目录下的 models.go 文件，实现以下方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">deleteCallback</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">scope</span><span class="p">.</span><span class="nf">HasError</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">extraOption</span> <span class="kt">string</span>
        <span class="k">if</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;gorm:delete_option&#34;</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">extraOption</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">deletedOnField</span><span class="p">,</span> <span class="nx">hasDeletedOnField</span> <span class="o">:=</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">FieldByName</span><span class="p">(</span><span class="s">&#34;DeletedOn&#34;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">!</span><span class="nx">scope</span><span class="p">.</span><span class="nx">Search</span><span class="p">.</span><span class="nx">Unscoped</span> <span class="o">&amp;&amp;</span> <span class="nx">hasDeletedOnField</span> <span class="p">{</span>
            <span class="nx">scope</span><span class="p">.</span><span class="nf">Raw</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span>
                <span class="s">&#34;UPDATE %v SET %v=%v%v%v&#34;</span><span class="p">,</span>
                <span class="nx">scope</span><span class="p">.</span><span class="nf">QuotedTableName</span><span class="p">(),</span>
                <span class="nx">scope</span><span class="p">.</span><span class="nf">Quote</span><span class="p">(</span><span class="nx">deletedOnField</span><span class="p">.</span><span class="nx">DBName</span><span class="p">),</span>
                <span class="nx">scope</span><span class="p">.</span><span class="nf">AddToVars</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()),</span>
                <span class="nf">addExtraSpaceIfExist</span><span class="p">(</span><span class="nx">scope</span><span class="p">.</span><span class="nf">CombinedConditionSql</span><span class="p">()),</span>
                <span class="nf">addExtraSpaceIfExist</span><span class="p">(</span><span class="nx">extraOption</span><span class="p">),</span>
            <span class="p">)).</span><span class="nf">Exec</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">scope</span><span class="p">.</span><span class="nf">Raw</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span>
                <span class="s">&#34;DELETE FROM %v%v%v&#34;</span><span class="p">,</span>
                <span class="nx">scope</span><span class="p">.</span><span class="nf">QuotedTableName</span><span class="p">(),</span>
                <span class="nf">addExtraSpaceIfExist</span><span class="p">(</span><span class="nx">scope</span><span class="p">.</span><span class="nf">CombinedConditionSql</span><span class="p">()),</span>
                <span class="nf">addExtraSpaceIfExist</span><span class="p">(</span><span class="nx">extraOption</span><span class="p">),</span>
            <span class="p">)).</span><span class="nf">Exec</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">addExtraSpaceIfExist</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">str</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="nx">str</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>scope.Get(&quot;gorm:delete_option&quot;)</code> 检查是否手动指定了 delete_option</li>
<li><code>scope.FieldByName(&quot;DeletedOn&quot;)</code> 获取我们约定的删除字段，若存在则 <code>UPDATE</code> 软删除，若不存在则 <code>DELETE</code> 硬删除</li>
<li><code>scope.QuotedTableName()</code> 返回引用的表名，这个方法 GORM 会根据自身逻辑对表名进行一些处理</li>
<li><code>scope.CombinedConditionSql()</code> 返回组合好的条件 SQL，看一下方法原型很明了</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">Scope</span><span class="p">)</span> <span class="nf">CombinedConditionSql</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">joinSQL</span> <span class="o">:=</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">joinsSQL</span><span class="p">()</span>
    <span class="nx">whereSQL</span> <span class="o">:=</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">whereSQL</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">scope</span><span class="p">.</span><span class="nx">Search</span><span class="p">.</span><span class="nx">raw</span> <span class="p">{</span>
        <span class="nx">whereSQL</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSuffix</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">TrimPrefix</span><span class="p">(</span><span class="nx">whereSQL</span><span class="p">,</span> <span class="s">&#34;WHERE (&#34;</span><span class="p">),</span> <span class="s">&#34;)&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">joinSQL</span> <span class="o">+</span> <span class="nx">whereSQL</span> <span class="o">+</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">groupSQL</span><span class="p">()</span> <span class="o">+</span>
        <span class="nx">scope</span><span class="p">.</span><span class="nf">havingSQL</span><span class="p">()</span> <span class="o">+</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">orderSQL</span><span class="p">()</span> <span class="o">+</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">limitAndOffsetSQL</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>scope.AddToVars</code> 该方法可以添加值作为 SQL 的参数，也可用于防范 SQL 注入</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">Scope</span><span class="p">)</span> <span class="nf">AddToVars</span><span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">skipBindVar</span> <span class="o">:=</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">InstanceGet</span><span class="p">(</span><span class="s">&#34;skip_bindvar&#34;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">expr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="o">*</span><span class="nx">expr</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">exp</span> <span class="o">:=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">expr</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">args</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">skipBindVar</span> <span class="p">{</span>
                <span class="nx">scope</span><span class="p">.</span><span class="nf">AddToVars</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">exp</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="nx">exp</span><span class="p">,</span> <span class="s">&#34;?&#34;</span><span class="p">,</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">AddToVars</span><span class="p">(</span><span class="nx">arg</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">exp</span>
    <span class="p">}</span>

    <span class="nx">scope</span><span class="p">.</span><span class="nx">SQLVars</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">scope</span><span class="p">.</span><span class="nx">SQLVars</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">skipBindVar</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&#34;?&#34;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">Dialect</span><span class="p">().</span><span class="nf">BindVar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">scope</span><span class="p">.</span><span class="nx">SQLVars</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h3 id="注册-callbacks-1">注册 Callbacks</h3>
<p>在 models.go 的 init 函数中，增加以下删除的回调</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">db</span><span class="p">.</span><span class="nf">Callback</span><span class="p">().</span><span class="nf">Delete</span><span class="p">().</span><span class="nf">Replace</span><span class="p">(</span><span class="s">&#34;gorm:delete&#34;</span><span class="p">,</span> <span class="nx">deleteCallback</span><span class="p">)</span>
</code></pre></div><h3 id="验证-1">验证</h3>
<p>重启服务，访问 DeleteTag 接口，成功后即可发现 deleted_on 字段有值</p>
<h2 id="小结">小结</h2>
<p>在这一章节中，我们结合 GORM 完成了新增、更新、查询的 Callbacks，在实际项目中常常也是这么使用</p>
<p>毕竟，一个钩子的事，就没有必要自己手写过多不必要的代码了</p>
<p>（注意，增加了软删除后，先前的代码需要增加 <code>deleted_on</code> 的判断）</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h3 id="文档">文档</h3>
<ul>
<li><a href="http://gorm.io/docs/write_plugins.html">gorm</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>爬取汽车之家 二手车产品库</title>
			<link>https://eddycjy.com/posts/go/crawler/2018-04-01-cars/</link>
			<pubDate>Sun, 01 Apr 2018 12:30:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/crawler/2018-04-01-cars/</guid>
			<description>项目地址：https://github.com/go-crawler/car-prices
目标 最近经常有人在耳边提起汽车之家，也好奇二手车在国内的价格是怎么样的，因此本次的目标站点是 汽车之家 的二手车产品库
分析目标源：
 一页共 24 条 含分页，但这个老产品库，在 100 页后会存在问题，因此我们爬取 99 页 可以获取全部城市 共可爬取 19w+ 数据  开始 爬取步骤
 获取全部的城市 拼装全部城市 URL 入队列 解析二手车页面结构 下一页 URL 入队列 循环拉取所有分页的二手车数据 循环拉取队列中城市的二手车数据 等待，确定队列中无新的 URL 爬取的二手车数据入库  获取城市 通过页面查看，可发现在城市筛选区可得到全部的二手车城市列表，但是你仔细查阅代码。会发现它是 JS 加载进来的，城市也统一放在了一个变量中
有两种提取方法
 分析 JS 变量，提取出来 直接将 areaJson 复制出来作为变量解析  在这里我们直接将其复制粘贴出来即可，因为这是比较少变动的值
获取分页 通过分析页面可以得知分页链接是有一定规律的，例如：/2sc/hangzhou/a0_0msdgscncgpi1ltocsp2exb4/，可以发现 sp%d，sp 后面为页码
按照常理，可以通过预测所有分页链接，推入队列后 go routine 一波 即可快速拉取
但是在这老产品库存在一个问题，在超过 100 页后，下一页永远是 101 页
因此我们采取比较传统的做法，通过拉取下一页的链接去访问，以便适应可能的分页链接改变； 100 页以后的分页展示也很奇怪，先忽视
获取二手车数据 页面结构较为固定，常规的清洗 HTML 即可</description>
			<content type="html"><![CDATA[<p>项目地址：https://github.com/go-crawler/car-prices</p>
<h2 id="目标">目标</h2>
<p>最近经常有人在耳边提起汽车之家，也好奇二手车在国内的价格是怎么样的，因此本次的目标站点是 <a href="https://car.autohome.com.cn/2sc/440399/index.html">汽车之家</a> 的二手车产品库</p>
<p><img src="https://i.loli.net/2018/03/30/5abe47f82a01f.png" alt="image"></p>
<p>分析目标源：</p>
<ul>
<li>一页共 24 条</li>
<li>含分页，但这个老产品库，在 100 页后会存在问题，因此我们爬取 99 页</li>
<li>可以获取全部城市</li>
<li>共可爬取 19w+ 数据</li>
</ul>
<h2 id="开始">开始</h2>
<p>爬取步骤</p>
<ul>
<li>获取全部的城市</li>
<li>拼装全部城市 URL 入队列</li>
<li>解析二手车页面结构</li>
<li>下一页 URL 入队列</li>
<li>循环拉取所有分页的二手车数据</li>
<li>循环拉取队列中城市的二手车数据</li>
<li>等待，确定队列中无新的 URL</li>
<li>爬取的二手车数据入库</li>
</ul>
<h3 id="获取城市">获取城市</h3>
<p><img src="https://i.loli.net/2018/03/31/5abeff11ef583.png" alt="image"></p>
<p>通过页面查看，可发现在城市筛选区可得到全部的二手车城市列表，但是你仔细查阅代码。会发现它是 JS 加载进来的，城市也统一放在了一个变量中</p>
<p><img src="https://i.loli.net/2018/03/31/5abf056389cf0.png" alt="image"></p>
<p>有两种提取方法</p>
<ul>
<li>分析 JS 变量，提取出来</li>
<li>直接将 <code>areaJson</code> 复制出来作为变量解析</li>
</ul>
<p>在这里我们直接将其复制粘贴出来即可，因为这是比较少变动的值</p>
<h3 id="获取分页">获取分页</h3>
<p><img src="https://i.loli.net/2018/03/31/5abf08ec812e2.png" alt="image"></p>
<p>通过分析页面可以得知分页链接是有一定规律的，例如：<code>/2sc/hangzhou/a0_0msdgscncgpi1ltocsp2exb4/</code>，可以发现 <code>sp%d</code>，<code>sp</code> 后面为页码</p>
<p>按照常理，可以通过预测所有分页链接，推入队列后 <code>go routine</code> 一波 即可快速拉取</p>
<p>但是在这老产品库存在一个问题，在超过 100 页后，下一页永远是 101 页</p>
<p><img src="https://i.loli.net/2018/03/31/5abf0e1e623ec.png" alt="image"></p>
<p>因此我们采取比较传统的做法，通过拉取下一页的链接去访问，以便适应可能的分页链接改变； 100 页以后的分页展示也很奇怪，先忽视</p>
<h3 id="获取二手车数据">获取二手车数据</h3>
<p>页面结构较为固定，常规的清洗 HTML 即可</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetCars</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">goquery</span><span class="p">.</span><span class="nx">Document</span><span class="p">)</span> <span class="p">(</span><span class="nx">cars</span> <span class="p">[]</span><span class="nx">QcCar</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cityName</span> <span class="o">:=</span> <span class="nf">GetCityName</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
	<span class="nx">doc</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;.piclist ul li:not(.line)&#34;</span><span class="p">).</span><span class="nf">Each</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">selection</span> <span class="o">*</span><span class="nx">goquery</span><span class="p">.</span><span class="nx">Selection</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">title</span> <span class="o">:=</span> <span class="nx">selection</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;.title a&#34;</span><span class="p">).</span><span class="nf">Text</span><span class="p">()</span>
		<span class="nx">price</span> <span class="o">:=</span> <span class="nx">selection</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;.detail .detail-r&#34;</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;.colf8&#34;</span><span class="p">).</span><span class="nf">Text</span><span class="p">()</span>
		<span class="nx">kilometer</span> <span class="o">:=</span> <span class="nx">selection</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;.detail .detail-l&#34;</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;p&#34;</span><span class="p">).</span><span class="nf">Eq</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nf">Text</span><span class="p">()</span>
		<span class="nx">year</span> <span class="o">:=</span> <span class="nx">selection</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;.detail .detail-l&#34;</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;p&#34;</span><span class="p">).</span><span class="nf">Eq</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">Text</span><span class="p">()</span>

		<span class="nx">kilometer</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">compileNumber</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">kilometer</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
		<span class="nx">year</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">compileNumber</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">year</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
		<span class="nx">priceS</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseFloat</span><span class="p">(</span><span class="nx">price</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
		<span class="nx">kilometerS</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseFloat</span><span class="p">(</span><span class="nx">kilometer</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
		<span class="nx">yearS</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">year</span><span class="p">)</span>

		<span class="nx">cars</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cars</span><span class="p">,</span> <span class="nx">QcCar</span><span class="p">{</span>
			<span class="nx">CityName</span><span class="p">:</span> <span class="nx">cityName</span><span class="p">,</span>
			<span class="nx">Title</span><span class="p">:</span> <span class="nx">title</span><span class="p">,</span>
			<span class="nx">Price</span><span class="p">:</span> <span class="nx">priceS</span><span class="p">,</span>
			<span class="nx">Kilometer</span><span class="p">:</span> <span class="nx">kilometerS</span><span class="p">,</span>
			<span class="nx">Year</span><span class="p">:</span> <span class="nx">yearS</span><span class="p">,</span>
		<span class="p">})</span>
	<span class="p">})</span>

	<span class="k">return</span> <span class="nx">cars</span>
<span class="p">}</span>
</code></pre></div><h2 id="数据">数据</h2>
<p><img src="https://i.loli.net/2018/03/31/5abf1d8042196.png" alt="image"></p>
<p><img src="https://i.loli.net/2018/04/01/5abfbaa14b09c.png" alt="image"></p>
<p>在各城市的平均价格对比中，我们可以发现北上广深里的北京、上海、深圳都在榜单上，而近年势头较猛的杭州直接占领了榜首，且后几名都有一些距离</p>
<p>而其他城市大致都是梯级下降的趋势，看来一线城市的二手车也是不便宜了，当然这只是均价</p>
<p><img src="https://i.loli.net/2018/03/31/5abf1dbc665f2.png" alt="image"></p>
<p>我们可以看到价格和公里数的对比，上海、成都、郑州的等比差异是有点大，感觉有需求的话可以在价格和公里数上做一个衡量</p>
<p><img src="https://i.loli.net/2018/03/31/5abf1e1434edc.png" alt="image"></p>
<p>这图有点儿有趣，粗略的统计了一下总公里数。在前几张图里，平均价格排名较高的统统没有出现在这里，反倒是呼和浩特、大庆、中山等出现在了榜首</p>
<p>是否侧面反应了一线城市的车辆更新换代较快，而较后的城市的车辆倒是换代较慢，公里数基本都杠杠的</p>
<p><img src="https://i.loli.net/2018/03/31/5abf1e4936640.png" alt="image"></p>
<p>通过对标题的分析，可以得知车辆产品库的命名基本都是品牌名称+自动/手动+XXXX 款+属性，看标题就能知道个概况了</p>
<h2 id="参考">参考</h2>
<h3 id="爬虫项目地址">爬虫项目地址</h3>
<ul>
<li><a href="https://github.com/go-crawler/car-prices">https://github.com/go-crawler/car-prices</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「番外」Golang 交叉编译</title>
			<link>https://eddycjy.com/posts/go/gin/2018-03-26-cgo/</link>
			<pubDate>Mon, 26 Mar 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-03-26-cgo/</guid>
			<description>知识点  跨平台编译  本文目标 在 连载九 讲解构建 Scratch 镜像时，我们编译可执行文件用了另外一个形式的命令，如下：
$ CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o go-gin-example . 我想你可能会有疑问，今天本文会针对这块进行讲解。
说明 我们将讲解命令各个参数的作用，希望你在阅读时，将每一项串联起来，你会发现这就是交叉编译相关的小知识
也就是 Golang 令人心动的特性之一跨平台编译
一、CGO_ENABLED 作用：
用于标识（声明） cgo 工具是否可用
意义：
存在交叉编译的情况时，cgo 工具是不可用的。在标准 go 命令的上下文环境中，交叉编译意味着程序构建环境的目标计算架构的标识与程序运行环境的目标计算架构的标识不同，或者程序构建环境的目标操作系统的标识与程序运行环境的目标操作系统的标识不同
小结：
结合案例来说，我们是在宿主机编译的可执行文件，而在 Scratch 镜像运行的可执行文件；显然两者的计算机架构、运行环境标识你无法确定它是否一致（毕竟构建的 docker 镜像还可以给他人使用），那么我们就要进行交叉编译，而交叉编译不支持 cgo，因此这里要禁用掉它
关闭 cgo 后，在构建过程中会忽略 cgo 并静态链接所有的依赖库，而开启 cgo 后，方式将转为动态链接
补充：
golang 是默认开启 cgo 工具的，可执行 go env 命令查看
$ go env GOARCH=&amp;quot;amd64&amp;quot; GOBIN=&amp;quot;&amp;quot; GOCACHE=&amp;quot;/root/.cache/go-build&amp;quot; GOEXE=&amp;quot;&amp;quot; GOHOSTARCH=&amp;quot;amd64&amp;quot; GOHOSTOS=&amp;quot;linux&amp;quot; GOOS=&amp;quot;linux&amp;quot; ... GCCGO=&amp;quot;gccgo&amp;quot; CC=&amp;quot;gcc&amp;quot; CXX=&amp;quot;g++&amp;quot; CGO_ENABLED=&amp;quot;1&amp;quot; .</description>
			<content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<ul>
<li>跨平台编译</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>在 <a href="https://segmentfault.com/a/1190000013960558">连载九</a> 讲解<strong>构建 Scratch 镜像</strong>时，我们编译可执行文件用了另外一个形式的命令，如下：</p>
<pre><code>$ CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o go-gin-example .
</code></pre><p>我想你可能会有疑问，今天本文会针对这块进行讲解。</p>
<h2 id="说明">说明</h2>
<p>我们将讲解命令各个参数的作用，希望你在阅读时，将每一项串联起来，你会发现这就是<strong>交叉编译相关的小知识</strong></p>
<p>也就是 <code>Golang</code> 令人心动的特性之一<strong>跨平台编译</strong></p>
<h3 id="一cgo_enabled">一、CGO_ENABLED</h3>
<p><strong>作用：</strong></p>
<p>用于标识（声明） <code>cgo</code> 工具是否可用</p>
<p><strong>意义：</strong></p>
<p>存在交叉编译的情况时，<code>cgo</code> 工具是不可用的。在标准 go 命令的上下文环境中，交叉编译意味着程序构建环境的目标计算架构的标识与程序运行环境的目标计算架构的标识不同，或者程序构建环境的目标操作系统的标识与程序运行环境的目标操作系统的标识不同</p>
<p><strong>小结：</strong></p>
<p>结合案例来说，我们是在宿主机编译的可执行文件，而在 <code>Scratch</code> 镜像运行的可执行文件；显然两者的计算机架构、运行环境标识你无法确定它是否一致（毕竟构建的 <code>docker</code> 镜像还可以给他人使用），那么我们就要进行交叉编译，而交叉编译不支持 <code>cgo</code>，因此这里要禁用掉它</p>
<p>关闭 <code>cgo</code> 后，在构建过程中会忽略 <code>cgo</code> 并静态链接所有的依赖库，而开启 <code>cgo</code> 后，方式将转为动态链接</p>
<p><strong>补充：</strong></p>
<p><code>golang</code> 是默认开启 <code>cgo</code> 工具的，可执行 <code>go env</code> 命令查看</p>
<pre><code>$ go env
GOARCH=&quot;amd64&quot;
GOBIN=&quot;&quot;
GOCACHE=&quot;/root/.cache/go-build&quot;
GOEXE=&quot;&quot;
GOHOSTARCH=&quot;amd64&quot;
GOHOSTOS=&quot;linux&quot;
GOOS=&quot;linux&quot;
...
GCCGO=&quot;gccgo&quot;
CC=&quot;gcc&quot;
CXX=&quot;g++&quot;
CGO_ENABLED=&quot;1&quot;
...
</code></pre><h3 id="二goos">二、GOOS</h3>
<p>用于标识（声明）程序构建环境的目标操作系统</p>
<p>如：</p>
<ul>
<li>linux</li>
<li>windows</li>
</ul>
<h3 id="三goarch">三、GOARCH</h3>
<p>用于标识（声明）程序构建环境的目标计算架构</p>
<p>若不设置，默认值与程序运行环境的目标计算架构一致（案例就是采用的默认值）</p>
<p>如：</p>
<ul>
<li>amd64</li>
<li>386</li>
</ul>
<table>
<thead>
<tr>
<th>系统</th>
<th>GOOS</th>
<th>GOARCH</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows 32 位</td>
<td>windows</td>
<td>386</td>
</tr>
<tr>
<td>Windows 64 位</td>
<td>windows</td>
<td>amd64</td>
</tr>
<tr>
<td>OS X 32 位</td>
<td>darwin</td>
<td>386</td>
</tr>
<tr>
<td>OS X 64 位</td>
<td>darwin</td>
<td>amd64</td>
</tr>
<tr>
<td>Linux 32 位</td>
<td>linux</td>
<td>386</td>
</tr>
<tr>
<td>Linux 64 位</td>
<td>linux</td>
<td>amd64</td>
</tr>
</tbody>
</table>
<h3 id="四gohostos">四、GOHOSTOS</h3>
<p>用于标识（声明）程序运行环境的目标操作系统</p>
<h3 id="五gohostarch">五、GOHOSTARCH</h3>
<p>用于标识（声明）程序运行环境的目标计算架构</p>
<h3 id="六go-build">六、go build</h3>
<h4 id="-a">-a</h4>
<p>强制重新编译，简单来说，就是不利用缓存或已编译好的部分文件，直接所有包都是最新的代码重新编译和关联</p>
<h4 id="-installsuffix">-installsuffix</h4>
<p><strong>作用：</strong></p>
<p>在软件包安装的目录中<strong>增加后缀标识</strong>，以保持输出与默认版本分开</p>
<p><strong>补充：</strong></p>
<p>如果使用 <code>-race</code> 标识，则后缀就会默认设置为 <code>-race</code> 标识，用于区别 <code>race</code> 和普通的版本</p>
<h4 id="-o">-o</h4>
<p>指定编译后的可执行文件名称</p>
<h3 id="小结">小结</h3>
<p>大部分参数指令，都有一定关联性，且与交叉编译的知识点相关，可以好好品味一下</p>
<p>最后可以看看 <code>go build help</code> 加深了解</p>
<pre><code>$ go help build
usage: go build [-o output] [-i] [build flags] [packages]
...
	-a
		force rebuilding of packages that are already up-to-date.
	-n
		print the commands but do not run them.
	-p n
		the number of programs, such as build commands or
		test binaries, that can be run in parallel.
		The default is the number of CPUs available.
	-race
		enable data race detection.
		Supported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.
	-msan
		enable interoperation with memory sanitizer.
		Supported only on linux/amd64,
		and only with Clang/LLVM as the host C compiler.
	-v
		print the names of packages as they are compiled.
	-work
		print the name of the temporary work directory and
		do not delete it when exiting.
	-x
		print the commands.

	-asmflags '[pattern=]arg list'
		arguments to pass on each go tool asm invocation.
	-buildmode mode
		build mode to use. See 'go help buildmode' for more.
	-compiler name
		name of compiler to use, as in runtime.Compiler (gccgo or gc).
	-gccgoflags '[pattern=]arg list'
		arguments to pass on each gccgo compiler/linker invocation.
	-gcflags '[pattern=]arg list'
		arguments to pass on each go tool compile invocation.
	-installsuffix suffix
		a suffix to use in the name of the package installation directory,
		in order to keep output separate from default builds.
		If using the -race flag, the install suffix is automatically set to race
		or, if set explicitly, has _race appended to it. Likewise for the -msan
		flag. Using a -buildmode option that requires non-default compile flags
		has a similar effect.
	-ldflags '[pattern=]arg list'
		arguments to pass on each go tool link invocation.
	-linkshared
		link against shared libraries previously created with
		-buildmode=shared.
	-pkgdir dir
		install and load all packages from dir instead of the usual locations.
		For example, when building with a non-standard configuration,
		use -pkgdir to keep generated packages in a separate location.
	-tags 'tag list'
		a space-separated list of build tags to consider satisfied during the
		build. For more information about build tags, see the description of
		build constraints in the documentation for the go/build package.
	-toolexec 'cmd args'
		a program to use to invoke toolchain programs like vet and asm.
		For example, instead of running asm, the go command will run
		'cmd args /path/to/asm &lt;arguments for asm&gt;'.
...
</code></pre><h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h3 id="书籍">书籍</h3>
<ul>
<li>Go 并发编程实战 第二版</li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「连载九」将Golang应用部署到Docker</title>
			<link>https://eddycjy.com/posts/go/gin/2018-03-24-golang-docker/</link>
			<pubDate>Sat, 24 Mar 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-03-24-golang-docker/</guid>
			<description>涉及知识点  Go + Docker  本文目标 将我们的 go-gin-example 应用部署到一个 Docker 里，你需要先准备好如下东西：
 你需要安装好 docker。 如果上外网比较吃力，需要配好镜像源。  Docker 在这里简单介绍下 Docker，建议深入学习
Docker 是一个开源的轻量级容器技术，让开发者可以打包他们的应用以及应用运行的上下文环境到一个可移植的镜像中，然后发布到任何支持 Docker 的系统上运行。 通过容器技术，在几乎没有性能开销的情况下，Docker 为应用提供了一个隔离运行环境
 简化配置 代码流水线管理 提高开发效率 隔离应用 快速、持续部署   接下来我们正式开始对项目进行 docker 的所需处理和编写，每一个大标题为步骤大纲
Golang 一、编写 Dockerfile 在 go-gin-example 项目根目录创建 Dockerfile 文件，写入内容
FROM golang:latest ENV GOPROXY https://goproxy.cn,direct WORKDIR $GOPATH/src/github.com/EDDYCJY/go-gin-example COPY . $GOPATH/src/github.com/EDDYCJY/go-gin-example RUN go build . EXPOSE 8000 ENTRYPOINT [&amp;quot;./go-gin-example&amp;quot;] 作用 golang:latest 镜像为基础镜像，将工作目录设置为 $GOPATH/src/go-gin-example，并将当前上下文目录的内容复制到 $GOPATH/src/go-gin-example 中
在进行 go build 编译完毕后，将容器启动程序设置为 .</description>
			<content type="html"><![CDATA[<h2 id="涉及知识点">涉及知识点</h2>
<ul>
<li>Go + Docker</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>将我们的 <code>go-gin-example</code> 应用部署到一个 Docker 里，你需要先准备好如下东西：</p>
<ul>
<li>你需要安装好 <code>docker</code>。</li>
<li>如果上外网比较吃力，需要配好镜像源。</li>
</ul>
<h2 id="docker">Docker</h2>
<p>在这里简单介绍下 Docker，建议深入学习</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1521800047226&amp;di=28b2764fccca8a943aea7d79ad8aed98&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.cww.net.cn%2FupLoadFile%2F2014%2F6%2F13%2F201461382247734.png" alt="image"></p>
<p>Docker 是一个开源的轻量级容器技术，让开发者可以打包他们的应用以及应用运行的上下文环境到一个可移植的镜像中，然后发布到任何支持 Docker 的系统上运行。 通过容器技术，在几乎没有性能开销的情况下，Docker 为应用提供了一个隔离运行环境</p>
<ul>
<li>简化配置</li>
<li>代码流水线管理</li>
<li>提高开发效率</li>
<li>隔离应用</li>
<li>快速、持续部署</li>
</ul>
<hr>
<p>接下来我们正式开始对项目进行 <code>docker</code> 的所需处理和编写，每一个大标题为步骤大纲</p>
<h2 id="golang">Golang</h2>
<h3 id="一编写-dockerfile">一、编写 Dockerfile</h3>
<p>在 <code>go-gin-example</code> 项目根目录创建 Dockerfile 文件，写入内容</p>
<pre><code>FROM golang:latest

ENV GOPROXY https://goproxy.cn,direct
WORKDIR $GOPATH/src/github.com/EDDYCJY/go-gin-example
COPY . $GOPATH/src/github.com/EDDYCJY/go-gin-example
RUN go build .

EXPOSE 8000
ENTRYPOINT [&quot;./go-gin-example&quot;]
</code></pre><h4 id="作用">作用</h4>
<p><code>golang:latest</code> 镜像为基础镜像，将工作目录设置为 <code>$GOPATH/src/go-gin-example</code>，并将当前上下文目录的内容复制到 <code>$GOPATH/src/go-gin-example</code> 中</p>
<p>在进行 <code>go build</code> 编译完毕后，将容器启动程序设置为 <code>./go-gin-example</code>，也就是我们所编译的可执行文件</p>
<p>注意 <code>go-gin-example</code> 在 <code>docker</code> 容器里编译，并没有在宿主机现场编译</p>
<h4 id="说明">说明</h4>
<p>Dockerfile 文件是用于定义 Docker 镜像生成流程的配置文件，文件内容是一条条指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建；这些指令应用于基础镜像并最终创建一个新的镜像</p>
<p>你可以认为用于快速创建自定义的 Docker 镜像</p>
<p><strong>1、 FROM</strong></p>
<p>指定基础镜像（必须有的指令，并且必须是第一条指令）</p>
<p><strong>2、 WORKDIR</strong></p>
<p>格式为 <code>WORKDIR</code> &lt;工作目录路径&gt;</p>
<p>使用 <code>WORKDIR</code> 指令可以来<strong>指定工作目录</strong>（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如果目录不存在，<code>WORKDIR</code> 会帮你建立目录</p>
<p><strong>3、COPY</strong></p>
<p>格式：</p>
<pre><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;
COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]
</code></pre>
<p><code>COPY</code> 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录<strong>复制</strong>到新的一层的镜像内的 &lt;目标路径&gt; 位置</p>
<p><strong>4、RUN</strong></p>
<p>用于执行命令行命令</p>
<p>格式：<code>RUN</code> &lt;命令&gt;</p>
<p><strong>5、EXPOSE</strong></p>
<p>格式为 <code>EXPOSE</code> &lt;端口 1&gt; [&lt;端口 2&gt;&hellip;]</p>
<p><code>EXPOSE</code> 指令是<strong>声明运行时容器提供服务端口，这只是一个声明</strong>，在运行时并不会因为这个声明应用就会开启这个端口的服务</p>
<p>在 Dockerfile 中写入这样的声明有两个好处</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射</li>
<li>运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口</li>
</ul>
<p><strong>6、ENTRYPOINT</strong></p>
<p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为两种格式</p>
<ul>
<li><code>exec</code> 格式：</li>
</ul>
<pre><code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;
</code></pre><ul>
<li><code>shell</code> 格式：</li>
</ul>
<pre><code>ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]
</code></pre><p><code>ENTRYPOINT</code> 指令是<strong>指定容器启动程序及参数</strong></p>
<h3 id="二构建镜像">二、构建镜像</h3>
<p><code>go-gin-example</code> 的项目根目录下<strong>执行</strong> <code>docker build -t gin-blog-docker .</code></p>
<p>该命令作用是创建/构建镜像，<code>-t</code> 指定名称为 <code>gin-blog-docker</code>，<code>.</code> 构建内容为当前上下文目录</p>
<pre><code>$ docker build -t gin-blog-docker .
Sending build context to Docker daemon 96.39 MB
Step 1/6 : FROM golang:latest
 ---&gt; d632bbfe5767
Step 2/6 : WORKDIR $GOPATH/src/github.com/EDDYCJY/go-gin-example
 ---&gt; 56294f978c5d
Removing intermediate container e112997b995d
Step 3/6 : COPY . $GOPATH/src/github.com/EDDYCJY/go-gin-example
 ---&gt; 3b60960120cf
Removing intermediate container 63e310b3f60c
Step 4/6 : RUN go build .
 ---&gt; Running in 52648a431450
go: downloading github.com/gin-gonic/gin v1.3.0
go: downloading github.com/go-ini/ini v1.32.1-0.20180214101753-32e4be5f41bb
go: downloading github.com/swaggo/gin-swagger v1.0.1-0.20190110070702-0c6fcfd3c7f3
...
 ---&gt; 7bfbeb301fea
Removing intermediate container 52648a431450
Step 5/6 : EXPOSE 8000
 ---&gt; Running in 98f5b387d1bb
 ---&gt; b65bd4076c65
Removing intermediate container 98f5b387d1bb
Step 6/6 : ENTRYPOINT ./go-gin-example
 ---&gt; Running in c4f6cdeb667b
 ---&gt; d8a109c7697c
Removing intermediate container c4f6cdeb667b
Successfully built d8a109c7697c
</code></pre><h3 id="三验证镜像">三、验证镜像</h3>
<p>查看所有的镜像，确定刚刚构建的 <code>gin-blog-docker</code> 镜像是否存在</p>
<pre><code>$ docker images
REPOSITORY              TAG                 IMAGE ID            CREATED              SIZE
gin-blog-docker         latest              d8a109c7697c        About a minute ago   946 MB
docker.io/golang        latest              d632bbfe5767        8 days ago           779 MB
...
</code></pre><h3 id="四创建并运行一个新容器">四、创建并运行一个新容器</h3>
<p>执行命令 <code>docker run -p 8000:8000 gin-blog-docker</code></p>
<pre><code>$ docker run -p 8000:8000 gin-blog-docker
dial tcp 127.0.0.1:3306: connect: connection refused
[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

...
Actual pid is 1

</code></pre><p>运行成功，你以为大功告成了吗？</p>
<p>你想太多了，仔细看看控制台的输出了一条错误 <code>dial tcp 127.0.0.1:3306: connect: connection refused</code></p>
<p>我们研判一下，发现是 <code>Mysql</code> 的问题，接下来第二项我们将解决这个问题</p>
<h2 id="mysql">Mysql</h2>
<h3 id="一拉取镜像">一、拉取镜像</h3>
<p>从 <code>Docker</code> 的公共仓库 <code>Dockerhub</code> 下载 <code>MySQL</code> 镜像（国内建议配个镜像）</p>
<pre><code>$ docker pull mysql
</code></pre><h3 id="二创建并运行一个新容器">二、创建并运行一个新容器</h3>
<p>运行 <code>Mysql</code> 容器，并设置执行成功后返回容器 ID</p>
<pre><code>$ docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=rootroot -d mysql
8c86ac986da4922492934b6fe074254c9165b8ee3e184d29865921b0fef29e64
</code></pre><h4 id="连接-mysql">连接 Mysql</h4>
<p>初始化的 <code>Mysql</code> 应该如图</p>
<p><img src="https://i.loli.net/2018/03/23/5ab4caab04cf1.png" alt="image"></p>
<h2 id="golang--mysql">Golang + Mysql</h2>
<h3 id="一删除镜像">一、删除镜像</h3>
<p>由于原本的镜像存在问题，我们需要删除它，此处有几种做法</p>
<ul>
<li>删除原本有问题的镜像，重新构建一个新镜像</li>
<li>重新构建一个不同 <code>name</code>、<code>tag</code> 的新镜像</li>
</ul>
<p>删除原本的有问题的镜像，<code>-f</code> 是强制删除及其关联状态</p>
<p>若不执行 <code>-f</code>，你需要执行 <code>docker ps -a</code> 查到所关联的容器，将其 <code>rm</code> 解除两者依赖关系</p>
<pre><code>$ docker rmi -f gin-blog-docker
Untagged: gin-blog-docker:latest
Deleted: sha256:d8a109c7697c3c2d9b4de7dbb49669d10106902122817b6467a031706bc52ab4
Deleted: sha256:b65bd4076c65a3c24029ca4def3b3f37001ff7c9eca09e2590c4d29e1e23dce5
Deleted: sha256:7bfbeb301fea9d8912a4b7c43e4bb8b69bdc57f0b416b372bfb6510e476a7dee
Deleted: sha256:3b60960120cf619181c1762cdc1b8ce318b8c815e056659809252dd321bcb642
Deleted: sha256:56294f978c5dfcfa4afa8ad033fd76b755b7ecb5237c6829550741a4d2ce10bc
</code></pre><h3 id="二修改配置文件">二、修改配置文件</h3>
<p>将项目的配置文件 <code>conf/app.ini</code>，内容修改为</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="c1">#debug or release</span>
<span class="na">RUN_MODE</span> <span class="o">=</span> <span class="s">debug</span>

<span class="k">[app]</span>
<span class="na">PAGE_SIZE</span> <span class="o">=</span> <span class="s">10</span>
<span class="na">JWT_SECRET</span> <span class="o">=</span> <span class="s">233</span>

<span class="k">[server]</span>
<span class="na">HTTP_PORT</span> <span class="o">=</span> <span class="s">8000</span>
<span class="na">READ_TIMEOUT</span> <span class="o">=</span> <span class="s">60</span>
<span class="na">WRITE_TIMEOUT</span> <span class="o">=</span> <span class="s">60</span>

<span class="k">[database]</span>
<span class="na">TYPE</span> <span class="o">=</span> <span class="s">mysql</span>
<span class="na">USER</span> <span class="o">=</span> <span class="s">root</span>
<span class="na">PASSWORD</span> <span class="o">=</span> <span class="s">rootroot</span>
<span class="na">HOST</span> <span class="o">=</span> <span class="s">mysql:3306</span>
<span class="na">NAME</span> <span class="o">=</span> <span class="s">blog</span>
<span class="na">TABLE_PREFIX</span> <span class="o">=</span> <span class="s">blog_</span>

</code></pre></div><h3 id="三重新构建镜像">三、重新构建镜像</h3>
<p>重复先前的步骤，回到 <code>gin-blog</code> 的项目根目录下<strong>执行</strong> <code>docker build -t gin-blog-docker .</code></p>
<h3 id="四创建并运行一个新容器-1">四、创建并运行一个新容器</h3>
<h2 id="关联">关联</h2>
<p>Q：我们需要将 <code>Golang</code> 容器和 <code>Mysql</code> 容器关联起来，那么我们需要怎么做呢？</p>
<p>A：增加命令 <code>--link mysql:mysql</code> 让 <code>Golang</code> 容器与 <code>Mysql</code> 容器互联；通过 <code>--link</code>，<strong>可以在容器内直接使用其关联的容器别名进行访问</strong>，而不通过 IP，但是<code>--link</code>只能解决单机容器间的关联，在分布式多机的情况下，需要通过别的方式进行连接</p>
<h2 id="运行">运行</h2>
<p>执行命令 <code>docker run --link mysql:mysql -p 8000:8000 gin-blog-docker</code></p>
<pre><code>$ docker run --link mysql:mysql -p 8000:8000 gin-blog-docker
[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)
...
Actual pid is 1
</code></pre><h2 id="结果">结果</h2>
<p>检查启动输出、接口测试、数据库内数据，均正常；我们的 <code>Golang</code> 容器和 <code>Mysql</code> 容器成功关联运行，大功告成 :)</p>
<hr>
<h2 id="review">Review</h2>
<h3 id="思考">思考</h3>
<p>虽然应用已经能够跑起来了</p>
<p>但如果对 <code>Golang</code> 和 <code>Docker</code> 有一定的了解，我希望你能够想到至少 2 个问题</p>
<ul>
<li>为什么 <code>gin-blog-docker</code> 占用空间这么大？（可用 <code>docker ps -as | grep gin-blog-docker</code> 查看）</li>
<li><code>Mysql</code> 容器直接这么使用，数据存储到哪里去了？</li>
</ul>
<h3 id="创建超小的-golang-镜像">创建超小的 Golang 镜像</h3>
<p>Q：第一个问题，为什么这么镜像体积这么大？</p>
<p>A：<code>FROM golang:latest</code> 拉取的是官方 <code>golang</code> 镜像，包含 Golang 的编译和运行环境，外加一堆 GCC、build 工具，相当齐全</p>
<p>这是有问题的，<strong>我们可以不在 Golang 容器中现场编译的</strong>，压根用不到那些东西，我们只需要一个能够运行可执行文件的环境即可</p>
<h4 id="构建-scratch-镜像">构建 Scratch 镜像</h4>
<p>Scratch 镜像，简洁、小巧，基本是个空镜像</p>
<h5 id="一修改-dockerfile">一、修改 Dockerfile</h5>
<pre><code>FROM scratch

WORKDIR $GOPATH/src/github.com/EDDYCJY/go-gin-example
COPY . $GOPATH/src/github.com/EDDYCJY/go-gin-example

EXPOSE 8000
CMD [&quot;./go-gin-example&quot;]
</code></pre><h5 id="二编译可执行文件">二、编译可执行文件</h5>
<pre><code>CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o go-gin-example .
</code></pre><p>编译所生成的可执行文件会依赖一些库，并且是动态链接。在这里因为使用的是 <code>scratch</code> 镜像，它是空镜像，因此我们需要将生成的可执行文件静态链接所依赖的库</p>
<h5 id="三构建镜像">三、构建镜像</h5>
<pre><code>$ docker build -t gin-blog-docker-scratch .
Sending build context to Docker daemon 133.1 MB
Step 1/5 : FROM scratch
 ---&gt;
Step 2/5 : WORKDIR $GOPATH/src/github.com/EDDYCJY/go-gin-example
 ---&gt; Using cache
 ---&gt; ee07e166a638
Step 3/5 : COPY . $GOPATH/src/github.com/EDDYCJY/go-gin-example
 ---&gt; 1489a0693d51
Removing intermediate container e3e9efc0fe4d
Step 4/5 : EXPOSE 8000
 ---&gt; Running in b5630de5544a
 ---&gt; 6993e9f8c944
Removing intermediate container b5630de5544a
Step 5/5 : CMD ./go-gin-example
 ---&gt; Running in eebc0d8628ae
 ---&gt; 5310bebeb86a
Removing intermediate container eebc0d8628ae
Successfully built 5310bebeb86a
</code></pre><p>注意，假设你的 Golang 应用没有依赖任何的配置等文件，是可以直接把可执行文件给拷贝进去即可，其他都不必关心</p>
<p>这里可以有好几种解决方案</p>
<ul>
<li>依赖文件统一管理挂载</li>
<li>go-bindata 一下</li>
</ul>
<p>&hellip;</p>
<p>因此这里如果<strong>解决了文件依赖的问题</strong>后，就不需要把目录给 <code>COPY</code> 进去了</p>
<h5 id="四运行">四、运行</h5>
<pre><code>$ docker run --link mysql:mysql -p 8000:8000 gin-blog-docker-scratch
[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /auth                     --&gt; github.com/EDDYCJY/go-gin-example/routers/api.GetAuth (3 handlers)
...
</code></pre><p>成功运行，程序也正常接收请求</p>
<p>接下来我们再看看占用大小，执行 <code>docker ps -as</code> 命令</p>
<pre><code>$ docker ps -as
CONTAINER ID        IMAGE                     COMMAND                  ...         SIZE
9ebdba5a8445        gin-blog-docker-scratch   &quot;./go-gin-example&quot;       ...     0 B (virtual 132 MB)
427ee79e6857        gin-blog-docker           &quot;./go-gin-example&quot;       ...     0 B (virtual 946 MB)
</code></pre><p>从结果而言，占用大小以<code>Scratch</code>镜像为基础的容器完胜，完成目标</p>
<h3 id="mysql-挂载数据卷">Mysql 挂载数据卷</h3>
<p>倘若不做任何干涉，在每次启动一个 <code>Mysql</code> 容器时，数据库都是空的。另外容器删除之后，数据就丢失了（还有各类意外情况），非常糟糕！</p>
<h4 id="数据卷">数据卷</h4>
<p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令</p>
<p>数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li>
<p>数据卷 可以在容器之间共享和重用</p>
</li>
<li>
<p>对 数据卷 的修改会立马生效</p>
</li>
<li>
<p>对 数据卷 的更新，不会影响镜像</p>
</li>
<li>
<p>数据卷 默认会一直存在，即使容器被删除</p>
</li>
</ul>
<blockquote>
<p>注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。</p>
</blockquote>
<h4 id="如何挂载">如何挂载</h4>
<p>首先创建一个目录用于存放数据卷；示例目录 <code>/data/docker-mysql</code>，注意 <code>--name</code> 原本名称为 <code>mysql</code> 的容器，需要将其删除 <code>docker rm</code></p>
<pre><code>$ docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=rootroot -v /data/docker-mysql:/var/lib/mysql -d mysql
54611dbcd62eca33fb320f3f624c7941f15697d998f40b24ee535a1acf93ae72
</code></pre><p>创建成功，检查目录 <code>/data/docker-mysql</code>，下面多了不少数据库文件</p>
<h4 id="验证">验证</h4>
<p>接下来交由你进行验证，目标是创建一些测试表和数据，然后删除当前容器，重新创建的容器，数据库数据也依然存在（当然了数据卷指向要一致）</p>
<p>我已验证完毕，你呢？</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h3 id="书籍">书籍</h3>
<ul>
<li><a href="https://www.gitbook.com/book/yeasy/docker_practice/details">Docker —— 从入门到实践</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>爬取豆瓣电影 Top250</title>
			<link>https://eddycjy.com/posts/go/crawler/2018-03-21-douban-top250/</link>
			<pubDate>Wed, 21 Mar 2018 12:30:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/crawler/2018-03-21-douban-top250/</guid>
			<description>爬虫是标配了，看数据那一刻很有趣。第一个就从最最最简单最基础的爬虫开始写起吧！
项目地址：https://github.com/go-crawler/douban-movie
目标 我们的目标站点是 豆瓣电影 Top250，估计大家都很眼熟了
本次爬取 8 个字段，用于简单的概括分析。具体的字段如下：
简单的分析一下目标源
 一页共 25 条 含分页（共 10 页）且分页规则是正常的 每一项的数据字段排序都是规则且不变  开始 由于量不大，我们的爬取步骤如下
 分析页面，获取所有的分页 分析页面，循环爬取所有页面的电影信息 爬取的电影信息入库  安装 $ go get -u github.com/PuerkitoBio/goquery 运行 $ go run main.go 代码片段 1、获取所有分页 func ParsePages(doc *goquery.Document) (pages []Page) { pages = append(pages, Page{Page: 1, Url: &amp;#34;&amp;#34;}) doc.Find(&amp;#34;#content &amp;gt; div &amp;gt; div.article &amp;gt; div.paginator &amp;gt; a&amp;#34;).Each(func(i int, s *goquery.Selection) { page, _ := strconv.Atoi(s.Text()) url, _ := s.</description>
			<content type="html"><![CDATA[<p>爬虫是标配了，看数据那一刻很有趣。第一个就从最最最简单最基础的爬虫开始写起吧！</p>
<p>项目地址：https://github.com/go-crawler/douban-movie</p>
<h2 id="目标">目标</h2>
<p>我们的目标站点是 <a href="https://movie.douban.com/top250">豆瓣电影 Top250</a>，估计大家都很眼熟了</p>
<p>本次爬取 8 个字段，用于简单的概括分析。具体的字段如下：</p>
<p><img src="https://i.loli.net/2018/03/20/5ab11596b8810.png" alt="image"></p>
<p>简单的分析一下目标源</p>
<ul>
<li>一页共 25 条</li>
<li>含分页（共 10 页）且分页规则是正常的</li>
<li>每一项的数据字段排序都是规则且不变</li>
</ul>
<h2 id="开始">开始</h2>
<p>由于量不大，我们的爬取步骤如下</p>
<ul>
<li>分析页面，获取所有的分页</li>
<li>分析页面，循环爬取所有页面的电影信息</li>
<li>爬取的电影信息入库</li>
</ul>
<h3 id="安装">安装</h3>
<pre><code>$ go get -u github.com/PuerkitoBio/goquery
</code></pre><h3 id="运行">运行</h3>
<pre><code>$ go run main.go
</code></pre><h3 id="代码片段">代码片段</h3>
<h4 id="1获取所有分页">1、获取所有分页</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ParsePages</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">goquery</span><span class="p">.</span><span class="nx">Document</span><span class="p">)</span> <span class="p">(</span><span class="nx">pages</span> <span class="p">[]</span><span class="nx">Page</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pages</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">pages</span><span class="p">,</span> <span class="nx">Page</span><span class="p">{</span><span class="nx">Page</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Url</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">})</span>
	<span class="nx">doc</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;#content &gt; div &gt; div.article &gt; div.paginator &gt; a&#34;</span><span class="p">).</span><span class="nf">Each</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">goquery</span><span class="p">.</span><span class="nx">Selection</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">page</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">Text</span><span class="p">())</span>
		<span class="nx">url</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Attr</span><span class="p">(</span><span class="s">&#34;href&#34;</span><span class="p">)</span>

		<span class="nx">pages</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">pages</span><span class="p">,</span> <span class="nx">Page</span><span class="p">{</span>
			<span class="nx">Page</span><span class="p">:</span> <span class="nx">page</span><span class="p">,</span>
			<span class="nx">Url</span><span class="p">:</span>  <span class="nx">url</span><span class="p">,</span>
		<span class="p">})</span>
	<span class="p">})</span>

	<span class="k">return</span> <span class="nx">pages</span>
<span class="p">}</span>
</code></pre></div><h4 id="2分析豆瓣电影信息">2、分析豆瓣电影信息</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ParseMovies</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">goquery</span><span class="p">.</span><span class="nx">Document</span><span class="p">)</span> <span class="p">(</span><span class="nx">movies</span> <span class="p">[]</span><span class="nx">Movie</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">doc</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;#content &gt; div &gt; div.article &gt; ol &gt; li&#34;</span><span class="p">).</span><span class="nf">Each</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">goquery</span><span class="p">.</span><span class="nx">Selection</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">title</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;.hd a span&#34;</span><span class="p">).</span><span class="nf">Eq</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nf">Text</span><span class="p">()</span>

		<span class="o">...</span>

		<span class="nx">movieDesc</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">DescInfo</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
		<span class="nx">year</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">movieDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="nx">area</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">movieDesc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="nx">tag</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">movieDesc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

		<span class="nx">star</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;.bd .star .rating_num&#34;</span><span class="p">).</span><span class="nf">Text</span><span class="p">()</span>

		<span class="nx">comment</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;.bd .star span&#34;</span><span class="p">).</span><span class="nf">Eq</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nf">Text</span><span class="p">())</span>
		<span class="nx">compile</span> <span class="o">:=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">&#34;[0-9]&#34;</span><span class="p">)</span>
		<span class="nx">comment</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">compile</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">comment</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#34;&#34;</span><span class="p">)</span>

		<span class="nx">quote</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&#34;.quote .inq&#34;</span><span class="p">).</span><span class="nf">Text</span><span class="p">()</span>

		<span class="o">...</span>

		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;i: %d, movie: %v&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">movie</span><span class="p">)</span>

		<span class="nx">movies</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">movies</span><span class="p">,</span> <span class="nx">movie</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">return</span> <span class="nx">movies</span>
<span class="p">}</span>
</code></pre></div><h3 id="数据">数据</h3>
<p><img src="https://i.loli.net/2018/03/21/5ab1309594741.png" alt="image"></p>
<p><img src="https://i.loli.net/2018/03/21/5ab131ca582f8.png" alt="image"></p>
<p><img src="https://i.loli.net/2018/03/21/5ab130d3a00d9.png" alt="image"></p>
<p>看到这些数据，你有什么想法呢，真是好奇 :=)</p>
]]></content>
		</item>
		
		<item>
			<title>「连载八」为它加上Swagger</title>
			<link>https://eddycjy.com/posts/go/gin/2018-03-18-swagger/</link>
			<pubDate>Sun, 18 Mar 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-03-18-swagger/</guid>
			<description>涉及知识点  Swagger  本文目标 一个好的 API&#39;s，必然离不开一个好的API文档，如果要开发纯手写 API 文档，不存在的（很难持续维护），因此我们要自动生成接口文档。
安装 swag $ go get -u github.com/swaggo/swag/cmd/swag 若 $GOROOT/bin 没有加入$PATH中，你需要执行将其可执行文件移动到$GOBIN下
mv $GOPATH/bin/swag /usr/local/go/bin 验证是否安装成功 检查 $GOBIN 下是否有 swag 文件，如下：
$ swag -v swag version v1.1.1 安装 gin-swagger $ go get -u github.com/swaggo/gin-swagger $ go get -u github.com/swaggo/gin-swagger/swaggerFiles 注：三个包都有一定大小，安装需要等一会或要科学上网。
初始化 编写 API 注释 Swagger 中需要将相应的注释或注解编写到方法上，再利用生成器自动生成说明文件
gin-swagger 给出的范例：
// @Summary Add a new pet to the store // @Description get string by ID // @Accept json // @Produce json // @Param some_id path int true &amp;#34;Some ID&amp;#34; // @Success 200 {string} string	&amp;#34;ok&amp;#34; // @Failure 400 {object} web.</description>
			<content type="html"><![CDATA[<h2 id="涉及知识点">涉及知识点</h2>
<ul>
<li>Swagger</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>一个好的 <code>API's</code>，必然离不开一个好的<code>API</code>文档，如果要开发纯手写 <code>API</code> 文档，不存在的（很难持续维护），因此我们要自动生成接口文档。</p>
<h2 id="安装-swag">安装 swag</h2>
<pre><code>$ go get -u github.com/swaggo/swag/cmd/swag
</code></pre><p>若 <code>$GOROOT/bin</code> 没有加入<code>$PATH</code>中，你需要执行将其可执行文件移动到<code>$GOBIN</code>下</p>
<pre><code>mv $GOPATH/bin/swag /usr/local/go/bin
</code></pre><h3 id="验证是否安装成功">验证是否安装成功</h3>
<p>检查 $GOBIN 下是否有 swag 文件，如下：</p>
<pre><code>$ swag -v
swag version v1.1.1
</code></pre><h2 id="安装-gin-swagger">安装 gin-swagger</h2>
<pre><code>$ go get -u github.com/swaggo/gin-swagger

$ go get -u github.com/swaggo/gin-swagger/swaggerFiles
</code></pre><p>注：三个包都有一定大小，安装需要等一会或要科学上网。</p>
<h2 id="初始化">初始化</h2>
<h3 id="编写-api-注释">编写 API 注释</h3>
<p><code>Swagger</code> 中需要将相应的注释或注解编写到方法上，再利用生成器自动生成说明文件</p>
<p><code>gin-swagger</code> 给出的范例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// @Summary Add a new pet to the store
</span><span class="c1">// @Description get string by ID
</span><span class="c1">// @Accept  json
</span><span class="c1">// @Produce  json
</span><span class="c1">// @Param   some_id     path    int     true        &#34;Some ID&#34;
</span><span class="c1">// @Success 200 {string} string	&#34;ok&#34;
</span><span class="c1">// @Failure 400 {object} web.APIError &#34;We need ID!!&#34;
</span><span class="c1">// @Failure 404 {object} web.APIError &#34;Can not find ID&#34;
</span><span class="c1">// @Router /testapi/get-string-by-int/{some_id} [get]
</span></code></pre></div><p>我们可以参照 <code>Swagger</code> 的注解规范和范例去编写</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// @Summary 新增文章标签
</span><span class="c1">// @Produce  json
</span><span class="c1">// @Param name query string true &#34;Name&#34;
</span><span class="c1">// @Param state query int false &#34;State&#34;
</span><span class="c1">// @Param created_by query int false &#34;CreatedBy&#34;
</span><span class="c1">// @Success 200 {string} json &#34;{&#34;code&#34;:200,&#34;data&#34;:{},&#34;msg&#34;:&#34;ok&#34;}&#34;
</span><span class="c1">// @Router /api/v1/tags [post]
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// @Summary 修改文章标签
</span><span class="c1">// @Produce  json
</span><span class="c1">// @Param id path int true &#34;ID&#34;
</span><span class="c1">// @Param name query string true &#34;ID&#34;
</span><span class="c1">// @Param state query int false &#34;State&#34;
</span><span class="c1">// @Param modified_by query string true &#34;ModifiedBy&#34;
</span><span class="c1">// @Success 200 {string} json &#34;{&#34;code&#34;:200,&#34;data&#34;:{},&#34;msg&#34;:&#34;ok&#34;}&#34;
</span><span class="c1">// @Router /api/v1/tags/{id} [put]
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">EditTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div><p>参考的注解请参见 <a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a>。以确保获取最新的 swag 语法</p>
<h3 id="路由">路由</h3>
<p>在完成了注解的编写后，我们需要针对 swagger 新增初始化动作和对应的路由规则，才可以使用。打开 routers/router.go 文件，新增内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routers</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="o">...</span>

	<span class="nx">_</span> <span class="s">&#34;github.com/EDDYCJY/go-gin-example/docs&#34;</span>

	<span class="o">...</span>
<span class="p">)</span>

<span class="c1">// InitRouter initialize routing information
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/swagger/*any&#34;</span><span class="p">,</span> <span class="nx">ginSwagger</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">swaggerFiles</span><span class="p">.</span><span class="nx">Handler</span><span class="p">))</span>
	<span class="o">...</span>
	<span class="nx">apiv1</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/api/v1&#34;</span><span class="p">)</span>
	<span class="nx">apiv1</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">jwt</span><span class="p">.</span><span class="nf">JWT</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></div><h3 id="生成">生成</h3>
<p>我们进入到<code>gin-blog</code>的项目根目录中，执行初始化命令</p>
<pre><code>[$ gin-blog]# swag init
2018/03/13 23:32:10 Generate swagger docs....
2018/03/13 23:32:10 Generate general API Info
2018/03/13 23:32:10 create docs.go at  docs/docs.go

</code></pre><p>完毕后会在项目根目录下生成<code>docs</code></p>
<pre><code>docs/
├── docs.go
└── swagger
    ├── swagger.json
    └── swagger.yaml

</code></pre><p>我们可以检查 <code>docs.go</code> 文件中的 <code>doc</code> 变量，详细记载中我们文件中所编写的注解和说明
<img src="https://image.eddycjy.com/37ae10e1714c63899a55d49c19af0860.png" alt="image"></p>
<h3 id="验证">验证</h3>
<p>大功告成，访问一下 <code>http://127.0.0.1:8000/swagger/index.html</code>， 查看 <code>API</code> 文档生成是否正确</p>
<p><img src="https://image.eddycjy.com/703b677c6756129c33b5308c1655a35c.png" alt="image"></p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「连载七」优雅的重启服务</title>
			<link>https://eddycjy.com/posts/go/gin/2018-03-15-reload-http/</link>
			<pubDate>Thu, 15 Mar 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-03-15-reload-http/</guid>
			<description>知识点  信号量的了解。 应用热更新。  本文目标 在前面编写案例代码时，我相信你会想到，每次更新完代码，更新完配置文件后，就直接这么 ctrl+c 真的没问题吗，ctrl+c到底做了些什么事情呢？
在这一节中我们简单讲述 ctrl+c 背后的信号以及如何在Gin中优雅的重启服务，也就是对 HTTP 服务进行热更新。
ctrl + c  内核在某些情况下发送信号，比如在进程往一个已经关闭的管道写数据时会产生SIGPIPE信号
 在终端执行特定的组合键可以使系统发送特定的信号给此进程，完成一系列的动作
   命令 信号 含义     ctrl + c SIGINT 强制进程结束   ctrl + z SIGTSTP 任务中断，进程挂起   ctrl + \ SIGQUIT 进程结束 和 dump core   ctrl + d  EOF    SIGHUP 终止收到该信号的进程。若程序中没有捕捉该信号，当收到该信号时，进程就会退出（常用于 重启、重新加载进程）    因此在我们执行ctrl + c关闭gin服务端时，会强制进程结束，导致正在访问的用户等出现问题</description>
			<content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<ul>
<li>信号量的了解。</li>
<li>应用热更新。</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>在前面编写案例代码时，我相信你会想到，每次更新完代码，更新完配置文件后，就直接这么 <code>ctrl+c</code> 真的没问题吗，<code>ctrl+c</code>到底做了些什么事情呢？</p>
<p>在这一节中我们简单讲述 <code>ctrl+c</code> 背后的<strong>信号</strong>以及如何在<code>Gin</code>中<strong>优雅的重启服务</strong>，也就是对 <code>HTTP</code> 服务进行热更新。</p>
<h2 id="ctrl--c">ctrl + c</h2>
<blockquote>
<p>内核在某些情况下发送信号，比如在进程往一个已经关闭的管道写数据时会产生<code>SIGPIPE</code>信号</p>
</blockquote>
<p>在终端执行特定的组合键可以使系统发送特定的信号给此进程，完成一系列的动作</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>信号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ctrl + c</td>
<td>SIGINT</td>
<td>强制进程结束</td>
</tr>
<tr>
<td>ctrl + z</td>
<td>SIGTSTP</td>
<td>任务中断，进程挂起</td>
</tr>
<tr>
<td>ctrl + \</td>
<td>SIGQUIT</td>
<td>进程结束 和 <code>dump core</code></td>
</tr>
<tr>
<td>ctrl + d</td>
<td></td>
<td>EOF</td>
</tr>
<tr>
<td></td>
<td>SIGHUP</td>
<td>终止收到该信号的进程。若程序中没有捕捉该信号，当收到该信号时，进程就会退出（常用于 重启、重新加载进程）</td>
</tr>
</tbody>
</table>
<p>因此在我们执行<code>ctrl + c</code>关闭<code>gin</code>服务端时，<strong>会强制进程结束，导致正在访问的用户等出现问题</strong></p>
<p>常见的 <code>kill -9 pid</code> 会发送 <code>SIGKILL</code> 信号给进程，也是类似的结果</p>
<h3 id="信号">信号</h3>
<p>本段中反复出现<strong>信号</strong>是什么呢？</p>
<p>信号是 <code>Unix</code> 、类 <code>Unix</code> 以及其他 <code>POSIX</code> 兼容的操作系统中进程间通讯的一种有限制的方式</p>
<p>它是一种异步的通知机制，用来提醒进程一个事件（硬件异常、程序执行异常、外部发出信号）已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程。此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数</p>
<h3 id="所有信号">所有信号</h3>
<pre><code>$ kill -l
 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP
 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1
11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
21) SIGTTIN 22) SIGTTOU 23) SIGURG  24) SIGXCPU 25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF 28) SIGWINCH    29) SIGIO   30) SIGPWR
31) SIGSYS  34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
</code></pre><h2 id="怎样算优雅">怎样算优雅</h2>
<h3 id="目的">目的</h3>
<ul>
<li>不关闭现有连接（正在运行中的程序）</li>
<li>新的进程启动并替代旧进程</li>
<li>新的进程接管新的连接</li>
<li>连接要随时响应用户的请求，当用户仍在请求旧进程时要保持连接，新用户应请求新进程，不可以出现拒绝请求的情况</li>
</ul>
<h3 id="流程">流程</h3>
<p>1、替换可执行文件或修改配置文件</p>
<p>2、发送信号量 <code>SIGHUP</code></p>
<p>3、拒绝新连接请求旧进程，但要保证已有连接正常</p>
<p>4、启动新的子进程</p>
<p>5、新的子进程开始 <code>Accet</code></p>
<p>6、系统将新的请求转交新的子进程</p>
<p>7、旧进程处理完所有旧连接后正常结束</p>
<h2 id="实现优雅重启">实现优雅重启</h2>
<h3 id="endless">endless</h3>
<blockquote>
<p>Zero downtime restarts for golang HTTP and HTTPS servers. (for golang 1.3+)</p>
</blockquote>
<p>我们借助 <a href="https://github.com/fvbock/endless">fvbock/endless</a> 来实现 <code>Golang HTTP/HTTPS</code> 服务重新启动的零停机</p>
<p><code>endless server</code> 监听以下几种信号量：</p>
<ul>
<li>syscall.SIGHUP：触发 <code>fork</code> 子进程和重新启动</li>
<li>syscall.SIGUSR1/syscall.SIGTSTP：被监听，但不会触发任何动作</li>
<li>syscall.SIGUSR2：触发 <code>hammerTime</code></li>
<li>syscall.SIGINT/syscall.SIGTERM：触发服务器关闭（会完成正在运行的请求）</li>
</ul>
<p><code>endless</code> 正正是依靠监听这些<strong>信号量</strong>，完成管控的一系列动作</p>
<h4 id="安装">安装</h4>
<pre><code>go get -u github.com/fvbock/endless
</code></pre><h4 id="编写">编写</h4>
<p>打开 <a href="https://github.com/EDDYCJY/go-gin-example">gin-blog</a> 的 <code>main.go</code>文件，修改文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;syscall&#34;</span>

    <span class="s">&#34;github.com/fvbock/endless&#34;</span>

    <span class="s">&#34;gin-blog/routers&#34;</span>
    <span class="s">&#34;gin-blog/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">endless</span><span class="p">.</span><span class="nx">DefaultReadTimeOut</span> <span class="p">=</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">ReadTimeout</span>
    <span class="nx">endless</span><span class="p">.</span><span class="nx">DefaultWriteTimeOut</span> <span class="p">=</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">WriteTimeout</span>
    <span class="nx">endless</span><span class="p">.</span><span class="nx">DefaultMaxHeaderBytes</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>
    <span class="nx">endPoint</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;:%d&#34;</span><span class="p">,</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">HTTPPort</span><span class="p">)</span>

    <span class="nx">server</span> <span class="o">:=</span> <span class="nx">endless</span><span class="p">.</span><span class="nf">NewServer</span><span class="p">(</span><span class="nx">endPoint</span><span class="p">,</span> <span class="nx">routers</span><span class="p">.</span><span class="nf">InitRouter</span><span class="p">())</span>
    <span class="nx">server</span><span class="p">.</span><span class="nx">BeforeBegin</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">add</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Actual pid is %d&#34;</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Getpid</span><span class="p">())</span>
    <span class="p">}</span>

    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Server err: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>endless.NewServer</code> 返回一个初始化的 <code>endlessServer</code> 对象，在 <code>BeforeBegin</code> 时输出当前进程的 <code>pid</code>，调用 <code>ListenAndServe</code> 将实际“启动”服务</p>
<h4 id="验证">验证</h4>
<h5 id="编译"><strong>编译</strong></h5>
<pre><code>$ go build main.go
</code></pre><h5 id="执行"><strong>执行</strong></h5>
<pre><code>$ ./main
[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.
...
Actual pid is 48601
</code></pre><p>启动成功后，输出了<code>pid</code>为 48601；在另外一个终端执行 <code>kill -1 48601</code> ，检验先前服务的终端效果</p>
<pre><code>[root@localhost go-gin-example]# ./main
[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /auth                     --&gt; ...
[GIN-debug] GET    /api/v1/tags              --&gt; ...
...

Actual pid is 48601

...

Actual pid is 48755
48601 Received SIGTERM.
48601 [::]:8000 Listener closed.
48601 Waiting for connections to finish...
48601 Serve() returning...
Server err: accept tcp [::]:8000: use of closed network connection
</code></pre><p>可以看到该命令已经挂起，并且 <code>fork</code> 了新的子进程 <code>pid</code> 为 <code>48755</code></p>
<pre><code>48601 Received SIGTERM.
48601 [::]:8000 Listener closed.
48601 Waiting for connections to finish...
48601 Serve() returning...
Server err: accept tcp [::]:8000: use of closed network connection
</code></pre><p>大致意思为主进程（<code>pid</code>为 48601）接受到 <code>SIGTERM</code> 信号量，关闭主进程的监听并且等待正在执行的请求完成；这与我们先前的描述一致</p>
<h5 id="唤醒"><strong>唤醒</strong></h5>
<p>这时候在 <code>postman</code> 上再次访问我们的接口，你可以惊喜的发现，他“复活”了！</p>
<pre><code>Actual pid is 48755
48601 Received SIGTERM.
48601 [::]:8000 Listener closed.
48601 Waiting for connections to finish...
48601 Serve() returning...
Server err: accept tcp [::]:8000: use of closed network connection


$ [GIN] 2018/03/15 - 13:00:16 | 200 |     188.096µs |   192.168.111.1 | GET      /api/v1/tags...

</code></pre><p>这就完成了一次正向的流转了</p>
<p>你想想，每次更新发布、或者修改配置文件等，只需要给该进程发送<strong>SIGTERM 信号</strong>，而不需要强制结束应用，是多么便捷又安全的事！</p>
<h4 id="问题">问题</h4>
<p><code>endless</code> 热更新是采取创建子进程后，将原进程退出的方式，这点不符合守护进程的要求</p>
<h3 id="httpserver---shutdown">http.Server - Shutdown()</h3>
<p>如果你的<code>Golang &gt;= 1.8</code>，也可以考虑使用 <code>http.Server</code> 的 <a href="https://golang.org/pkg/net/http/#Server.Shutdown">Shutdown</a> 方法</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
    <span class="s">&#34;context&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;os&#34;</span>
    <span class="s">&#34;os/signal&#34;</span>
    <span class="s">&#34;time&#34;</span>


    <span class="s">&#34;gin-blog/routers&#34;</span>
    <span class="s">&#34;gin-blog/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">router</span> <span class="o">:=</span> <span class="nx">routers</span><span class="p">.</span><span class="nf">InitRouter</span><span class="p">()</span>

    <span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
        <span class="nx">Addr</span><span class="p">:</span>           <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;:%d&#34;</span><span class="p">,</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">HTTPPort</span><span class="p">),</span>
        <span class="nx">Handler</span><span class="p">:</span>        <span class="nx">router</span><span class="p">,</span>
        <span class="nx">ReadTimeout</span><span class="p">:</span>    <span class="nx">setting</span><span class="p">.</span><span class="nx">ReadTimeout</span><span class="p">,</span>
        <span class="nx">WriteTimeout</span><span class="p">:</span>   <span class="nx">setting</span><span class="p">.</span><span class="nx">WriteTimeout</span><span class="p">,</span>
        <span class="nx">MaxHeaderBytes</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Listen: %s\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="nx">quit</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">)</span>
    <span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">quit</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Interrupt</span><span class="p">)</span>
    <span class="o">&lt;-</span> <span class="nx">quit</span>

    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Shutdown Server ...&#34;</span><span class="p">)</span>

    <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Shutdown</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Server Shutdown:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Server exiting&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="小结">小结</h2>
<p>在日常的服务中，优雅的重启（热更新）是非常重要的一环。而 <code>Golang</code> 在 <code>HTTP</code> 服务方面的热更新也有不少方案了，我们应该根据实际应用场景挑选最合适的</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h3 id="拓展阅读">拓展阅读</h3>
<ul>
<li><a href="https://github.com/braintree/manners">manners</a></li>
<li><a href="https://github.com/tylerb/graceful">graceful</a></li>
<li><a href="https://github.com/facebookgo/grace">grace</a></li>
<li><a href="https://github.com/golang/go/commit/0cbb12f0bbaeb3893b3d011fdb1a270291747ab0">plugin: new package for loading plugins · golang/go@0cbb12f · GitHub</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>聊一聊，Go 的相对路径问题</title>
			<link>https://eddycjy.com/posts/go/talk/2018-03-13-golang-relatively-path/</link>
			<pubDate>Tue, 13 Mar 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/talk/2018-03-13-golang-relatively-path/</guid>
			<description>前言 Golang 中存在各种运行方式，如何正确的引用文件路径成为一个值得商议的问题
以 gin-blog 为例，当我们在项目根目录下，执行 go run main.go 时能够正常运行（go build也是正常的）
[$ gin-blog]# go run main.go [GIN-debug] [WARNING] Running in &amp;quot;debug&amp;quot; mode. Switch to &amp;quot;release&amp;quot; mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] GET /api/v1/tags --&amp;gt; gin-blog/routers/api/v1.GetTags (3 handlers) ... 那么在不同的目录层级下，不同的方式运行，又是怎么样的呢，带着我们的疑问去学习
问题 1、 go run 我们上移目录层级，到 $GOPATH/src 下，执行 go run gin-blog/main.go
[$ src]# go run gin-blog/main.go 2018/03/12 16:06:13 Fail to parse &#39;conf/app.ini&#39;: open conf/app.ini: no such file or directory exit status 1 2、 go build，执行 .</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><code>Golang</code> 中存在各种运行方式，如何<strong>正确的引用文件路径</strong>成为一个值得商议的问题</p>
<p>以 <a href="https://github.com/EDDYCJY/go-gin-example">gin-blog</a> 为例，当我们在项目根目录下，执行 <code>go run main.go</code> 时能够正常运行（<code>go build</code>也是正常的）</p>
<pre><code>[$ gin-blog]# go run main.go
[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.
 - using env:    export GIN_MODE=release
 - using code:    gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /api/v1/tags              --&gt; gin-blog/routers/api/v1.GetTags (3 handlers)
...
</code></pre><p>那么在不同的目录层级下，不同的方式运行，又是怎么样的呢，带着我们的疑问去学习</p>
<h2 id="问题">问题</h2>
<p>1、 go run
我们上移目录层级，到 <code>$GOPATH/src</code> 下，执行 <code>go run gin-blog/main.go</code></p>
<pre><code>[$ src]# go run gin-blog/main.go
2018/03/12 16:06:13 Fail to parse 'conf/app.ini': open conf/app.ini: no such file or directory
exit status 1
</code></pre><p>2、 go build，执行 <code>./gin-blog/main</code></p>
<pre><code>[$ src]# ./gin-blog/main
2018/03/12 16:49:35 Fail to parse 'conf/app.ini': open conf/app.ini: no such file or directory
</code></pre><p>这时候你要打一个大大的问号，就是我的程序读取到什么地方去了</p>
<hr>
<p>我们通过分析得知，<strong><code>Golang</code>的相对路径是相对于执行命令时的目录</strong>；自然也就读取不到了</p>
<h2 id="思考">思考</h2>
<p>既然已经知道问题的所在点，我们就可以寻思做点什么 : )</p>
<p>我们想到相对路径是相对执行命令的目录，那么我们获取可执行文件的地址，拼接起来不就好了吗？</p>
<h2 id="实践">实践</h2>
<p>我们编写<strong>获取当前可执行文件路径的方法</strong></p>
<pre><code>import (
	&quot;path/filepath&quot;
	&quot;os&quot;
	&quot;os/exec&quot;
	&quot;string&quot;
)

func GetAppPath() string {
    file, _ := exec.LookPath(os.Args[0])
    path, _ := filepath.Abs(file)
    index := strings.LastIndex(path, string(os.PathSeparator))

    return path[:index]
}
</code></pre><p>将其放到启动代码处查看路径</p>
<pre><code>log.Println(GetAppPath())
</code></pre><p>我们分别执行以下两个命令，查看输出结果
1、 go run</p>
<pre><code>$ go run main.go
2018/03/12 18:45:40 /tmp/go-build962610262/b001/exe
</code></pre><p>2、 go build</p>
<pre><code>$ ./main
2018/03/12 18:49:44 $GOPATH/src/gin-blog

</code></pre><h2 id="剖析">剖析</h2>
<p>我们聚焦在 <code>go run</code> 的输出结果上，发现它是一个临时文件的地址，这是为什么呢？</p>
<p>在<code>go help run</code>中，我们可以看到</p>
<pre><code>Run compiles and runs the main package comprising the named Go source files.
A Go source file is defined to be a file ending in a literal &quot;.go&quot; suffix.
</code></pre><p>也就是 <code>go run</code> 执行时会将文件放到 <code>/tmp/go-build...</code> 目录下，编译并运行</p>
<p>因此<code>go run main.go</code>出现<code>/tmp/go-build962610262/b001/exe</code>结果也不奇怪了，因为它已经跑到临时目录下去执行可执行文件了</p>
<hr>
<p>这就已经很清楚了，那么我们想想，会出现哪些问题呢</p>
<ul>
<li>依赖相对路径的文件，出现路径出错的问题</li>
<li><code>go run</code> 和 <code>go build</code> 不一样，一个到临时目录下执行，一个可手动在编译后的目录下执行，路径的处理方式会不同</li>
<li>不断<code>go run</code>，不断产生新的临时文件</li>
</ul>
<p>这其实就是<strong>根本原因</strong>了，因为 <code>go run</code> 和 <code>go build</code> 的编译文件执行路径并不同，执行的层级也有可能不一样，自然而然就出现各种读取不到的奇怪问题了</p>
<h2 id="解决方案">解决方案</h2>
<p><strong>一、获取编译后的可执行文件路径</strong></p>
<p>1、 将配置文件的相对路径与<code>GetAppPath()</code>的结果相拼接，可解决<code>go build main.go</code>的可执行文件跨目录执行的问题（如：<code>./src/gin-blog/main</code>）</p>
<pre><code>import (
	&quot;path/filepath&quot;
	&quot;os&quot;
	&quot;os/exec&quot;
	&quot;string&quot;
)

func GetAppPath() string {
    file, _ := exec.LookPath(os.Args[0])
    path, _ := filepath.Abs(file)
    index := strings.LastIndex(path, string(os.PathSeparator))

    return path[:index]
}
</code></pre><p>但是这种方式，对于<code>go run</code>依旧无效，这时候就需要2来补救</p>
<p>2、 通过传递参数指定路径，可解决<code>go run</code>的问题</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

func main() {
    var appPath string
    flag.StringVar(&amp;appPath, &quot;app-path&quot;, &quot;app-path&quot;)
    flag.Parse()
    fmt.Printf(&quot;App path: %s&quot;, appPath)
}
</code></pre><p>运行</p>
<pre><code>go run main.go --app-path &quot;Your project address&quot;
</code></pre><p><strong>二、增加<code>os.Getwd()</code>进行多层判断</strong></p>
<p>参见 <a href="https://github.com/astaxie/beego/blob/master/config.go#L133-L146">beego</a> 读取 <code>app.conf</code> 的代码</p>
<p>该写法可兼容 <code>go build</code> 和在项目根目录执行 <code>go run</code> ，但是若跨目录执行 <code>go run</code> 就不行</p>
<p><strong>三、配置全局系统变量</strong></p>
<p>我们可以通过<code>os.Getenv</code>来获取系统全局变量，然后与相对路径进行拼接</p>
<p>1、 设置项目工作区</p>
<p>简单来说，就是设置项目（应用）的工作路径，然后与配置文件、日志文件等相对路径进行拼接，达到相对的绝对路径来保证路径一致</p>
<p>参见 <a href="https://github.com/gogits/gogs/blob/master/pkg/setting/setting.go#L351">gogs</a> 读取<code>GOGS_WORK_DIR</code>进行拼接的代码</p>
<p>2、 利用系统自带变量</p>
<p>简单来说就是通过系统自带的全局变量，例如<code>$HOME</code>等，将配置文件存放在<code>$HOME/conf</code>或<code>/etc/conf</code>下</p>
<p>这样子就能更加固定的存放配置文件，<strong>不需要额外去设置一个环境变量</strong></p>
<p>（这点今早与一位SFer讨论了一波，感谢）</p>
<h2 id="拓展">拓展</h2>
<p><code>go test</code> 在一些场景下也会遇到路径问题，因为<code>go test</code>只能够在当前目录执行，所以在执行测试用例的时候，你的执行目录已经是测试目录了</p>
<p>需要注意的是，如果采用获取外部参数的办法，用 <code>os.args</code> 时，<code>go test -args</code> 和 <code>go run</code>、<code>go build</code> 会有命令行参数位置的不一致问题</p>
<h2 id="小结">小结</h2>
<p>这三种解决方案，在目前可见的开源项目或介绍中都能找到这些的身影</p>
<p>优缺点也是显而易见的，我认为应在<strong>不同项目选定合适的解决方案</strong>即可</p>
<p>建议大家不要强依赖读取配置文件的模块，应当将其“堆积木”化，<strong>需要什么配置才去注册什么配置变量</strong>，可以解决一部分的问题</p>
<p>大家又有什么想法呢，一起讨论一波？</p>
]]></content>
		</item>
		
		<item>
			<title>「连载三」Swagger了解一下</title>
			<link>https://eddycjy.com/posts/go/grpc-gateway/2018-03-04-swagger/</link>
			<pubDate>Sun, 04 Mar 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc-gateway/2018-03-04-swagger/</guid>
			<description>在上一节，我们完成了一个服务端同时支持Rpc和RESTful Api后，你以为自己大功告成了，结果突然发现要写Api文档和前端同事对接= = 。。。
你寻思有没有什么组件能够自动化生成Api文档来解决这个问题，就在这时你发现了Swagger，一起了解一下吧！
介绍 Swagger Swagger是全球最大的OpenAPI规范（OAS）API开发工具框架，支持从设计和文档到测试和部署的整个API生命周期的开发
Swagger是目前最受欢迎的RESTful Api文档生成工具之一，主要的原因如下
 跨平台、跨语言的支持 强大的社区 生态圈 Swagger Tools（Swagger Editor、Swagger Codegen、Swagger UI &amp;hellip;） 强大的控制台  同时grpc-gateway也支持Swagger
[image]
OpenAPI规范 OpenAPI规范是Linux基金会的一个项目，试图通过定义一种用来描述API格式或API定义的语言，来规范RESTful服务开发过程。OpenAPI规范帮助我们描述一个API的基本信息，比如：
 有关该API的一般性描述 可用路径（/资源） 在每个路径上的可用操作（获取/提交&amp;hellip;） 每个操作的输入/输出格式  目前V2.0版本的OpenAPI规范（也就是SwaggerV2.0规范）已经发布并开源在github上。该文档写的非常好，结构清晰，方便随时查阅。
注：OpenAPI规范的介绍引用自原文
使用 生成Swagger的说明文件 第一，我们需要检查$GOBIN下是否包含protoc-gen-swagger可执行文件
若不存在则需要执行：
go get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger 等待执行完毕后，可在$GOPATH/bin下发现该执行文件，将其移动到$GOBIN下即可
第二，回到$GOPATH/src/grpc-hello-world/proto下，执行命令
protoc -I/usr/local/include -I. -I$GOPATH/src/grpc-hello-world/proto/google/api --swagger_out=logtostderr=true:. ./hello.proto 成功后执行ls即可看到hello.swagger.json文件
下载Swagger UI文件 Swagger提供可视化的API管理平台，就是Swagger UI
我们将其源码下载下来，并将其dist目录下的所有文件拷贝到我们项目中的$GOPATH/src/grpc-hello-world/third_party/swagger-ui去
将Swagger UI转换为Go源代码 在这里我们使用的转换工具是go-bindata
它支持将任何文件转换为可管理的Go源代码。用于将二进制数据嵌入到Go程序中。并且在将文件数据转换为原始字节片之前，可以选择压缩文件数据
安装 go get -u github.com/jteeuwen/go-bindata/... 完成后，将$GOPATH/bin下的go-bindata移动到$GOBIN下
转换 在项目下新建pkg/ui/data/swagger目录，回到$GOPATH/src/grpc-hello-world/third_party/swagger-ui下，执行命令
go-bindata --nocompress -pkg swagger -o pkg/ui/data/swagger/datafile.</description>
			<content type="html"><![CDATA[<p>在<a href="https://segmentfault.com/a/1190000013408485">上一节</a>，我们完成了一个服务端同时支持<code>Rpc</code>和<code>RESTful Api</code>后，你以为自己大功告成了，结果突然发现要写<code>Api</code>文档和前端同事对接= = 。。。</p>
<p>你寻思有没有什么组件能够自动化生成<code>Api</code>文档来解决这个问题，就在这时你发现了<code>Swagger</code>，一起了解一下吧！</p>
<h2 id="介绍">介绍</h2>
<h3 id="swagger">Swagger</h3>
<p><code>Swagger</code>是全球最大的<code>OpenAPI</code>规范（OAS）API开发工具框架，支持从设计和文档到测试和部署的整个API生命周期的开发</p>
<p><code>Swagger</code>是目前最受欢迎的<code>RESTful Api</code>文档生成工具之一，主要的原因如下</p>
<ul>
<li>跨平台、跨语言的支持</li>
<li>强大的社区</li>
<li>生态圈 Swagger Tools（<a href="https://github.com/swagger-api/swagger-editor">Swagger Editor</a>、<a href="https://github.com/swagger-api/swagger-codegen">Swagger Codegen</a>、<a href="https://github.com/swagger-api/swagger-ui">Swagger UI</a> &hellip;）</li>
<li>强大的控制台</li>
</ul>
<p>同时<code>grpc-gateway</code>也支持<code>Swagger</code></p>
<p>[image]</p>
<h3 id="openapi规范"><code>OpenAPI</code>规范</h3>
<p><code>OpenAPI</code>规范是<code>Linux</code>基金会的一个项目，试图通过定义一种用来描述API格式或API定义的语言，来规范<code>RESTful</code>服务开发过程。<code>OpenAPI</code>规范帮助我们描述一个API的基本信息，比如：</p>
<ul>
<li>有关该API的一般性描述</li>
<li>可用路径（/资源）</li>
<li>在每个路径上的可用操作（获取/提交&hellip;）</li>
<li>每个操作的输入/输出格式</li>
</ul>
<p>目前V2.0版本的<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md">OpenAPI规范</a>（也就是SwaggerV2.0规范）已经发布并开源在github上。该文档写的非常好，结构清晰，方便随时查阅。</p>
<p>注：<code>OpenAPI</code>规范的介绍引用自<a href="https://huangwenchao.gitbooks.io/swagger/content/">原文</a></p>
<h2 id="使用">使用</h2>
<h3 id="生成swagger的说明文件">生成<code>Swagger</code>的说明文件</h3>
<p><strong>第一</strong>，我们需要检查$GOBIN下是否包含<code>protoc-gen-swagger</code>可执行文件</p>
<p>若不存在则需要执行：</p>
<pre><code>go get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger
</code></pre><p>等待执行完毕后，可在<code>$GOPATH/bin</code>下发现该执行文件，将其移动到<code>$GOBIN</code>下即可</p>
<p><strong>第二</strong>，回到<code>$GOPATH/src/grpc-hello-world/proto</code>下，执行命令</p>
<pre><code>protoc -I/usr/local/include -I. -I$GOPATH/src/grpc-hello-world/proto/google/api --swagger_out=logtostderr=true:. ./hello.proto
</code></pre><p>成功后执行<code>ls</code>即可看到<code>hello.swagger.json</code>文件</p>
<h3 id="下载swagger-ui文件">下载<code>Swagger UI</code>文件</h3>
<p><code>Swagger</code>提供可视化的<code>API</code>管理平台，就是<a href="https://github.com/swagger-api/swagger-ui">Swagger UI</a></p>
<p>我们将其源码下载下来，并将其<code>dist</code>目录下的所有文件拷贝到我们项目中的<code>$GOPATH/src/grpc-hello-world/third_party/swagger-ui</code>去</p>
<h3 id="将swagger-ui转换为go源代码">将<code>Swagger UI</code>转换为<code>Go</code>源代码</h3>
<p>在这里我们使用的转换工具是<a href="https://github.com/jteeuwen/go-bindata">go-bindata</a></p>
<p>它支持将任何文件转换为可管理的<code>Go</code>源代码。用于将二进制数据嵌入到<code>Go</code>程序中。并且在将文件数据转换为原始字节片之前，可以选择压缩文件数据</p>
<h4 id="安装">安装</h4>
<pre><code>go get -u github.com/jteeuwen/go-bindata/...
</code></pre><p>完成后，将<code>$GOPATH/bin</code>下的<code>go-bindata</code>移动到<code>$GOBIN</code>下</p>
<h4 id="转换">转换</h4>
<p>在项目下新建<code>pkg/ui/data/swagger</code>目录，回到<code>$GOPATH/src/grpc-hello-world/third_party/swagger-ui</code>下，执行命令</p>
<pre><code>go-bindata --nocompress -pkg swagger -o pkg/ui/data/swagger/datafile.go third_party/swagger-ui/...
</code></pre><h4 id="检查">检查</h4>
<p>回到<code>pkg/ui/data/swagger</code>目录，检查是否存在<code>datafile.go</code>文件</p>
<h3 id="swagger-ui文件服务器对外提供服务"><code>Swagger UI</code>文件服务器（对外提供服务）</h3>
<p>在这一步，我们需要使用与其配套的<a href="https://github.com/elazarl/go-bindata-assetfs/">go-bindata-assetfs</a></p>
<p>它能够使用<code>go-bindata</code>所生成<code>Swagger UI</code>的<code>Go</code>代码，结合<code>net/http</code>对外提供服务</p>
<h4 id="安装-1">安装</h4>
<pre><code>go get github.com/elazarl/go-bindata-assetfs/...
</code></pre><h4 id="编写">编写</h4>
<p>通过分析，我们得知生成的文件提供了一个<code>assetFS</code>函数，该函数返回一个封装了嵌入文件的<code>http.Filesystem</code>，可以用其来提供一个<code>HTTP</code>服务</p>
<p>那么我们来编写<code>Swagger UI</code>的代码吧，主要是两个部分，一个是<code>swagger.json</code>，另外一个是<code>swagger-ui</code>的响应</p>
<h5 id="serveswaggerfile">serveSwaggerFile</h5>
<p>引用包<code>strings</code>、<code>path</code></p>
<pre><code>func serveSwaggerFile(w http.ResponseWriter, r *http.Request) {
      if ! strings.HasSuffix(r.URL.Path, &quot;swagger.json&quot;) {
        log.Printf(&quot;Not Found: %s&quot;, r.URL.Path)
        http.NotFound(w, r)
        return
    }

    p := strings.TrimPrefix(r.URL.Path, &quot;/swagger/&quot;)
    p = path.Join(&quot;proto&quot;, p)

    log.Printf(&quot;Serving swagger-file: %s&quot;, p)

    http.ServeFile(w, r, p)
}
</code></pre><p>在函数中，我们利用<code>r.URL.Path</code>进行路径后缀判断</p>
<p>主要做了对<code>swagger.json</code>的文件访问支持（提供<code>https://127.0.0.1:50052/swagger/hello.swagger.json</code>的访问）</p>
<h5 id="serveswaggerui">serveSwaggerUI</h5>
<p>引用包<code>github.com/elazarl/go-bindata-assetfs</code>、<code>grpc-hello-world/pkg/ui/data/swagger</code></p>
<pre><code>func serveSwaggerUI(mux *http.ServeMux) {
    fileServer := http.FileServer(&amp;assetfs.AssetFS{
        Asset:    swagger.Asset,
        AssetDir: swagger.AssetDir,
        Prefix:   &quot;third_party/swagger-ui&quot;,
    })
    prefix := &quot;/swagger-ui/&quot;
    mux.Handle(prefix, http.StripPrefix(prefix, fileServer))
}
</code></pre><p>在函数中，我们使用了<a href="https://github.com/elazarl/go-bindata-assetfs/">go-bindata-assetfs</a>来调度先前生成的<code>datafile.go</code>，结合<code>net/http</code>来对外提供<code>swagger-ui</code>的服务</p>
<h4 id="结合">结合</h4>
<p>在完成功能后，我们发现<code>path.Join(&quot;proto&quot;, p)</code>是写死参数的，这样显然不对，我们应该将其导出成外部参数，那么我们来最终改造一番</p>
<p>首先我们在<code>server.go</code>新增包全局变量<code>SwaggerDir</code>，修改<code>cmd/server.go</code>文件：</p>
<pre><code>package cmd

import (
	&quot;log&quot;

	&quot;github.com/spf13/cobra&quot;
	
	&quot;grpc-hello-world/server&quot;
)

var serverCmd = &amp;cobra.Command{
	Use:   &quot;server&quot;,
	Short: &quot;Run the gRPC hello-world server&quot;,
	Run: func(cmd *cobra.Command, args []string) {
		defer func() {
			if err := recover(); err != nil {
				log.Println(&quot;Recover error : %v&quot;, err)
			}
		}()
		
		server.Run()
	},
}

func init() {
	serverCmd.Flags().StringVarP(&amp;server.ServerPort, &quot;port&quot;, &quot;p&quot;, &quot;50052&quot;, &quot;server port&quot;)
	serverCmd.Flags().StringVarP(&amp;server.CertPemPath, &quot;cert-pem&quot;, &quot;&quot;, &quot;./conf/certs/server.pem&quot;, &quot;cert-pem path&quot;)
	serverCmd.Flags().StringVarP(&amp;server.CertKeyPath, &quot;cert-key&quot;, &quot;&quot;, &quot;./conf/certs/server.key&quot;, &quot;cert-key path&quot;)
	serverCmd.Flags().StringVarP(&amp;server.CertServerName, &quot;cert-server-name&quot;, &quot;&quot;, &quot;grpc server name&quot;, &quot;server's hostname&quot;)
	serverCmd.Flags().StringVarP(&amp;server.SwaggerDir, &quot;swagger-dir&quot;, &quot;&quot;, &quot;proto&quot;, &quot;path to the directory which contains swagger definitions&quot;)
	
	rootCmd.AddCommand(serverCmd)
}
</code></pre><p>修改<code>path.Join(&quot;proto&quot;, p)</code>为<code>path.Join(SwaggerDir, p)</code>，这样的话我们<code>swagger.json</code>的文件路径就可以根据外部情况去修改它</p>
<p>最终<code>server.go</code>文件内容：</p>
<pre><code>package server

import (
    &quot;crypto/tls&quot;
    &quot;net&quot;
    &quot;net/http&quot;
    &quot;log&quot;
    &quot;strings&quot;
    &quot;path&quot;

    &quot;golang.org/x/net/context&quot;
    &quot;google.golang.org/grpc&quot;
    &quot;google.golang.org/grpc/credentials&quot;
    &quot;github.com/grpc-ecosystem/grpc-gateway/runtime&quot;
    &quot;github.com/elazarl/go-bindata-assetfs&quot;
    
    pb &quot;grpc-hello-world/proto&quot;
    &quot;grpc-hello-world/pkg/util&quot;
    &quot;grpc-hello-world/pkg/ui/data/swagger&quot;
)

var (
    ServerPort string
    CertServerName string
    CertPemPath string
    CertKeyPath string
    SwaggerDir string
    EndPoint string

    tlsConfig *tls.Config
)

func Run() (err error) {
    EndPoint = &quot;:&quot; + ServerPort
    tlsConfig = util.GetTLSConfig(CertPemPath, CertKeyPath)

    conn, err := net.Listen(&quot;tcp&quot;, EndPoint)
    if err != nil {
        log.Printf(&quot;TCP Listen err:%v\n&quot;, err)
    }

    srv := newServer(conn)

    log.Printf(&quot;gRPC and https listen on: %s\n&quot;, ServerPort)

    if err = srv.Serve(util.NewTLSListener(conn, tlsConfig)); err != nil {
        log.Printf(&quot;ListenAndServe: %v\n&quot;, err)
    }

    return err
}
 
func newServer(conn net.Listener) (*http.Server) {
    grpcServer := newGrpc()
    gwmux, err := newGateway()
    if err != nil {
        panic(err)
    }

    mux := http.NewServeMux()
    mux.Handle(&quot;/&quot;, gwmux)
    mux.HandleFunc(&quot;/swagger/&quot;, serveSwaggerFile)
    serveSwaggerUI(mux)

    return &amp;http.Server{
        Addr:      EndPoint,
        Handler:   util.GrpcHandlerFunc(grpcServer, mux),
        TLSConfig: tlsConfig,
    }
}

func newGrpc() *grpc.Server {
    creds, err := credentials.NewServerTLSFromFile(CertPemPath, CertKeyPath)
    if err != nil {
        panic(err)
    }

    opts := []grpc.ServerOption{
        grpc.Creds(creds),
    }
    server := grpc.NewServer(opts...)

    pb.RegisterHelloWorldServer(server, NewHelloService())

    return server
}

func newGateway() (http.Handler, error) {
    ctx := context.Background()
    dcreds, err := credentials.NewClientTLSFromFile(CertPemPath, CertServerName)
    if err != nil {
        return nil, err
    }
    dopts := []grpc.DialOption{grpc.WithTransportCredentials(dcreds)}
    
    gwmux := runtime.NewServeMux()
    if err := pb.RegisterHelloWorldHandlerFromEndpoint(ctx, gwmux, EndPoint, dopts); err != nil {
        return nil, err
    }

    return gwmux, nil
}

func serveSwaggerFile(w http.ResponseWriter, r *http.Request) {
      if ! strings.HasSuffix(r.URL.Path, &quot;swagger.json&quot;) {
        log.Printf(&quot;Not Found: %s&quot;, r.URL.Path)
        http.NotFound(w, r)
        return
    }

    p := strings.TrimPrefix(r.URL.Path, &quot;/swagger/&quot;)
    p = path.Join(SwaggerDir, p)

    log.Printf(&quot;Serving swagger-file: %s&quot;, p)

    http.ServeFile(w, r, p)
}

func serveSwaggerUI(mux *http.ServeMux) {
    fileServer := http.FileServer(&amp;assetfs.AssetFS{
        Asset:    swagger.Asset,
        AssetDir: swagger.AssetDir,
        Prefix:   &quot;third_party/swagger-ui&quot;,
    })
    prefix := &quot;/swagger-ui/&quot;
    mux.Handle(prefix, http.StripPrefix(prefix, fileServer))
}
</code></pre><h2 id="测试">测试</h2>
<p>访问路径<code>https://127.0.0.1:50052/swagger/hello.swagger.json</code>，查看输出内容是否为<code>hello.swagger.json</code>的内容，例如：
[image]</p>
<p>访问路径<code>https://127.0.0.1:50052/swagger-ui/</code>，查看内容
[image]</p>
<h2 id="小结">小结</h2>
<p>至此我们这一章节就完毕了，<code>Swagger</code>和其生态圈十分的丰富，有兴趣研究的小伙伴可以到其<a href="https://swagger.io/">官网</a>认真研究</p>
<p>而目前完成的程度也满足了日常工作的需求了，可较自动化的生成<code>RESTful Api</code>文档，完成与接口对接</p>
<h2 id="参考">参考</h2>
<h3 id="示例代码">示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/grpc-hello-world">grpc-hello-world</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载二」Hello World</title>
			<link>https://eddycjy.com/posts/go/grpc-gateway/2018-02-27-hello-world/</link>
			<pubDate>Tue, 27 Feb 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc-gateway/2018-02-27-hello-world/</guid>
			<description>这节将开始编写一个复杂的Hello World，涉及到许多的知识，建议大家认真思考其中的概念
需求 由于本实践偏向Grpc+Grpc Gateway的方面，我们的需求是同一个服务端支持Rpc和Restful Api，那么就意味着http2、TLS等等的应用，功能方面就是一个服务端能够接受来自grpc和Restful Api的请求并响应
一、初始化目录 我们先在$GOPATH中新建grpc-hello-world文件夹，我们项目的初始目录目录如下：
grpc-hello-world/ ├── certs ├── client ├── cmd ├── pkg ├── proto │ ├── google │ │ └── api └── server  certs：证书凭证 client：客户端 cmd：命令行 pkg：第三方公共模块 proto：protobuf的一些相关文件（含.proto、pb.go、.pb.gw.go)，google/api中用于存放annotations.proto、http.proto server：服务端  二、制作证书 在服务端支持Rpc和Restful Api，需要用到TLS，因此我们要先制作证书
进入certs目录，生成TLS所需的公钥密钥文件
私钥 openssl genrsa -out server.key 2048 openssl ecparam -genkey -name secp384r1 -out server.key  openssl genrsa：生成RSA私钥，命令的最后一个参数，将指定生成密钥的位数，如果没有指定，默认512 openssl ecparam：生成ECC私钥，命令为椭圆曲线密钥参数生成及操作，本文中ECC曲线选择的是secp384r1  自签名公钥 openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650  openssl req：生成自签名证书，-new指生成证书请求、-sha256指使用sha256加密、-key指定私钥文件、-x509指输出证书、-days 3650为有效期，此后则输入证书拥有者信息  填写信息 Country Name (2 letter code) [XX]: State or Province Name (full name) []: Locality Name (eg, city) [Default City]: Organization Name (eg, company) [Default Company Ltd]: Organizational Unit Name (eg, section) []: Common Name (eg, your name or your server&#39;s hostname) []:grpc server name Email Address []: 三、proto 编写 1、 google.</description>
			<content type="html"><![CDATA[<p>这节将开始编写一个复杂的Hello World，涉及到许多的知识，建议大家认真思考其中的概念</p>
<h2 id="需求">需求</h2>
<p>由于本实践偏向<code>Grpc</code>+<code>Grpc Gateway</code>的方面，我们的需求是<strong>同一个服务端支持<code>Rpc</code>和<code>Restful Api</code></strong>，那么就意味着<code>http2</code>、<code>TLS</code>等等的应用，功能方面就是一个服务端能够接受来自<code>grpc</code>和<code>Restful Api</code>的请求并响应</p>
<h2 id="一初始化目录">一、初始化目录</h2>
<p>我们先在$GOPATH中新建<code>grpc-hello-world</code>文件夹，我们项目的初始目录目录如下：</p>
<pre><code>grpc-hello-world/
├── certs
├── client
├── cmd
├── pkg
├── proto
│   ├── google
│   │   └── api
└── server
</code></pre><ul>
<li><code>certs</code>：证书凭证</li>
<li><code>client</code>：客户端</li>
<li><code>cmd</code>：命令行</li>
<li><code>pkg</code>：第三方公共模块</li>
<li><code>proto</code>：<code>protobuf</code>的一些相关文件（含<code>.proto</code>、<code>pb.go</code>、<code>.pb.gw.go</code>)，<code>google/api</code>中用于存放<code>annotations.proto</code>、<code>http.proto</code></li>
<li><code>server</code>：服务端</li>
</ul>
<h2 id="二制作证书">二、制作证书</h2>
<p>在服务端支持<code>Rpc</code>和<code>Restful Api</code>，需要用到<code>TLS</code>，因此我们要先制作证书</p>
<p>进入<code>certs</code>目录，生成<code>TLS</code>所需的公钥密钥文件</p>
<h3 id="私钥">私钥</h3>
<pre><code>openssl genrsa -out server.key 2048

openssl ecparam -genkey -name secp384r1 -out server.key
</code></pre><ul>
<li><code>openssl genrsa</code>：生成<code>RSA</code>私钥，命令的最后一个参数，将指定生成密钥的位数，如果没有指定，默认512</li>
<li><code>openssl ecparam</code>：生成<code>ECC</code>私钥，命令为椭圆曲线密钥参数生成及操作，本文中<code>ECC</code>曲线选择的是<code>secp384r1</code></li>
</ul>
<h3 id="自签名公钥">自签名公钥</h3>
<pre><code>openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650
</code></pre><ul>
<li><code>openssl req</code>：生成自签名证书，<code>-new</code>指生成证书请求、<code>-sha256</code>指使用<code>sha256</code>加密、<code>-key</code>指定私钥文件、<code>-x509</code>指输出证书、<code>-days 3650</code>为有效期，此后则输入证书拥有者信息</li>
</ul>
<h3 id="填写信息">填写信息</h3>
<pre><code>Country Name (2 letter code) [XX]:
State or Province Name (full name) []:
Locality Name (eg, city) [Default City]:
Organization Name (eg, company) [Default Company Ltd]:
Organizational Unit Name (eg, section) []:
Common Name (eg, your name or your server's hostname) []:grpc server name
Email Address []:
</code></pre><h2 id="三proto">三、<code>proto</code></h2>
<h3 id="编写">编写</h3>
<p>1、 <code>google.api</code></p>
<p>我们看到<code>proto</code>目录中有<code>google/api</code>目录，它用到了<code>google</code>官方提供的两个<code>api</code>描述文件，主要是针对<code>grpc-gateway</code>的<code>http</code>转换提供支持，定义了<code>Protocol Buffer</code>所扩展的<code>HTTP Option</code></p>
<p><code>annotations.proto</code>文件：</p>
<pre><code>// Copyright (c) 2015, Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = &quot;proto3&quot;;

package google.api;

import &quot;google/api/http.proto&quot;;
import &quot;google/protobuf/descriptor.proto&quot;;

option java_multiple_files = true;
option java_outer_classname = &quot;AnnotationsProto&quot;;
option java_package = &quot;com.google.api&quot;;

extend google.protobuf.MethodOptions {
  // See `HttpRule`.
  HttpRule http = 72295728;
}

</code></pre><p><code>http.proto</code>文件：</p>
<pre><code>// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = &quot;proto3&quot;;

package google.api;

option cc_enable_arenas = true;
option java_multiple_files = true;
option java_outer_classname = &quot;HttpProto&quot;;
option java_package = &quot;com.google.api&quot;;


// Defines the HTTP configuration for a service. It contains a list of
// [HttpRule][google.api.HttpRule], each specifying the mapping of an RPC method
// to one or more HTTP REST API methods.
message Http {
  // A list of HTTP rules for configuring the HTTP REST API methods.
  repeated HttpRule rules = 1;
}

// Use CustomHttpPattern to specify any HTTP method that is not included in the
// `pattern` field, such as HEAD, or &quot;*&quot; to leave the HTTP method unspecified for
// a given URL path rule. The wild-card rule is useful for services that provide
// content to Web (HTML) clients.
message HttpRule {
  // Selects methods to which this rule applies.
  //
  // Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
  string selector = 1;

  // Determines the URL pattern is matched by this rules. This pattern can be
  // used with any of the {get|put|post|delete|patch} methods. A custom method
  // can be defined using the 'custom' field.
  oneof pattern {
    // Used for listing and getting information about resources.
    string get = 2;

    // Used for updating a resource.
    string put = 3;

    // Used for creating a resource.
    string post = 4;

    // Used for deleting a resource.
    string delete = 5;

    // Used for updating a resource.
    string patch = 6;

    // Custom pattern is used for defining custom verbs.
    CustomHttpPattern custom = 8;
  }

  // The name of the request field whose value is mapped to the HTTP body, or
  // `*` for mapping all fields not captured by the path pattern to the HTTP
  // body. NOTE: the referred field must not be a repeated field.
  string body = 7;

  // Additional HTTP bindings for the selector. Nested bindings must
  // not contain an `additional_bindings` field themselves (that is,
  // the nesting may only be one level deep).
  repeated HttpRule additional_bindings = 11;
}

// A custom pattern is used for defining custom HTTP verb.
message CustomHttpPattern {
  // The name of this custom HTTP verb.
  string kind = 1;

  // The path matched by this custom verb.
  string path = 2;
}

</code></pre><ol start="2">
<li><code>hello.proto</code></li>
</ol>
<p>这一小节将编写<code>Demo</code>的<code>.proto</code>文件，我们在<code>proto</code>目录下新建<code>hello.proto</code>文件，写入文件内容：</p>
<pre><code>syntax = &quot;proto3&quot;;

package proto;

import &quot;google/api/annotations.proto&quot;;

service HelloWorld {
    rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse) {
        option (google.api.http) = {
            post: &quot;/hello_world&quot;
            body: &quot;*&quot;
        };
    }
}

message HelloWorldRequest {
    string referer = 1;
}

message HelloWorldResponse {
    string message = 1;
}
</code></pre><p>在<code>hello.proto</code>文件中，引用了<code>google/api/annotations.proto</code>，达到支持<code>HTTP Option</code>的效果</p>
<ul>
<li>定义了一个<code>service</code>RPC服务<code>HelloWorld</code>，在其内部定义了一个<code>HTTP Option</code>的<code>POST</code>方法，<code>HTTP</code>响应路径为<code>/hello_world</code></li>
<li>定义<code>message</code>类型<code>HelloWorldRequest</code>、<code>HelloWorldResponse</code>，用于响应请求和返回结果</li>
</ul>
<h3 id="编译">编译</h3>
<p>在编写完<code>.proto</code>文件后，我们需要对其进行编译，就能够在<code>server</code>中使用</p>
<p>进入<code>proto</code>目录，执行以下命令</p>
<pre><code># 编译google.api
protoc -I . --go_out=plugins=grpc,Mgoogle/protobuf/descriptor.proto=github.com/golang/protobuf/protoc-gen-go/descriptor:. google/api/*.proto

#编译hello_http.proto为hello_http.pb.proto
protoc -I . --go_out=plugins=grpc,Mgoogle/api/annotations.proto=grpc-hello-world/proto/google/api:. ./hello.proto

#编译hello_http.proto为hello_http.pb.gw.proto
protoc --grpc-gateway_out=logtostderr=true:. ./hello.proto
</code></pre><p>执行完毕后将生成<code>hello.pb.go</code>和<code>hello.gw.pb.go</code>，分别针对<code>grpc</code>和<code>grpc-gateway</code>的功能支持</p>
<h2 id="四命令行模块-cmd">四、命令行模块 <code>cmd</code></h2>
<h3 id="介绍">介绍</h3>
<p>这一小节我们编写命令行模块，为什么要独立出来呢，是为了将<code>cmd</code>和<code>server</code>两者解耦，避免混淆在一起。</p>
<p>我们采用 <a href="https://github.com/spf13/cobra">Cobra</a> 来完成这项功能，<code>Cobra</code>既是创建强大的现代CLI应用程序的库，也是生成应用程序和命令文件的程序。提供了以下功能：</p>
<ul>
<li>简易的子命令行模式</li>
<li>完全兼容posix的命令行模式(包括短和长版本)</li>
<li>嵌套的子命令</li>
<li>全局、本地和级联<code>flags</code></li>
<li>使用<code>Cobra</code>很容易的生成应用程序和命令，使用<code>cobra create appname</code>和<code>cobra add cmdname</code></li>
<li>智能提示</li>
<li>自动生成commands和flags的帮助信息</li>
<li>自动生成详细的help信息<code>-h</code>，<code>--help</code>等等</li>
<li>自动生成的bash自动完成功能</li>
<li>为应用程序自动生成手册</li>
<li>命令别名</li>
<li>定义您自己的帮助、用法等的灵活性。</li>
<li>可选与<a href="https://github.com/spf13/viper">viper</a>紧密集成的apps</li>
</ul>
<h3 id="编写server">编写<code>server</code></h3>
<p>在编写<code>cmd</code>时需要先用<code>server</code>进行测试关联，因此这一步我们先写<code>server.go</code>用于测试</p>
<p>在<code>server</code>模块下 新建<code>server.go</code>文件，写入测试内容：</p>
<pre><code>package server

import (
    &quot;log&quot;
)

var (
    ServerPort string
    CertName string
    CertPemPath string
    CertKeyPath string
)

func Serve() (err error){
    log.Println(ServerPort)
    
    log.Println(CertName)
    
    log.Println(CertPemPath)
    
    log.Println(CertKeyPath)
    
    return nil
}

</code></pre><h3 id="编写cmd">编写<code>cmd</code></h3>
<p>在<code>cmd</code>模块下 新建<code>root.go</code>文件，写入内容：</p>
<pre><code>package cmd

import (
    &quot;fmt&quot;
    &quot;os&quot;

    &quot;github.com/spf13/cobra&quot;
)

var rootCmd = &amp;cobra.Command{
    Use:   &quot;grpc&quot;,
    Short: &quot;Run the gRPC hello-world server&quot;,
}

func Execute() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Println(err)
        os.Exit(-1)
    }
}
</code></pre><p>新建<code>server.go</code>文件，写入内容：</p>
<pre><code>package cmd

import (
	&quot;log&quot;

	&quot;github.com/spf13/cobra&quot;
	
	&quot;grpc-hello-world/server&quot;
)

var serverCmd = &amp;cobra.Command{
	Use:   &quot;server&quot;,
	Short: &quot;Run the gRPC hello-world server&quot;,
	Run: func(cmd *cobra.Command, args []string) {
		defer func() {
			if err := recover(); err != nil {
				log.Println(&quot;Recover error : %v&quot;, err)
			}
		}()
		
		server.Serve()
	},
}

func init() {
	serverCmd.Flags().StringVarP(&amp;server.ServerPort, &quot;port&quot;, &quot;p&quot;, &quot;50052&quot;, &quot;server port&quot;)
	serverCmd.Flags().StringVarP(&amp;server.CertPemPath, &quot;cert-pem&quot;, &quot;&quot;, &quot;./certs/server.pem&quot;, &quot;cert pem path&quot;)
	serverCmd.Flags().StringVarP(&amp;server.CertKeyPath, &quot;cert-key&quot;, &quot;&quot;, &quot;./certs/server.key&quot;, &quot;cert key path&quot;)
	serverCmd.Flags().StringVarP(&amp;server.CertName, &quot;cert-name&quot;, &quot;&quot;, &quot;grpc server name&quot;, &quot;server's hostname&quot;)
	rootCmd.AddCommand(serverCmd)
}
</code></pre><p>我们在<code>grpc-hello-world/</code>目录下，新建文件<code>main.go</code>，写入内容：</p>
<pre><code>package main

import (
	&quot;grpc-hello-world/cmd&quot;
)

func main() {
	cmd.Execute()
}
</code></pre><h3 id="讲解">讲解</h3>
<p>要使用<code>Cobra</code>，按照<code>Cobra</code>标准要创建<code>main.go</code>和一个<code>rootCmd</code>文件，另外我们有子命令<code>server</code></p>
<p>1、<code>rootCmd</code>：
<code>rootCmd</code>表示在没有任何子命令的情况下的基本命令</p>
<p>2、<code>&amp;cobra.Command</code>：</p>
<ul>
<li><code>Use</code>：<code>Command</code>的用法，<code>Use</code>是一个行用法消息</li>
<li><code>Short</code>：<code>Short</code>是<code>help</code>命令输出中显示的简短描述</li>
<li><code>Run</code>：运行:典型的实际工作功能。大多数命令只会实现这一点；另外还有<code>PreRun</code>、<code>PreRunE</code>、<code>PostRun</code>、<code>PostRunE</code>等等不同时期的运行命令，但比较少用，具体使用时再查看亦可</li>
</ul>
<p>3、<code>rootCmd.AddCommand</code>：<code>AddCommand</code>向这父命令（<code>rootCmd</code>）添加一个或多个命令</p>
<p>4、<code>serverCmd.Flags().StringVarP()</code>：</p>
<p>一般来说，我们需要在<code>init()</code>函数中定义<code>flags</code>和处理配置，以<code>serverCmd.Flags().StringVarP(&amp;server.ServerPort, &quot;port&quot;, &quot;p&quot;, &quot;50052&quot;, &quot;server port&quot;)</code>为例，我们定义了一个<code>flag</code>，值存储在<code>&amp;server.ServerPort</code>中，长命令为<code>--port</code>，短命令为<code>-p</code>，，默认值为<code>50052</code>，命令的描述为<code>server port</code>。这一种调用方式成为<code>Local Flags</code></p>
<p>我们延伸一下，如果觉得每一个子命令都要设一遍觉得很麻烦，我们可以采用<code>Persistent Flags</code>：</p>
<p><code>rootCmd.PersistentFlags().BoolVarP(&amp;Verbose, &quot;verbose&quot;, &quot;v&quot;, false, &quot;verbose output&quot;)</code></p>
<p>作用：</p>
<p><code>flag</code>是可以持久的，这意味着该<code>flag</code>将被分配给它所分配的命令以及该命令下的每个命令。对于全局标记，将标记作为根上的持久标志。</p>
<p>另外还有<code>Local Flag on Parent Commands</code>、<code>Bind Flags with Config</code>、<code>Required flags</code>等等，使用到再 <a href="https://github.com/spf13/cobra#local-flag-on-parent-commands">传送</a> 了解即可</p>
<h3 id="测试">测试</h3>
<p>回到<code>grpc-hello-world/</code>目录下执行<code>go run main.go server</code>，查看输出是否为（此时应为默认值）：</p>
<pre><code>2018/02/25 23:23:21 50052
2018/02/25 23:23:21 dev
2018/02/25 23:23:21 ./certs/server.pem
2018/02/25 23:23:21 ./certs/server.key
</code></pre><p>执行<code>go run main.go server --port=8000 --cert-pem=test-pem --cert-key=test-key --cert-name=test-name</code>，检验命令行参数是否正确：</p>
<pre><code>2018/02/25 23:24:56 8000
2018/02/25 23:24:56 test-name
2018/02/25 23:24:56 test-pem
2018/02/25 23:24:56 test-key
</code></pre><p>若都无误，那么恭喜你<code>cmd</code>模块的编写正确了，下一部分开始我们的重点章节！</p>
<h2 id="五服务端模块-server">五、服务端模块 <code>server</code></h2>
<h3 id="编写hellogo">编写<code>hello.go</code></h3>
<p>在<code>server</code>目录下新建文件<code>hello.go</code>，写入文件内容：</p>
<pre><code>package server

import (
	&quot;golang.org/x/net/context&quot;

	pb &quot;grpc-hello-world/proto&quot;
)

type helloService struct{}

func NewHelloService() *helloService {
	return &amp;helloService{}
}

func (h helloService) SayHelloWorld(ctx context.Context, r *pb.HelloWorldRequest) (*pb.HelloWorldResponse, error) {
	return &amp;pb.HelloWorldResponse{
		Message : &quot;test&quot;,
	}, nil
}
</code></pre><p>我们创建了<code>helloService</code>及其方法<code>SayHelloWorld</code>，对应<code>.proto</code>的<code>rpc SayHelloWorld</code>，这个方法需要有2个参数：<code>ctx context.Context</code>用于接受上下文参数、<code>r *pb.HelloWorldRequest</code>用于接受<code>protobuf</code>的<code>Request</code>参数（对应<code>.proto</code>的<code>message HelloWorldRequest</code>）</p>
<h3 id="编写servergo">*编写<code>server.go</code></h3>
<p>这一小章节，我们编写最为重要的服务端程序部分，涉及到大量的<code>grpc</code>、<code>grpc-gateway</code>及一些网络知识的应用</p>
<p>1、在<code>pkg</code>下新建<code>util</code>目录，新建<code>grpc.go</code>文件，写入内容：</p>
<pre><code>package util

import (
	&quot;net/http&quot;
	&quot;strings&quot;

	&quot;google.golang.org/grpc&quot;
)

func GrpcHandlerFunc(grpcServer *grpc.Server, otherHandler http.Handler) http.Handler {
    if otherHandler == nil {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            grpcServer.ServeHTTP(w, r)
        })
    }
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if r.ProtoMajor == 2 &amp;&amp; strings.Contains(r.Header.Get(&quot;Content-Type&quot;), &quot;application/grpc&quot;) {
            grpcServer.ServeHTTP(w, r)
        } else {
            otherHandler.ServeHTTP(w, r)
        }
    })
}
</code></pre><p><code>GrpcHandlerFunc</code>函数是用于判断请求是来源于<code>Rpc</code>客户端还是<code>Restful Api</code>的请求，根据不同的请求注册不同的<code>ServeHTTP</code>服务；<code>r.ProtoMajor == 2</code>也代表着请求必须基于<code>HTTP/2</code></p>
<p>2、在<code>pkg</code>下的<code>util</code>目录下，新建<code>tls.go</code>文件，写入内容：</p>
<pre><code>package util

import (
	&quot;crypto/tls&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;

    &quot;golang.org/x/net/http2&quot;
)

func GetTLSConfig(certPemPath, certKeyPath string) *tls.Config {
    var certKeyPair *tls.Certificate
    cert, _ := ioutil.ReadFile(certPemPath)
    key, _ := ioutil.ReadFile(certKeyPath)
    
    pair, err := tls.X509KeyPair(cert, key)
    if err != nil {
        log.Println(&quot;TLS KeyPair err: %v\n&quot;, err)
    }
    
    certKeyPair = &amp;pair

    return &amp;tls.Config{
        Certificates: []tls.Certificate{*certKeyPair},
        NextProtos:   []string{http2.NextProtoTLS},
    }
}
</code></pre><p><code>GetTLSConfig</code>函数是用于获取<code>TLS</code>配置，在内部，我们读取了<code>server.key</code>和<code>server.pem</code>这类证书凭证文件</p>
<ul>
<li><code>tls.X509KeyPair</code>：从一对<code>PEM</code>编码的数据中解析公钥/私钥对。成功则返回公钥/私钥对</li>
<li><code>http2.NextProtoTLS</code>：<code>NextProtoTLS</code>是谈判期间的<code>NPN/ALPN</code>协议，用于<strong>HTTP/2的TLS设置</strong></li>
<li><code>tls.Certificate</code>：返回一个或多个证书，实质我们解析<code>PEM</code>调用的<code>X509KeyPair</code>的函数声明就是<code>func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)</code>，返回值就是<code>Certificate</code></li>
</ul>
<p>总的来说该函数是用于处理从证书凭证文件（PEM），最终获取<code>tls.Config</code>作为<code>HTTP2</code>的使用参数</p>
<p>3、修改<code>server</code>目录下的<code>server.go</code>文件，该文件是我们服务里的核心文件，写入内容：</p>
<pre><code>package server

import (
    &quot;crypto/tls&quot;
    &quot;net&quot;
    &quot;net/http&quot;
    &quot;log&quot;

    &quot;golang.org/x/net/context&quot;
    &quot;google.golang.org/grpc&quot;
    &quot;google.golang.org/grpc/credentials&quot;
    &quot;github.com/grpc-ecosystem/grpc-gateway/runtime&quot;
    
    pb &quot;grpc-hello-world/proto&quot;
    &quot;grpc-hello-world/pkg/util&quot;
)

var (
    ServerPort string
    CertName string
    CertPemPath string
    CertKeyPath string
    EndPoint string
)

func Serve() (err error){
    EndPoint = &quot;:&quot; + ServerPort
    conn, err := net.Listen(&quot;tcp&quot;, EndPoint)
    if err != nil {
        log.Printf(&quot;TCP Listen err:%v\n&quot;, err)
    }

    tlsConfig := util.GetTLSConfig(CertPemPath, CertKeyPath)
    srv := createInternalServer(conn, tlsConfig)

    log.Printf(&quot;gRPC and https listen on: %s\n&quot;, ServerPort)

    if err = srv.Serve(tls.NewListener(conn, tlsConfig)); err != nil {
        log.Printf(&quot;ListenAndServe: %v\n&quot;, err)
    }

    return err
}

func createInternalServer(conn net.Listener, tlsConfig *tls.Config) (*http.Server) {
    var opts []grpc.ServerOption

    // grpc server
    creds, err := credentials.NewServerTLSFromFile(CertPemPath, CertKeyPath)
    if err != nil {
        log.Printf(&quot;Failed to create server TLS credentials %v&quot;, err)
    }

    opts = append(opts, grpc.Creds(creds))
    grpcServer := grpc.NewServer(opts...)

    // register grpc pb
    pb.RegisterHelloWorldServer(grpcServer, NewHelloService())

    // gw server
    ctx := context.Background()
    dcreds, err := credentials.NewClientTLSFromFile(CertPemPath, CertName)
    if err != nil {
        log.Printf(&quot;Failed to create client TLS credentials %v&quot;, err)
    }
    dopts := []grpc.DialOption{grpc.WithTransportCredentials(dcreds)}
    gwmux := runtime.NewServeMux()

    // register grpc-gateway pb
    if err := pb.RegisterHelloWorldHandlerFromEndpoint(ctx, gwmux, EndPoint, dopts); err != nil {
        log.Printf(&quot;Failed to register gw server: %v\n&quot;, err)
    }

    // http服务
    mux := http.NewServeMux()
    mux.Handle(&quot;/&quot;, gwmux)

    return &amp;http.Server{
        Addr:      EndPoint,
        Handler:   util.GrpcHandlerFunc(grpcServer, mux),
        TLSConfig: tlsConfig,
    }
}
</code></pre><h4 id="server流程剖析"><code>server</code>流程剖析</h4>
<p>我们将这一大块代码，分成以下几个部分来理解</p>
<h5 id="一启动监听">一、启动监听</h5>
<p><code>net.Listen(&quot;tcp&quot;, EndPoint)</code>用于监听本地的网络地址通知，它的函数原型<code>func Listen(network, address string) (Listener, error)</code></p>
<p>参数：<code>network</code>必须传入<code>tcp</code>、<code>tcp4</code>、<code>tcp6</code>、<code>unix</code>、<code>unixpacket</code>，若<code>address</code>为空或为0则会自动选择一个端口号
返回值：通过查看源码我们可以得知其返回值为<code>Listener</code>，结构体原型：</p>
<pre><code>type Listener interface {
    Accept() (Conn, error)
    Close() error
    Addr() Addr
}
</code></pre><p>通过分析得知，<strong>最后<code>net.Listen</code>会返回一个监听器的结构体，返回给接下来的动作，让其执行下一步的操作</strong>，它可以执行三类操作</p>
<ul>
<li><code>Accept</code>：接受等待并将下一个连接返回给<code>Listener</code></li>
<li><code>Close</code>：关闭<code>Listener</code></li>
<li><code>Addr</code>：返回<code>Listener</code>的网络地址</li>
</ul>
<h5 id="二获取tls">二、获取<code>TLS</code></h5>
<p>通过<code>util.GetTLSConfig</code>解析得到<code>tls.Config</code>，传达给<code>http.Server</code>服务的<code>TLSConfig</code>配置项使用</p>
<h5 id="三创建内部服务">三、创建内部服务</h5>
<p><code>createInternalServer</code>函数，是整个服务端的核心流转部分</p>
<p>程序采用的是<code>HTT2</code>、<code>HTTPS</code>也就是需要支持<code>TLS</code>，因此在启动<code>grpc.NewServer</code>前，我们要将认证的中间件注册进去</p>
<p>而前面所获取的<code>tlsConfig</code>仅能给<code>HTTP</code>使用，因此<strong>第一步</strong>我们要创建<code>grpc</code>的<code>TLS</code>认证凭证</p>
<p><strong>1、创建<code>grpc</code>的<code>TLS</code>认证凭证</strong></p>
<p>新增引用<code>google.golang.org/grpc/credentials</code>的第三方包，它实现了<code>grpc</code>库支持的各种凭证，该凭证封装了客户机需要的所有状态，以便与服务器进行身份验证并进行各种断言，例如关于客户机的身份，角色或是否授权进行特定的呼叫</p>
<p>我们调用<code>NewServerTLSFromFile</code>来达到我们的目的，它能够从输入证书文件和服务器的密钥文件<strong>构造TLS证书凭证</strong></p>
<pre><code>func NewServerTLSFromFile(certFile, keyFile string) (TransportCredentials, error) {
    //LoadX509KeyPair读取并解析来自一对文件的公钥/私钥对
    cert, err := tls.LoadX509KeyPair(certFile, keyFile)
    if err != nil {
        return nil, err
    }
    //NewTLS使用tls.Config来构建基于TLS的TransportCredentials
    return NewTLS(&amp;tls.Config{Certificates: []tls.Certificate{cert}}), nil
}
</code></pre><p><strong>2、设置<code>grpc ServerOption</code></strong></p>
<p>以<code>grpc.Creds(creds)</code>为例，其原型为<code>func Creds(c credentials.TransportCredentials) ServerOption</code>，该函数返回<code>ServerOption</code>，它为服务器连接设置凭据</p>
<p><strong>3、创建<code>grpc</code>服务端</strong></p>
<p>函数原型：</p>
<pre><code>func NewServer(opt ...ServerOption) *Server
</code></pre><p>我们在此处创建了一个没有注册服务的<code>grpc</code>服务端，还没有开始接受请求</p>
<pre><code>grpcServer := grpc.NewServer(opts...)
</code></pre><p><strong>4、注册<code>grpc</code>服务</strong></p>
<pre><code>pb.RegisterHelloWorldServer(grpcServer, NewHelloService())
</code></pre><p><strong>5、创建<code>grpc-gateway</code>关联组件</strong></p>
<pre><code>ctx := context.Background()
dcreds, err := credentials.NewClientTLSFromFile(CertPemPath, CertName)
if err != nil {
    log.Println(&quot;Failed to create client TLS credentials %v&quot;, err)
}
dopts := []grpc.DialOption{grpc.WithTransportCredentials(dcreds)}
</code></pre><ul>
<li><code>context.Background</code>：返回一个非空的空上下文。它没有被注销，没有值，没有过期时间。它通常由主函数、初始化和测试使用，并作为传入请求的<strong>顶级上下文</strong></li>
<li><code>credentials.NewClientTLSFromFile</code>：从客户机的输入证书文件构造TLS凭证</li>
<li><code>grpc.WithTransportCredentials</code>：配置一个连接级别的安全凭据(例：<code>TLS</code>、<code>SSL</code>)，返回值为<code>type DialOption</code></li>
<li><code>grpc.DialOption</code>：<code>DialOption</code>选项配置我们如何设置连接（其内部具体由多个的<code>DialOption</code>组成，决定其设置连接的内容）</li>
</ul>
<p><strong>6、创建<code>HTTP NewServeMux</code>及注册<code>grpc-gateway</code>逻辑</strong></p>
<pre><code>gwmux := runtime.NewServeMux()

// register grpc-gateway pb
if err := pb.RegisterHelloWorldHandlerFromEndpoint(ctx, gwmux, EndPoint, dopts); err != nil {
    log.Println(&quot;Failed to register gw server: %v\n&quot;, err)
}

// http服务
mux := http.NewServeMux()
mux.Handle(&quot;/&quot;, gwmux)
</code></pre><ul>
<li><code>runtime.NewServeMux</code>：返回一个新的<code>ServeMux</code>，它的内部映射是空的；<code>ServeMux</code>是<code>grpc-gateway</code>的一个请求多路复用器。它将<code>http</code>请求与模式匹配，并调用相应的处理程序</li>
<li><code>RegisterHelloWorldHandlerFromEndpoint</code>：如函数名，注册<code>HelloWorld</code>服务的<code>HTTP Handle</code>到<code>grpc</code>端点</li>
<li><code>http.NewServeMux</code>：<code>分配并返回一个新的ServeMux</code></li>
<li><code>mux.Handle</code>：为给定模式注册处理程序</li>
</ul>
<p>（带着疑问去看程序）为什么<code>gwmux</code>可以放入<code>mux.Handle</code>中？</p>
<p>首先我们看看它们的原型是怎么样的</p>
<p>（1）<code>http.NewServeMux()</code></p>
<pre><code>func NewServeMux() *ServeMux {
        return new(ServeMux) 
}
</code></pre><pre><code>type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
</code></pre><p>（2）<code>runtime.NewServeMux</code>？</p>
<pre><code>func NewServeMux(opts ...ServeMuxOption) *ServeMux {
    serveMux := &amp;ServeMux{
        handlers:               make(map[string][]handler),
        forwardResponseOptions: make([]func(context.Context, http.ResponseWriter, proto.Message) error, 0),
        marshalers:             makeMarshalerMIMERegistry(),
    }
    ...
    return serveMux
}
</code></pre><p>（3）<code>http.NewServeMux()</code>的<code>Handle</code>方法</p>
<pre><code>func (mux *ServeMux) Handle(pattern string, handler Handler)
</code></pre><p>通过分析可得知，两者<code>NewServeMux</code>都是最终返回<code>serveMux</code>，<code>Handler</code>中导出的方法仅有<code>ServeHTTP</code>，功能是用于响应HTTP请求</p>
<p>我们回到<code>Handle interface</code>中，可以得出结论就是任何结构体，只要实现了<code>ServeHTTP</code>方法，这个结构就可以称为<code>Handle</code>，<code>ServeMux</code>会使用该<code>Handler</code>调用<code>ServeHTTP</code>方法处理请求，这也就是<strong>自定义<code>Handler</code></strong></p>
<p>而我们这里正是将<code>grpc-gateway</code>中注册好的<code>HTTP Handler</code>无缝的植入到<code>net/http</code>的<code>Handle</code>方法中</p>
<p><strong>补充：在<code>go</code>中任何结构体只要实现了与接口相同的方法，就等同于实现了接口</strong></p>
<p><strong>7、注册具体服务</strong></p>
<pre><code>if err := pb.RegisterHelloWorldHandlerFromEndpoint(ctx, gwmux, EndPoint, dopts); err != nil {
    log.Println(&quot;Failed to register gw server: %v\n&quot;, err)
}
</code></pre><p>在这段代码中，我们利用了前几小节的</p>
<ul>
<li>上下文</li>
<li><code>gateway-grpc</code>的请求多路复用器</li>
<li>服务网络地址</li>
<li>配置好的安全凭据</li>
</ul>
<p>注册了<code>HelloWorld</code>这一个服务</p>
<h5 id="四创建tlsnewlistener">四、创建<code>tls.NewListener</code></h5>
<pre><code>func NewListener(inner net.Listener, config *Config) net.Listener {
    l := new(listener)
    l.Listener = inner
    l.config = config
    return l
}
</code></pre><p><code>NewListener</code>将会创建一个<code>Listener</code>，它接受两个参数，第一个是来自内部<code>Listener</code>的监听器，第二个参数是<code>tls.Config</code>（必须包含至少一个证书）</p>
<h5 id="五服务开始接受请求">五、服务开始接受请求</h5>
<p>在最后我们调用<code>srv.Serve(tls.NewListener(conn, tlsConfig))</code>，可以得知它是<code>http.Server</code>的方法，并且需要一个<code>Listener</code>作为参数，那么<code>Serve</code>内部做了些什么事呢？</p>
<pre><code>func (srv *Server) Serve(l net.Listener) error {
    defer l.Close()
    ...

    baseCtx := context.Background() // base is always background, per Issue 16220
    ctx := context.WithValue(baseCtx, ServerContextKey, srv)
    for {
        rw, e := l.Accept()
        ...
        c := srv.newConn(rw)
        c.setState(c.rwc, StateNew) // before Serve can return
        go c.serve(ctx)
    }
}
</code></pre><p>粗略的看，它创建了一个<code>context.Background()</code>上下文对象，并调用<code>Listener</code>的<code>Accept</code>方法开始接受外部请求，在获取到连接数据后使用<code>newConn</code>创建连接对象，在最后使用<code>goroutine</code>的方式处理连接请求，达到其目的</p>
<p><strong>补充：对于<code>HTTP/2</code>支持，在调用<code>Serve</code>之前，应将<code>srv.TLSConfig</code>初始化为提供的<code>Listener</code>的TLS配置。如果<code>srv.TLSConfig</code>非零，并且在<code>Config.NextProtos</code>中不包含字符串<code>h2</code>，则不启用<code>HTTP/2</code>支持</strong></p>
<h2 id="六验证功能">六、验证功能</h2>
<h3 id="编写测试客户端">编写测试客户端</h3>
<p>在<code>grpc-hello-world/</code>下新建目录<code>client</code>，新建<code>client.go</code>文件，新增内容：</p>
<pre><code>package main

import (
	&quot;log&quot;

	&quot;golang.org/x/net/context&quot;
	&quot;google.golang.org/grpc&quot;
	&quot;google.golang.org/grpc/credentials&quot;

	pb &quot;grpc-hello-world/proto&quot;
)

func main() {
	creds, err := credentials.NewClientTLSFromFile(&quot;../certs/server.pem&quot;, &quot;dev&quot;)
	if err != nil {
		log.Println(&quot;Failed to create TLS credentials %v&quot;, err)
	}
	conn, err := grpc.Dial(&quot;:50052&quot;, grpc.WithTransportCredentials(creds))
	defer conn.Close()

	if err != nil {
		log.Println(err)
	}

	c := pb.NewHelloWorldClient(conn)
	context := context.Background()
	body := &amp;pb.HelloWorldRequest{
		Referer : &quot;Grpc&quot;,
	}

	r, err := c.SayHelloWorld(context, body)
	if err != nil {
		log.Println(err)
	}

	log.Println(r.Message)
}
</code></pre><p>由于客户端只是展示测试用，就简单的来了，原本它理应归类到<code>cobra</code>的管控下，配置管理等等都应可控化</p>
<p>在看这篇文章的你，可以试试将测试客户端归类好</p>
<h3 id="启动服务端">启动服务端</h3>
<p>回到<code>grpc-hello-world/</code>目录下，启动服务端<code>go run main.go server</code>，成功则仅返回</p>
<pre><code>2018/02/26 17:19:36 gRPC and https listen on: 50052
</code></pre><h3 id="执行测试客户端">执行测试客户端</h3>
<p>回到<code>client</code>目录下，启动客户端<code>go run client.go</code>，成功则返回</p>
<pre><code>2018/02/26 17:22:57 Grpc
</code></pre><h3 id="执行测试restful-api">执行测试Restful Api</h3>
<pre><code>curl -X POST -k https://localhost:50052/hello_world -d '{&quot;referer&quot;: &quot;restful_api&quot;}'
</code></pre><p>成功则返回<code>{&quot;message&quot;:&quot;restful_api&quot;}</code></p>
<hr>
<h2 id="最终目录结构">最终目录结构</h2>
<pre><code>grpc-hello-world
├── certs
│   ├── server.key
│   └── server.pem
├── client
│   └── client.go
├── cmd
│   ├── root.go
│   └── server.go
├── main.go
├── pkg
│   └── util
│       ├── grpc.go
│       └── tls.go
├── proto
│   ├── google
│   │   └── api
│   │       ├── annotations.pb.go
│   │       ├── annotations.proto
│   │       ├── http.pb.go
│   │       └── http.proto
│   ├── hello.pb.go
│   ├── hello.pb.gw.go
│   └── hello.proto
└── server
    ├── hello.go
    └── server.go
</code></pre><p>至此本节就结束了，推荐一下<code>jergoo</code>的文章，大家有时间可以看看</p>
<p>另外本节涉及了许多组件间的知识，值得大家细细的回味，非常有意义！</p>
<h2 id="参考">参考</h2>
<h3 id="示例代码">示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/grpc-hello-world">grpc-hello-world</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载一」gRPC介绍与环境安装</title>
			<link>https://eddycjy.com/posts/go/grpc-gateway/2018-02-23-install/</link>
			<pubDate>Fri, 23 Feb 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/grpc-gateway/2018-02-23-install/</guid>
			<description>假定我们有一个项目需求，希望用Rpc作为内部API的通讯，同时也想对外提供Restful Api，写两套又太繁琐不符合
于是我们想到了Grpc以及Grpc Gateway，这就是我们所需要的
准备环节 在正式开始我们的Grpc+Grpc Gateway实践前，我们需要先配置好我们的开发环境
 Grpc Protoc Plugin Protocol Buffers Grpc-gateway  Grpc 是什么 Google对Grpc的定义：
 A high performance, open-source universal RPC framework
 也就是Grpc是一个高性能、开源的通用RPC框架，具有以下特性：
 强大的IDL，使用Protocol Buffers作为数据交换的格式，支持v2、v3（推荐v3） 跨语言、跨平台，也就是Grpc支持多种平台和语言 支持HTTP2，双向传输、多路复用、认证等  安装 1、官方推荐（需科学上网）
go get -u google.golang.org/grpc 2、通过github.com
进入到第一个$GOPATH目录（因为go get 会默认安装在第一个下）下，新建google.golang.org目录，拉取golang在github上的镜像库：
cd /usr/local/go/path/src mkdir google.golang.org cd google.golang.org/ git clone https://github.com/grpc/grpc-go mv grpc-go/ grpc/ 目录结构：
google.golang.org/ └── grpc ... 而在grpc下有许多常用的包，例如：
 metadata：定义了grpc所支持的元数据结构，包中方法可以对MD进行获取和处理 credentials：实现了grpc所支持的各种认证凭据，封装了客户端对服务端进行身份验证所需要的所有状态，并做出各种断言 codes：定义了grpc使用的标准错误码，可通用  Protoc Plugin 是什么 编译器插件</description>
			<content type="html"><![CDATA[<p>假定我们有一个项目需求，希望用<code>Rpc</code>作为内部<code>API</code>的通讯，同时也想对外提供<code>Restful Api</code>，写两套又太繁琐不符合</p>
<p>于是我们想到了<code>Grpc</code>以及<code>Grpc Gateway</code>，这就是我们所需要的</p>
<p><img src="https://camo.githubusercontent.com/e75a8b46b078a3c1df0ed9966a16c24add9ccb83/68747470733a2f2f646f63732e676f6f676c652e636f6d2f64726177696e67732f642f3132687034435071724e5046686174744c5f63496f4a707446766c41716d35774c513067677149356d6b43672f7075623f773d37343926683d333730" alt="image"></p>
<h2 id="准备环节">准备环节</h2>
<p>在正式开始我们的<code>Grpc</code>+<code>Grpc Gateway</code>实践前，我们需要先配置好我们的开发环境</p>
<ul>
<li>Grpc</li>
<li>Protoc Plugin</li>
<li>Protocol Buffers</li>
<li>Grpc-gateway</li>
</ul>
<h2 id="grpc">Grpc</h2>
<h3 id="是什么">是什么</h3>
<p>Google对<code>Grpc</code>的定义：</p>
<blockquote>
<p>A high performance, open-source universal RPC framework</p>
</blockquote>
<p>也就是<code>Grpc</code>是一个高性能、开源的通用RPC框架，具有以下特性：</p>
<ul>
<li>强大的<code>IDL</code>，使用<code>Protocol Buffers</code>作为数据交换的格式，支持<code>v2</code>、<code>v3</code>（推荐<code>v3</code>）</li>
<li>跨语言、跨平台，也就是<code>Grpc</code>支持多种平台和语言</li>
<li><strong>支持HTTP2</strong>，双向传输、多路复用、认证等</li>
</ul>
<h3 id="安装">安装</h3>
<p>1、官方推荐（需科学上网）</p>
<pre><code>go get -u google.golang.org/grpc
</code></pre><p>2、通过<code>github.com</code></p>
<p>进入到第一个$GOPATH目录（因为<code>go get</code> 会默认安装在第一个下）下，新建<code>google.golang.org</code>目录，拉取<code>golang</code>在<code>github</code>上的镜像库：</p>
<pre><code>cd /usr/local/go/path/src   

mkdir google.golang.org

cd google.golang.org/

git clone https://github.com/grpc/grpc-go

mv grpc-go/ grpc/
</code></pre><p>目录结构：</p>
<pre><code>google.golang.org/
└── grpc
    ...
</code></pre><p>而在<code>grpc</code>下有许多常用的包，例如：</p>
<ul>
<li><a href="https://gowalker.org/google.golang.org/grpc/metadata">metadata</a>：定义了<code>grpc</code>所支持的元数据结构，包中方法可以对<code>MD</code>进行获取和处理</li>
<li><a href="https://gowalker.org/google.golang.org/grpc/credentials">credentials</a>：实现了<code>grpc</code>所支持的各种认证凭据，封装了客户端对服务端进行身份验证所需要的所有状态，并做出各种断言</li>
<li><a href="https://gowalker.org/google.golang.org/grpc/codes">codes</a>：定义了<code>grpc</code>使用的标准错误码，可通用</li>
</ul>
<h2 id="protoc-plugin">Protoc Plugin</h2>
<h3 id="是什么-1">是什么</h3>
<p>编译器插件</p>
<h3 id="安装-1">安装</h3>
<pre><code>go get -u github.com/golang/protobuf/protoc-gen-go
</code></pre><p>将<code>Protoc Plugin</code>的可执行文件从$GOPATH中移动到$GOBIN下</p>
<pre><code>mv /usr/local/go/path/bin/protoc-gen-go /usr/local/go/bin/
</code></pre><h2 id="protocol-buffers-v3">Protocol Buffers v3</h2>
<h3 id="是什么-2">是什么</h3>
<blockquote>
<p>Protocol buffers are a flexible, efficient, automated mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages. You can even update your data structure without breaking deployed programs that are compiled against the &ldquo;old&rdquo; format.</p>
</blockquote>
<p><code>Protocol Buffers</code>是<code>Google</code>推出的一种数据描述语言，支持多语言、多平台，它是一种二进制的格式，总得来说就是更小、更快、更简单、更灵活，目前分别有<code>v2</code>、<code>v3</code>的版本，我们推荐使用<code>v3</code></p>
<ul>
<li><a href="https://developers.google.com/protocol-buffers/docs/proto">proto2 文档地址</a></li>
<li><a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3 文档地址</a></li>
</ul>
<p>建议可以阅读下官方文档的介绍，本系列会在使用时简单介绍所涉及的内容</p>
<h3 id="安装-2">安装</h3>
<pre><code>wget https://github.com/google/protobuf/releases/download/v3.5.1/protobuf-all-3.5.1.zip
unzip protobuf-all-3.5.1.zip
cd protobuf-3.5.1/
./configure
make
make install
</code></pre><p>检查是否安装成功</p>
<pre><code>protoc --version
</code></pre><p>如果出现报错</p>
<pre><code>protoc: error while loading shared libraries: libprotobuf.so.15: cannot open shared object file: No such file or directory
</code></pre><p>则执行<code>ldconfig</code>后，再次运行即可成功</p>
<h4 id="为什么要执行ldconfig">为什么要执行<code>ldconfig</code></h4>
<p>我们通过控制台输出的信息可以知道，<code>Protocol Buffers Libraries</code>的默认安装路径在<code>/usr/local/lib</code></p>
<pre><code>Libraries have been installed in:
   /usr/local/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the `-LLIBDIR'
flag during linking and do at least one of the following:
   - add LIBDIR to the `LD_LIBRARY_PATH' environment variable
     during execution
   - add LIBDIR to the `LD_RUN_PATH' environment variable
     during linking
   - use the `-Wl,-rpath -Wl,LIBDIR' linker flag
   - have your system administrator add LIBDIR to `/etc/ld.so.conf'

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
</code></pre><p>而我们安装了一个新的动态链接库，<code>ldconfig</code>一般在系统启动时运行，所以现在会找不到这个<code>lib</code>，因此我们要手动执行<code>ldconfig</code>，<strong>让动态链接库为系统所共享，它是一个动态链接库管理命令</strong>，这就是<code>ldconfig</code>命令的作用</p>
<h3 id="protoc使用">protoc使用</h3>
<p>我们按照惯例执行<code>protoc --help</code>（查看帮助文档），我们抽出几个常用的命令进行讲解</p>
<p>1、<code>-IPATH, --proto_path=PATH</code>：指定<code>import</code>搜索的目录，可指定多个，如果不指定则默认当前工作目录</p>
<p>2、<code>--go_out</code>：生成<code>golang</code>源文件</p>
<h4 id="参数">参数</h4>
<p>若要将额外的参数传递给插件，可使用从输出目录中分离出来的逗号分隔的参数列表:</p>
<pre><code>protoc --go_out=plugins=grpc,import_path=mypackage:. *.proto
</code></pre><ul>
<li><code>import_prefix=xxx</code>：将指定前缀添加到所有<code>import</code>路径的开头</li>
<li><code>import_path=foo/bar</code>：如果文件没有声明<code>go_package</code>，则用作包。如果它包含斜杠，那么最右边的斜杠将被忽略。</li>
<li><code>plugins=plugin1+plugin2</code>：指定要加载的子插件列表（我们所下载的repo中唯一的插件是grpc）</li>
<li><code>Mfoo/bar.proto=quux/shme</code>： <code>M</code>参数，指定<code>.proto</code>文件编译后的包名（<code>foo/bar.proto</code>编译后为包名为<code>quux/shme</code>）</li>
</ul>
<h4 id="grpc支持">Grpc支持</h4>
<p>如果<code>proto</code>文件指定了<code>RPC</code>服务，<code>protoc-gen-go</code>可以生成与<code>grpc</code>相兼容的代码，我们仅需要将<code>plugins=grpc</code>参数传递给<code>--go_out</code>，就可以达到这个目的</p>
<pre><code>protoc --go_out=plugins=grpc:. *.proto
</code></pre><h2 id="grpc-gateway">Grpc-gateway</h2>
<h3 id="是什么-3">是什么</h3>
<blockquote>
<p>grpc-gateway is a plugin of protoc. It reads gRPC service definition, and generates a reverse-proxy server which translates a RESTful JSON API into gRPC. This server is generated according to custom options in your gRPC definition.</p>
</blockquote>
<p><a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a>是protoc的一个插件。它读取gRPC服务定义，并生成一个反向代理服务器，将RESTful JSON API转换为gRPC。此服务器是根据gRPC定义中的自定义选项生成的。</p>
<h3 id="安装-3">安装</h3>
<pre><code>go get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway
</code></pre><p>如果出现以下报错，我们分析错误提示可得知是连接超时（大概是被墙了）</p>
<pre><code>package google.golang.org/genproto/googleapis/api/annotations: unrecognized import path &quot;google.golang.org/genproto/googleapis/api/annotations&quot; (https fetch: Get https://google.golang.org/genproto/googleapis/api/annotations?go-get=1: dial tcp 216.239.37.1:443: getsockopt: connection timed out)
</code></pre><p>有两种解决方法，</p>
<p>1、科学上网</p>
<p>2、通过<code>github.com</code></p>
<p>进入到第一个$GOTPATH目录的<code>google.golang.org</code>目录下，拉取<code>genproto</code>在<code>github</code>上的<code>go-genproto</code>镜像库：</p>
<pre><code>cd /usr/local/go/path/src/google.golang.org

git clone https://github.com/google/go-genproto.git

mv go-genproto/ genproto/
</code></pre><p>在安装完毕后，我们将<code>grpc-gateway</code>的可执行文件从$GOPATH中移动到$GOBIN</p>
<pre><code>mv /usr/local/go/path/bin/protoc-gen-grpc-gateway /usr/local/go/bin/
</code></pre><p>到这里我们这节就基本完成了，建议多反复看几遍加深对各个组件的理解！</p>
<h2 id="参考">参考</h2>
<h3 id="示例代码">示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/grpc-hello-world">grpc-hello-world</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>「连载六」编写一个简单的文件日志</title>
			<link>https://eddycjy.com/posts/go/gin/2018-02-15-log/</link>
			<pubDate>Thu, 15 Feb 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-02-15-log/</guid>
			<description>涉及知识点  自定义 log。  本文目标 在上一节中，我们解决了 API&amp;rsquo;s 可以任意访问的问题，那么我们现在还有一个问题，就是我们的日志，都是输出到控制台上的，这显然对于一个项目来说是不合理的，因此我们这一节简单封装log库，使其支持简单的文件日志！
新建logging包 我们在pkg下新建logging目录，新建file.go和log.go文件，写入内容：
编写file文件 1、 file.go：
package logging import ( &amp;#34;os&amp;#34; &amp;#34;time&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; ) var ( LogSavePath = &amp;#34;runtime/logs/&amp;#34; LogSaveName = &amp;#34;log&amp;#34; LogFileExt = &amp;#34;log&amp;#34; TimeFormat = &amp;#34;20060102&amp;#34; ) func getLogFilePath() string { return fmt.Sprintf(&amp;#34;%s&amp;#34;, LogSavePath) } func getLogFileFullPath() string { prefixPath := getLogFilePath() suffixPath := fmt.Sprintf(&amp;#34;%s%s.%s&amp;#34;, LogSaveName, time.Now().Format(TimeFormat), LogFileExt) return fmt.Sprintf(&amp;#34;%s%s&amp;#34;, prefixPath, suffixPath) } func openLogFile(filePath string) *os.File { _, err := os.</description>
			<content type="html"><![CDATA[<h2 id="涉及知识点">涉及知识点</h2>
<ul>
<li>自定义 log。</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>在上一节中，我们解决了 API&rsquo;s 可以任意访问的问题，那么我们现在还有一个问题，就是我们的日志，都是输出到控制台上的，这显然对于一个项目来说是不合理的，因此我们这一节简单封装<code>log</code>库，使其支持简单的文件日志！</p>
<h2 id="新建logging包">新建<code>logging</code>包</h2>
<p>我们在<code>pkg</code>下新建<code>logging</code>目录，新建<code>file.go</code>和<code>log.go</code>文件，写入内容：</p>
<h3 id="编写file文件">编写<code>file</code>文件</h3>
<p><strong>1、 file.go：</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">logging</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;time&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">LogSavePath</span> <span class="p">=</span> <span class="s">&#34;runtime/logs/&#34;</span>
	<span class="nx">LogSaveName</span> <span class="p">=</span> <span class="s">&#34;log&#34;</span>
	<span class="nx">LogFileExt</span> <span class="p">=</span> <span class="s">&#34;log&#34;</span>
	<span class="nx">TimeFormat</span> <span class="p">=</span> <span class="s">&#34;20060102&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">getLogFilePath</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">LogSavePath</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getLogFileFullPath</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">prefixPath</span> <span class="o">:=</span> <span class="nf">getLogFilePath</span><span class="p">()</span>
	<span class="nx">suffixPath</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s%s.%s&#34;</span><span class="p">,</span> <span class="nx">LogSaveName</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="nx">TimeFormat</span><span class="p">),</span> <span class="nx">LogFileExt</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s%s&#34;</span><span class="p">,</span> <span class="nx">prefixPath</span><span class="p">,</span> <span class="nx">suffixPath</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">openLogFile</span><span class="p">(</span><span class="nx">filePath</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Stat</span><span class="p">(</span><span class="nx">filePath</span><span class="p">)</span>
	<span class="k">switch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">):</span>
			<span class="nf">mkDir</span><span class="p">()</span>
		<span class="k">case</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsPermission</span><span class="p">(</span><span class="nx">err</span><span class="p">):</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Permission :%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">handle</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="nx">filePath</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_APPEND</span> <span class="p">|</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span> <span class="p">|</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">,</span> <span class="mo">0644</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Fail to OpenFile :%v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">handle</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">mkDir</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">dir</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getwd</span><span class="p">()</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">MkdirAll</span><span class="p">(</span><span class="nx">dir</span> <span class="o">+</span> <span class="s">&#34;/&#34;</span> <span class="o">+</span> <span class="nf">getLogFilePath</span><span class="p">(),</span> <span class="nx">os</span><span class="p">.</span><span class="nx">ModePerm</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>os.Stat</code>：返回文件信息结构描述文件。如果出现错误，会返回<code>*PathError</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PathError</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Op</span>   <span class="kt">string</span>
    <span class="nx">Path</span> <span class="kt">string</span>
    <span class="nx">Err</span>  <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>os.IsNotExist</code>：能够接受<code>ErrNotExist</code>、<code>syscall</code>的一些错误，它会返回一个布尔值，能够得知文件不存在或目录不存在</li>
<li><code>os.IsPermission</code>：能够接受<code>ErrPermission</code>、<code>syscall</code>的一些错误，它会返回一个布尔值，能够得知权限是否满足</li>
<li><code>os.OpenFile</code>：调用文件，支持传入文件名称、指定的模式调用文件、文件权限，返回的文件的方法可以用于 I/O。如果出现错误，则为<code>*PathError</code>。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="c1">// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.
</span><span class="c1"></span>    <span class="nx">O_RDONLY</span> <span class="kt">int</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">O_RDONLY</span> <span class="c1">// 以只读模式打开文件
</span><span class="c1"></span>    <span class="nx">O_WRONLY</span> <span class="kt">int</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">O_WRONLY</span> <span class="c1">// 以只写模式打开文件
</span><span class="c1"></span>    <span class="nx">O_RDWR</span>   <span class="kt">int</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">O_RDWR</span>   <span class="c1">// 以读写模式打开文件
</span><span class="c1"></span>    <span class="c1">// The remaining values may be or&#39;ed in to control behavior.
</span><span class="c1"></span>    <span class="nx">O_APPEND</span> <span class="kt">int</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">O_APPEND</span> <span class="c1">// 在写入时将数据追加到文件中
</span><span class="c1"></span>    <span class="nx">O_CREATE</span> <span class="kt">int</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">O_CREAT</span>  <span class="c1">// 如果不存在，则创建一个新文件
</span><span class="c1"></span>    <span class="nx">O_EXCL</span>   <span class="kt">int</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">O_EXCL</span>   <span class="c1">// 使用O_CREATE时，文件必须不存在
</span><span class="c1"></span>    <span class="nx">O_SYNC</span>   <span class="kt">int</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">O_SYNC</span>   <span class="c1">// 同步IO
</span><span class="c1"></span>    <span class="nx">O_TRUNC</span>  <span class="kt">int</span> <span class="p">=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">O_TRUNC</span>  <span class="c1">// 如果可以，打开时
</span><span class="c1"></span><span class="p">)</span>
</code></pre></div><ul>
<li><code>os.Getwd</code>：返回与当前目录对应的根路径名</li>
<li><code>os.MkdirAll</code>：创建对应的目录以及所需的子目录，若成功则返回<code>nil</code>，否则返回<code>error</code></li>
<li><code>os.ModePerm</code>：<code>const</code>定义<code>ModePerm FileMode = 0777</code></li>
</ul>
<h3 id="编写log文件">编写<code>log</code>文件</h3>
<p><strong>2、log.go</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">logging</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;runtime&#34;</span>
	<span class="s">&#34;path/filepath&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Level</span> <span class="kt">int</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">F</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span>

	<span class="nx">DefaultPrefix</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
	<span class="nx">DefaultCallerDepth</span> <span class="p">=</span> <span class="mi">2</span>

	<span class="nx">logger</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span>
	<span class="nx">logPrefix</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
	<span class="nx">levelFlags</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;DEBUG&#34;</span><span class="p">,</span> <span class="s">&#34;INFO&#34;</span><span class="p">,</span> <span class="s">&#34;WARN&#34;</span><span class="p">,</span> <span class="s">&#34;ERROR&#34;</span><span class="p">,</span> <span class="s">&#34;FATAL&#34;</span><span class="p">}</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">DEBUG</span> <span class="nx">Level</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">INFO</span>
	<span class="nx">WARNING</span>
	<span class="nx">ERROR</span>
	<span class="nx">FATAL</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">filePath</span> <span class="o">:=</span> <span class="nf">getLogFileFullPath</span><span class="p">()</span>
	<span class="nx">F</span> <span class="p">=</span> <span class="nf">openLogFile</span><span class="p">(</span><span class="nx">filePath</span><span class="p">)</span>

	<span class="nx">logger</span> <span class="p">=</span> <span class="nx">log</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">F</span><span class="p">,</span> <span class="nx">DefaultPrefix</span><span class="p">,</span> <span class="nx">log</span><span class="p">.</span><span class="nx">LstdFlags</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Debug</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nf">setPrefix</span><span class="p">(</span><span class="nx">DEBUG</span><span class="p">)</span>
	<span class="nx">logger</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Info</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nf">setPrefix</span><span class="p">(</span><span class="nx">INFO</span><span class="p">)</span>
	<span class="nx">logger</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Warn</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nf">setPrefix</span><span class="p">(</span><span class="nx">WARNING</span><span class="p">)</span>
	<span class="nx">logger</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Error</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nf">setPrefix</span><span class="p">(</span><span class="nx">ERROR</span><span class="p">)</span>
	<span class="nx">logger</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Fatal</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nf">setPrefix</span><span class="p">(</span><span class="nx">FATAL</span><span class="p">)</span>
	<span class="nx">logger</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">setPrefix</span><span class="p">(</span><span class="nx">level</span> <span class="nx">Level</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">file</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Caller</span><span class="p">(</span><span class="nx">DefaultCallerDepth</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">logPrefix</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;[%s][%s:%d]&#34;</span><span class="p">,</span> <span class="nx">levelFlags</span><span class="p">[</span><span class="nx">level</span><span class="p">],</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Base</span><span class="p">(</span><span class="nx">file</span><span class="p">),</span> <span class="nx">line</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">logPrefix</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;[%s]&#34;</span><span class="p">,</span> <span class="nx">levelFlags</span><span class="p">[</span><span class="nx">level</span><span class="p">])</span>
	<span class="p">}</span>

	<span class="nx">logger</span><span class="p">.</span><span class="nf">SetPrefix</span><span class="p">(</span><span class="nx">logPrefix</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><ul>
<li><code>log.New</code>：创建一个新的日志记录器。<code>out</code>定义要写入日志数据的<code>IO</code>句柄。<code>prefix</code>定义每个生成的日志行的开头。<code>flag</code>定义了日志记录属性</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">out</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">prefix</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">flag</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Logger</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Logger</span><span class="p">{</span><span class="nx">out</span><span class="p">:</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">prefix</span><span class="p">:</span> <span class="nx">prefix</span><span class="p">,</span> <span class="nx">flag</span><span class="p">:</span> <span class="nx">flag</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>log.LstdFlags</code>：日志记录的格式属性之一，其余的选项如下</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">Ldate</span>         <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>     <span class="c1">// the date in the local time zone: 2009/01/23
</span><span class="c1"></span>    <span class="nx">Ltime</span>                         <span class="c1">// the time in the local time zone: 01:23:23
</span><span class="c1"></span>    <span class="nx">Lmicroseconds</span>                 <span class="c1">// microsecond resolution: 01:23:23.123123.  assumes Ltime.
</span><span class="c1"></span>    <span class="nx">Llongfile</span>                     <span class="c1">// full file name and line number: /a/b/c/d.go:23
</span><span class="c1"></span>    <span class="nx">Lshortfile</span>                    <span class="c1">// final file name element and line number: d.go:23. overrides Llongfile
</span><span class="c1"></span>    <span class="nx">LUTC</span>                          <span class="c1">// if Ldate or Ltime is set, use UTC rather than the local time zone
</span><span class="c1"></span>    <span class="nx">LstdFlags</span>     <span class="p">=</span> <span class="nx">Ldate</span> <span class="p">|</span> <span class="nx">Ltime</span> <span class="c1">// initial values for the standard logger
</span><span class="c1"></span><span class="p">)</span>
</code></pre></div><p>当前目录结构：</p>
<pre><code>gin-blog/
├── conf
│   └── app.ini
├── main.go
├── middleware
│   └── jwt
│       └── jwt.go
├── models
│   ├── article.go
│   ├── auth.go
│   ├── models.go
│   └── tag.go
├── pkg
│   ├── e
│   │   ├── code.go
│   │   └── msg.go
│   ├── logging
│   │   ├── file.go
│   │   └── log.go
│   ├── setting
│   │   └── setting.go
│   └── util
│       ├── jwt.go
│       └── pagination.go
├── routers
│   ├── api
│   │   ├── auth.go
│   │   └── v1
│   │       ├── article.go
│   │       └── tag.go
│   └── router.go
├── runtime

</code></pre><p>我们自定义的<code>logging</code>包，已经基本完成了，接下来让它接入到我们的项目之中吧。我们打开先前包含<code>log</code>包的代码，如下：</p>
<ol>
<li>打开<code>routers</code>目录下的<code>article.go</code>、<code>tag.go</code>、<code>auth.go</code>。</li>
<li>将<code>log</code>包的引用删除，修改引用我们自己的日志包为<code>github.com/EDDYCJY/go-gin-example/pkg/logging</code>。</li>
<li>将原本的<code>log.Println(...)</code>改为<code>logging.Info(...)</code>。</li>
</ol>
<p>例如<code>auth.go</code>文件的修改内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">api</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/astaxie/beego/validation&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/e&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/util&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/models&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/logging&#34;</span>
<span class="p">)</span>
<span class="o">...</span>
<span class="kd">func</span> <span class="nf">GetAuth</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">valid</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">{</span>
                <span class="nx">logging</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
            <span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div><h2 id="验证功能">验证功能</h2>
<p>修改文件后，重启服务，我们来试试吧！</p>
<p>获取到 API 的 Token 后，我们故意传错误 URL 参数给接口，如：<code>http://127.0.0.1:8000/api/v1/articles?tag_id=0&amp;state=9999999&amp;token=eyJhbG..</code></p>
<p>然后我们到<code>$GOPATH/gin-blog/runtime/logs</code>查看日志：</p>
<pre><code>$ tail -f log20180216.log
[INFO][article.go:79]2018/02/16 18:33:12 [state 状态只允许0或1]
[INFO][article.go:79]2018/02/16 18:33:42 [state 状态只允许0或1]
[INFO][article.go:79]2018/02/16 18:33:42 [tag_id 标签ID必须大于0]
[INFO][article.go:79]2018/02/16 18:38:39 [state 状态只允许0或1]
[INFO][article.go:79]2018/02/16 18:38:39 [tag_id 标签ID必须大于0]
</code></pre><p>日志结构一切正常，我们的记录模式都为<code>Info</code>，因此前缀是对的，并且我们是入参有问题，也把错误记录下来了，这样排错就很方便了！</p>
<p>至此，本节就完成了，这只是一个简单的扩展，实际上我们线上项目要使用的文件日志，是更复杂一些，开动你的大脑 举一反三吧！</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「连载五」使用 JWT 进行身份校验</title>
			<link>https://eddycjy.com/posts/go/gin/2018-02-14-jwt/</link>
			<pubDate>Wed, 14 Feb 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-02-14-jwt/</guid>
			<description>涉及知识点  JWT  本文目标 在前面几节中，我们已经基本的完成了 API&amp;rsquo;s 的编写，但是，还存在一些非常严重的问题，例如，我们现在的 API 是可以随意调用的，这显然还不安全全，在本文中我们通过 jwt-go （GoDoc）的方式来简单解决这个问题。
下载依赖包 首先，我们下载 jwt-go 的依赖包，如下：
go get -u github.com/dgrijalva/jwt-go 编写 jwt 工具包 我们需要编写一个jwt的工具包，我们在pkg下的util目录新建jwt.go，写入文件内容：
package util import ( &amp;#34;time&amp;#34; jwt &amp;#34;github.com/dgrijalva/jwt-go&amp;#34; &amp;#34;github.com/EDDYCJY/go-gin-example/pkg/setting&amp;#34; ) var jwtSecret = []byte(setting.JwtSecret) type Claims struct { Username string `json:&amp;#34;username&amp;#34;` Password string `json:&amp;#34;password&amp;#34;` jwt.StandardClaims } func GenerateToken(username, password string) (string, error) { nowTime := time.Now() expireTime := nowTime.Add(3 * time.Hour) claims := Claims{ username, password, jwt.StandardClaims { ExpiresAt : expireTime.</description>
			<content type="html"><![CDATA[<h2 id="涉及知识点">涉及知识点</h2>
<ul>
<li>JWT</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<p>在前面几节中，我们已经基本的完成了 API&rsquo;s 的编写，但是，还存在一些非常严重的问题，例如，我们现在的 API 是可以随意调用的，这显然还不安全全，在本文中我们通过 <a href="https://github.com/dgrijalva/jwt-go">jwt-go</a> （<a href="https://godoc.org/github.com/dgrijalva/jwt-go">GoDoc</a>）的方式来简单解决这个问题。</p>
<h2 id="下载依赖包">下载依赖包</h2>
<p>首先，我们下载 jwt-go 的依赖包，如下：</p>
<pre><code>go get -u github.com/dgrijalva/jwt-go
</code></pre><h2 id="编写-jwt-工具包">编写 jwt 工具包</h2>
<p>我们需要编写一个<code>jwt</code>的工具包，我们在<code>pkg</code>下的<code>util</code>目录新建<code>jwt.go</code>，写入文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">util</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;time&#34;</span>

	<span class="nx">jwt</span> <span class="s">&#34;github.com/dgrijalva/jwt-go&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">jwtSecret</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">setting</span><span class="p">.</span><span class="nx">JwtSecret</span><span class="p">)</span>

<span class="kd">type</span> <span class="nx">Claims</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Username</span> <span class="kt">string</span> <span class="s">`json:&#34;username&#34;`</span>
	<span class="nx">Password</span> <span class="kt">string</span> <span class="s">`json:&#34;password&#34;`</span>
	<span class="nx">jwt</span><span class="p">.</span><span class="nx">StandardClaims</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GenerateToken</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">password</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">nowTime</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="nx">expireTime</span> <span class="o">:=</span> <span class="nx">nowTime</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">)</span>

	<span class="nx">claims</span> <span class="o">:=</span> <span class="nx">Claims</span><span class="p">{</span>
		<span class="nx">username</span><span class="p">,</span>
		<span class="nx">password</span><span class="p">,</span>
		<span class="nx">jwt</span><span class="p">.</span><span class="nx">StandardClaims</span> <span class="p">{</span>
			<span class="nx">ExpiresAt</span> <span class="p">:</span> <span class="nx">expireTime</span><span class="p">.</span><span class="nf">Unix</span><span class="p">(),</span>
			<span class="nx">Issuer</span> <span class="p">:</span> <span class="s">&#34;gin-blog&#34;</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">}</span>

	<span class="nx">tokenClaims</span> <span class="o">:=</span> <span class="nx">jwt</span><span class="p">.</span><span class="nf">NewWithClaims</span><span class="p">(</span><span class="nx">jwt</span><span class="p">.</span><span class="nx">SigningMethodHS256</span><span class="p">,</span> <span class="nx">claims</span><span class="p">)</span>
	<span class="nx">token</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tokenClaims</span><span class="p">.</span><span class="nf">SignedString</span><span class="p">(</span><span class="nx">jwtSecret</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">token</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ParseToken</span><span class="p">(</span><span class="nx">token</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Claims</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tokenClaims</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">jwt</span><span class="p">.</span><span class="nf">ParseWithClaims</span><span class="p">(</span><span class="nx">token</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">Claims</span><span class="p">{},</span> <span class="kd">func</span><span class="p">(</span><span class="nx">token</span> <span class="o">*</span><span class="nx">jwt</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">jwtSecret</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">tokenClaims</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">claims</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">tokenClaims</span><span class="p">.</span><span class="nx">Claims</span><span class="p">.(</span><span class="o">*</span><span class="nx">Claims</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">tokenClaims</span><span class="p">.</span><span class="nx">Valid</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">claims</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><p>在这个工具包，我们涉及到</p>
<ul>
<li><code>NewWithClaims(method SigningMethod, claims Claims)</code>，<code>method</code>对应着<code>SigningMethodHMAC struct{}</code>，其包含<code>SigningMethodHS256</code>、<code>SigningMethodHS384</code>、<code>SigningMethodHS512</code>三种<code>crypto.Hash</code>方案</li>
<li><code>func (t *Token) SignedString(key interface{})</code> 该方法内部生成签名字符串，再用于获取完整、已签名的<code>token</code></li>
<li><code>func (p *Parser) ParseWithClaims</code> 用于解析鉴权的声明，<a href="https://gowalker.org/github.com/dgrijalva/jwt-go#Parser_ParseWithClaims">方法内部</a>主要是具体的解码和校验的过程，最终返回<code>*Token</code></li>
<li><code>func (m MapClaims) Valid()</code> 验证基于时间的声明<code>exp, iat, nbf</code>，注意如果没有任何声明在令牌中，仍然会被认为是有效的。并且对于时区偏差没有计算方法</li>
</ul>
<p>有了<code>jwt</code>工具包，接下来我们要编写要用于<code>Gin</code>的中间件，我们在<code>middleware</code>下新建<code>jwt</code>目录，新建<code>jwt.go</code>文件，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">jwt</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;time&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/util&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/e&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">JWT</span><span class="p">()</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">code</span> <span class="kt">int</span>
		<span class="kd">var</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{}</span>

		<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
		<span class="nx">token</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;token&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">token</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">claims</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">ParseToken</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_AUTH_CHECK_TOKEN_FAIL</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">claims</span><span class="p">.</span><span class="nx">ExpiresAt</span> <span class="p">{</span>
				<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_AUTH_CHECK_TOKEN_TIMEOUT</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">code</span> <span class="o">!=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusUnauthorized</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
		        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
		        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
		        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
		    <span class="p">})</span>

		    <span class="nx">c</span><span class="p">.</span><span class="nf">Abort</span><span class="p">()</span>
		    <span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="如何获取token">如何获取<code>Token</code></h2>
<p>那么我们如何调用它呢，我们还要获取<code>Token</code>呢？</p>
<p>1、 我们要新增一个获取<code>Token</code>的 API</p>
<p>在<code>models</code>下新建<code>auth.go</code>文件，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">models</span>

<span class="kd">type</span> <span class="nx">Auth</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span> <span class="kt">int</span> <span class="s">`gorm:&#34;primary_key&#34; json:&#34;id&#34;`</span>
	<span class="nx">Username</span> <span class="kt">string</span> <span class="s">`json:&#34;username&#34;`</span>
	<span class="nx">Password</span> <span class="kt">string</span> <span class="s">`json:&#34;password&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CheckAuth</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">password</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">auth</span> <span class="nx">Auth</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="s">&#34;id&#34;</span><span class="p">).</span><span class="nf">Where</span><span class="p">(</span><span class="nx">Auth</span><span class="p">{</span><span class="nx">Username</span> <span class="p">:</span> <span class="nx">username</span><span class="p">,</span> <span class="nx">Password</span> <span class="p">:</span> <span class="nx">password</span><span class="p">}).</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">auth</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">auth</span><span class="p">.</span><span class="nx">ID</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div><p>在<code>routers</code>下的<code>api</code>目录新建<code>auth.go</code>文件，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">api</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/astaxie/beego/validation&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/e&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/util&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/models&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">auth</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Username</span> <span class="kt">string</span> <span class="s">`valid:&#34;Required; MaxSize(50)&#34;`</span>
	<span class="nx">Password</span> <span class="kt">string</span> <span class="s">`valid:&#34;Required; MaxSize(50)&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetAuth</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">username</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;username&#34;</span><span class="p">)</span>
	<span class="nx">password</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;password&#34;</span><span class="p">)</span>

	<span class="nx">valid</span> <span class="o">:=</span> <span class="nx">validation</span><span class="p">.</span><span class="nx">Validation</span><span class="p">{}</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nx">auth</span><span class="p">{</span><span class="nx">Username</span><span class="p">:</span> <span class="nx">username</span><span class="p">,</span> <span class="nx">Password</span><span class="p">:</span> <span class="nx">password</span><span class="p">}</span>
	<span class="nx">ok</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">Valid</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>

	<span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">isExist</span> <span class="o">:=</span> <span class="nx">models</span><span class="p">.</span><span class="nf">CheckAuth</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">password</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">isExist</span> <span class="p">{</span>
			<span class="nx">token</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">GenerateToken</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">password</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_AUTH_TOKEN</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">data</span><span class="p">[</span><span class="s">&#34;token&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">token</span>

				<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_AUTH</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">valid</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
        <span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>我们打开<code>routers</code>目录下的<code>router.go</code>文件，修改文件内容（新增获取 token 的方法）：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routers</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>

    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/routers/api&#34;</span>
    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/routers/api/v1&#34;</span>
    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

    <span class="nx">r</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nf">Logger</span><span class="p">())</span>

    <span class="nx">r</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nf">Recovery</span><span class="p">())</span>

    <span class="nx">gin</span><span class="p">.</span><span class="nf">SetMode</span><span class="p">(</span><span class="nx">setting</span><span class="p">.</span><span class="nx">RunMode</span><span class="p">)</span>

    <span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/auth&#34;</span><span class="p">,</span> <span class="nx">api</span><span class="p">.</span><span class="nx">GetAuth</span><span class="p">)</span>

    <span class="nx">apiv1</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/api/v1&#34;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></div><h2 id="验证token">验证<code>Token</code></h2>
<p>获取<code>token</code>的 API 方法就到这里啦，让我们来测试下是否可以正常使用吧！</p>
<p>重启服务后，用<code>GET</code>方式访问<code>http://127.0.0.1:8000/auth?username=test&amp;password=test123456</code>，查看返回值是否正确</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;code&#34;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
  <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;token&#34;</span><span class="p">:</span> <span class="s2">&#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QiLCJwYXNzd29yZCI6InRlc3QxMjM0NTYiLCJleHAiOjE1MTg3MjAwMzcsImlzcyI6Imdpbi1ibG9nIn0.-kK0V9E06qTHOzupQM_gHXAGDB3EJtJS4H5TTCyWwW8&#34;</span>
  <span class="p">},</span>
  <span class="nt">&#34;msg&#34;</span><span class="p">:</span> <span class="s2">&#34;ok&#34;</span>
<span class="p">}</span>
</code></pre></div><p>我们有了<code>token</code>的 API，也调用成功了</p>
<h2 id="将中间件接入gin">将中间件接入<code>Gin</code></h2>
<p>2、 接下来我们将中间件接入到<code>Gin</code>的访问流程中</p>
<p>我们打开<code>routers</code>目录下的<code>router.go</code>文件，修改文件内容（新增引用包和中间件引用）</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routers</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>

    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/routers/api&#34;</span>
    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/routers/api/v1&#34;</span>
    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/middleware/jwt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

    <span class="nx">r</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nf">Logger</span><span class="p">())</span>

    <span class="nx">r</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nf">Recovery</span><span class="p">())</span>

    <span class="nx">gin</span><span class="p">.</span><span class="nf">SetMode</span><span class="p">(</span><span class="nx">setting</span><span class="p">.</span><span class="nx">RunMode</span><span class="p">)</span>

    <span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/auth&#34;</span><span class="p">,</span> <span class="nx">api</span><span class="p">.</span><span class="nx">GetAuth</span><span class="p">)</span>

    <span class="nx">apiv1</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/api/v1&#34;</span><span class="p">)</span>
    <span class="nx">apiv1</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">jwt</span><span class="p">.</span><span class="nf">JWT</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></div><p>当前目录结构：</p>
<pre><code>go-gin-example/
├── conf
│   └── app.ini
├── main.go
├── middleware
│   └── jwt
│       └── jwt.go
├── models
│   ├── article.go
│   ├── auth.go
│   ├── models.go
│   └── tag.go
├── pkg
│   ├── e
│   │   ├── code.go
│   │   └── msg.go
│   ├── setting
│   │   └── setting.go
│   └── util
│       ├── jwt.go
│       └── pagination.go
├── routers
│   ├── api
│   │   ├── auth.go
│   │   └── v1
│   │       ├── article.go
│   │       └── tag.go
│   └── router.go
├── runtime
</code></pre><p>到这里，我们的<code>JWT</code>编写就完成啦！</p>
<h2 id="验证功能">验证功能</h2>
<p>我们来测试一下，再次访问</p>
<ul>
<li>http://127.0.0.1:8000/api/v1/articles</li>
<li>http://127.0.0.1:8000/api/v1/articles?token=23131</li>
</ul>
<p>正确的反馈应该是</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;code&#34;</span><span class="p">:</span> <span class="mi">400</span><span class="p">,</span>
  <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nt">&#34;msg&#34;</span><span class="p">:</span> <span class="s2">&#34;请求参数错误&#34;</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="nt">&#34;code&#34;</span><span class="p">:</span> <span class="mi">20001</span><span class="p">,</span>
  <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nt">&#34;msg&#34;</span><span class="p">:</span> <span class="s2">&#34;Token鉴权失败&#34;</span>
<span class="p">}</span>

</code></pre></div><p>我们需要访问<code>http://127.0.0.1:8000/auth?username=test&amp;password=test123456</code>，得到<code>token</code></p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;code&#34;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
  <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;token&#34;</span><span class="p">:</span> <span class="s2">&#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QiLCJwYXNzd29yZCI6InRlc3QxMjM0NTYiLCJleHAiOjE1MTg3MjQ2OTMsImlzcyI6Imdpbi1ibG9nIn0.KSBY6TeavV_30kfmP7HWLRYKP5TPEDgHtABe9HCsic4&#34;</span>
  <span class="p">},</span>
  <span class="nt">&#34;msg&#34;</span><span class="p">:</span> <span class="s2">&#34;ok&#34;</span>
<span class="p">}</span>
</code></pre></div><p>再用包含<code>token</code>的 URL 参数去访问我们的应用 API，</p>
<p>访问<code>http://127.0.0.1:8000/api/v1/articles?token=eyJhbGci...</code>，检查接口返回值</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;code&#34;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
  <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;lists&#34;</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">&#34;created_on&#34;</span><span class="p">:</span> <span class="mi">1518700920</span><span class="p">,</span>
        <span class="nt">&#34;modified_on&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;tag_id&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nt">&#34;tag&#34;</span><span class="p">:</span> <span class="p">{</span>
          <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
          <span class="nt">&#34;created_on&#34;</span><span class="p">:</span> <span class="mi">1518684200</span><span class="p">,</span>
          <span class="nt">&#34;modified_on&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;tag1&#34;</span><span class="p">,</span>
          <span class="nt">&#34;created_by&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
          <span class="nt">&#34;modified_by&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
          <span class="nt">&#34;state&#34;</span><span class="p">:</span> <span class="mi">0</span>
        <span class="p">},</span>
        <span class="nt">&#34;content&#34;</span><span class="p">:</span> <span class="s2">&#34;test-content&#34;</span><span class="p">,</span>
        <span class="nt">&#34;created_by&#34;</span><span class="p">:</span> <span class="s2">&#34;test-created&#34;</span><span class="p">,</span>
        <span class="nt">&#34;modified_by&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;state&#34;</span><span class="p">:</span> <span class="mi">0</span>
      <span class="p">}</span>
    <span class="p">],</span>
    <span class="nt">&#34;total&#34;</span><span class="p">:</span> <span class="mi">1</span>
  <span class="p">},</span>
  <span class="nt">&#34;msg&#34;</span><span class="p">:</span> <span class="s2">&#34;ok&#34;</span>
<span class="p">}</span>
</code></pre></div><p>返回正确，至此我们的<code>jwt-go</code>在<code>Gin</code>中的验证就完成了！</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「连载四」Gin搭建Blog API&#39;s （三）</title>
			<link>https://eddycjy.com/posts/go/gin/2018-02-13-api-03/</link>
			<pubDate>Tue, 13 Feb 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-02-13-api-03/</guid>
			<description>涉及知识点  Gin：Golang 的一个微框架，性能极佳。 beego-validation：本节采用的 beego 的表单验证库，中文文档。 gorm，对开发人员友好的 ORM 框架，英文文档 com，一个小而美的工具包。  本文目标  完成博客的文章类接口定义和编写  定义接口 本节编写文章的逻辑，我们定义一下接口吧！
 获取文章列表：GET(&amp;quot;/articles&amp;rdquo;) 获取指定文章：POST(&amp;quot;/articles/:id&amp;rdquo;) 新建文章：POST(&amp;quot;/articles&amp;rdquo;) 更新指定文章：PUT(&amp;quot;/articles/:id&amp;rdquo;) 删除指定文章：DELETE(&amp;quot;/articles/:id&amp;rdquo;)  编写路由逻辑 在routers的 v1 版本下，新建article.go文件，写入内容：
package v1 import ( &amp;#34;github.com/gin-gonic/gin&amp;#34; ) //获取单个文章 func GetArticle(c *gin.Context) { } //获取多个文章 func GetArticles(c *gin.Context) { } //新增文章 func AddArticle(c *gin.Context) { } //修改文章 func EditArticle(c *gin.Context) { } //删除文章 func DeleteArticle(c *gin.Context) { } 我们打开routers下的router.go文件，修改文件内容为：
package routers import ( &amp;#34;github.</description>
			<content type="html"><![CDATA[<h2 id="涉及知识点">涉及知识点</h2>
<ul>
<li><a href="https://github.com/gin-gonic/gin">Gin</a>：Golang 的一个微框架，性能极佳。</li>
<li><a href="https://github.com/astaxie/beego/tree/master/validation">beego-validation</a>：本节采用的 beego 的表单验证库，<a href="https://beego.me/docs/mvc/controller/validation.md">中文文档</a>。</li>
<li><a href="https://github.com/jinzhu/gorm">gorm</a>，对开发人员友好的 ORM 框架，<a href="http://gorm.io/docs/">英文文档</a></li>
<li><a href="https://github.com/Unknwon/com">com</a>，一个小而美的工具包。</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<ul>
<li>完成博客的文章类接口定义和编写</li>
</ul>
<h2 id="定义接口">定义接口</h2>
<p>本节编写文章的逻辑，我们定义一下接口吧！</p>
<ul>
<li>获取文章列表：GET(&quot;/articles&rdquo;)</li>
<li>获取指定文章：POST(&quot;/articles/:id&rdquo;)</li>
<li>新建文章：POST(&quot;/articles&rdquo;)</li>
<li>更新指定文章：PUT(&quot;/articles/:id&rdquo;)</li>
<li>删除指定文章：DELETE(&quot;/articles/:id&rdquo;)</li>
</ul>
<h2 id="编写路由逻辑">编写路由逻辑</h2>
<p>在<code>routers</code>的 v1 版本下，新建<code>article.go</code>文件，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">v1</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
<span class="p">)</span>

<span class="c1">//获取单个文章
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetArticle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">//获取多个文章
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetArticles</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">//新增文章
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddArticle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">//修改文章
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">EditArticle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">//删除文章
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DeleteArticle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div><p>我们打开<code>routers</code>下的<code>router.go</code>文件，修改文件内容为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routers</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>

    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/routers/api/v1&#34;</span>
    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">apiv1</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/api/v1&#34;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">...</span>
        <span class="c1">//获取文章列表
</span><span class="c1"></span>        <span class="nx">apiv1</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/articles&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">GetArticles</span><span class="p">)</span>
        <span class="c1">//获取指定文章
</span><span class="c1"></span>        <span class="nx">apiv1</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/articles/:id&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">GetArticle</span><span class="p">)</span>
        <span class="c1">//新建文章
</span><span class="c1"></span>        <span class="nx">apiv1</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/articles&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">AddArticle</span><span class="p">)</span>
        <span class="c1">//更新指定文章
</span><span class="c1"></span>        <span class="nx">apiv1</span><span class="p">.</span><span class="nf">PUT</span><span class="p">(</span><span class="s">&#34;/articles/:id&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">EditArticle</span><span class="p">)</span>
        <span class="c1">//删除指定文章
</span><span class="c1"></span>        <span class="nx">apiv1</span><span class="p">.</span><span class="nf">DELETE</span><span class="p">(</span><span class="s">&#34;/articles/:id&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">DeleteArticle</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></div><p>当前目录结构：</p>
<pre><code>go-gin-example/
├── conf
│   └── app.ini
├── main.go
├── middleware
├── models
│   ├── models.go
│   └── tag.go
├── pkg
│   ├── e
│   │   ├── code.go
│   │   └── msg.go
│   ├── setting
│   │   └── setting.go
│   └── util
│       └── pagination.go
├── routers
│   ├── api
│   │   └── v1
│   │       ├── article.go
│   │       └── tag.go
│   └── router.go
├── runtime

</code></pre><p>在基础的路由规则配置结束后，我们<strong>开始编写我们的接口</strong>吧！</p>
<hr>
<p>##编写 models 逻辑
创建<code>models</code>目录下的<code>article.go</code>，写入文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">models</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/jinzhu/gorm&#34;</span>

    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Article</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Model</span>

    <span class="nx">TagID</span> <span class="kt">int</span> <span class="s">`json:&#34;tag_id&#34; gorm:&#34;index&#34;`</span>
    <span class="nx">Tag</span>   <span class="nx">Tag</span> <span class="s">`json:&#34;tag&#34;`</span>

    <span class="nx">Title</span> <span class="kt">string</span> <span class="s">`json:&#34;title&#34;`</span>
    <span class="nx">Desc</span> <span class="kt">string</span> <span class="s">`json:&#34;desc&#34;`</span>
    <span class="nx">Content</span> <span class="kt">string</span> <span class="s">`json:&#34;content&#34;`</span>
    <span class="nx">CreatedBy</span> <span class="kt">string</span> <span class="s">`json:&#34;created_by&#34;`</span>
    <span class="nx">ModifiedBy</span> <span class="kt">string</span> <span class="s">`json:&#34;modified_by&#34;`</span>
    <span class="nx">State</span> <span class="kt">int</span> <span class="s">`json:&#34;state&#34;`</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="p">(</span><span class="nx">article</span> <span class="o">*</span><span class="nx">Article</span><span class="p">)</span> <span class="nf">BeforeCreate</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">scope</span><span class="p">.</span><span class="nf">SetColumn</span><span class="p">(</span><span class="s">&#34;CreatedOn&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">article</span> <span class="o">*</span><span class="nx">Article</span><span class="p">)</span> <span class="nf">BeforeUpdate</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">scope</span><span class="p">.</span><span class="nf">SetColumn</span><span class="p">(</span><span class="s">&#34;ModifiedOn&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>我们创建了一个<code>Article struct {}</code>，与<code>Tag</code>不同的是，<code>Article</code>多了几项，如下：</p>
<ol>
<li><code>gorm:index</code>，用于声明这个字段为索引，如果你使用了自动迁移功能则会有所影响，在不使用则无影响</li>
<li><code>Tag</code>字段，实际是一个嵌套的<code>struct</code>，它利用<code>TagID</code>与<code>Tag</code>模型相互关联，在执行查询的时候，能够达到<code>Article</code>、<code>Tag</code>关联查询的功能</li>
<li><code>time.Now().Unix()</code> 返回当前的时间戳</li>
</ol>
<p>接下来，请确保已对上一章节的内容通读且了解，由于逻辑偏差不会太远，我们本节直接编写这五个接口</p>
<hr>
<p>打开<code>models</code>目录下的<code>article.go</code>，修改文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">models</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;time&#34;</span>

    <span class="s">&#34;github.com/jinzhu/gorm&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Article</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Model</span>

    <span class="nx">TagID</span> <span class="kt">int</span> <span class="s">`json:&#34;tag_id&#34; gorm:&#34;index&#34;`</span>
    <span class="nx">Tag</span>   <span class="nx">Tag</span> <span class="s">`json:&#34;tag&#34;`</span>

    <span class="nx">Title</span> <span class="kt">string</span> <span class="s">`json:&#34;title&#34;`</span>
    <span class="nx">Desc</span> <span class="kt">string</span> <span class="s">`json:&#34;desc&#34;`</span>
    <span class="nx">Content</span> <span class="kt">string</span> <span class="s">`json:&#34;content&#34;`</span>
    <span class="nx">CreatedBy</span> <span class="kt">string</span> <span class="s">`json:&#34;created_by&#34;`</span>
    <span class="nx">ModifiedBy</span> <span class="kt">string</span> <span class="s">`json:&#34;modified_by&#34;`</span>
    <span class="nx">State</span> <span class="kt">int</span> <span class="s">`json:&#34;state&#34;`</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">ExistArticleByID</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">article</span> <span class="nx">Article</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="s">&#34;id&#34;</span><span class="p">).</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">article</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">article</span><span class="p">.</span><span class="nx">ID</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetArticleTotal</span><span class="p">(</span><span class="nx">maps</span> <span class="kd">interface</span> <span class="p">{})</span> <span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">){</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Article</span><span class="p">{}).</span><span class="nf">Where</span><span class="p">(</span><span class="nx">maps</span><span class="p">).</span><span class="nf">Count</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">count</span><span class="p">)</span>

    <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetArticles</span><span class="p">(</span><span class="nx">pageNum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">pageSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">maps</span> <span class="kd">interface</span> <span class="p">{})</span> <span class="p">(</span><span class="nx">articles</span> <span class="p">[]</span><span class="nx">Article</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Preload</span><span class="p">(</span><span class="s">&#34;Tag&#34;</span><span class="p">).</span><span class="nf">Where</span><span class="p">(</span><span class="nx">maps</span><span class="p">).</span><span class="nf">Offset</span><span class="p">(</span><span class="nx">pageNum</span><span class="p">).</span><span class="nf">Limit</span><span class="p">(</span><span class="nx">pageSize</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">articles</span><span class="p">)</span>

    <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetArticle</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">article</span> <span class="nx">Article</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">article</span><span class="p">)</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">article</span><span class="p">).</span><span class="nf">Related</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">article</span><span class="p">.</span><span class="nx">Tag</span><span class="p">)</span>

    <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">EditArticle</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span> <span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Article</span><span class="p">{}).</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">Updates</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">AddArticle</span><span class="p">(</span><span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span> <span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Article</span> <span class="p">{</span>
        <span class="nx">TagID</span> <span class="p">:</span> <span class="nx">data</span><span class="p">[</span><span class="s">&#34;tag_id&#34;</span><span class="p">].(</span><span class="kt">int</span><span class="p">),</span>
        <span class="nx">Title</span> <span class="p">:</span> <span class="nx">data</span><span class="p">[</span><span class="s">&#34;title&#34;</span><span class="p">].(</span><span class="kt">string</span><span class="p">),</span>
        <span class="nx">Desc</span> <span class="p">:</span> <span class="nx">data</span><span class="p">[</span><span class="s">&#34;desc&#34;</span><span class="p">].(</span><span class="kt">string</span><span class="p">),</span>
        <span class="nx">Content</span> <span class="p">:</span> <span class="nx">data</span><span class="p">[</span><span class="s">&#34;content&#34;</span><span class="p">].(</span><span class="kt">string</span><span class="p">),</span>
        <span class="nx">CreatedBy</span> <span class="p">:</span> <span class="nx">data</span><span class="p">[</span><span class="s">&#34;created_by&#34;</span><span class="p">].(</span><span class="kt">string</span><span class="p">),</span>
        <span class="nx">State</span> <span class="p">:</span> <span class="nx">data</span><span class="p">[</span><span class="s">&#34;state&#34;</span><span class="p">].(</span><span class="kt">int</span><span class="p">),</span>
    <span class="p">})</span>

    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">DeleteArticle</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">Article</span><span class="p">{})</span>

    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">article</span> <span class="o">*</span><span class="nx">Article</span><span class="p">)</span> <span class="nf">BeforeCreate</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">scope</span><span class="p">.</span><span class="nf">SetColumn</span><span class="p">(</span><span class="s">&#34;CreatedOn&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">article</span> <span class="o">*</span><span class="nx">Article</span><span class="p">)</span> <span class="nf">BeforeUpdate</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">scope</span><span class="p">.</span><span class="nf">SetColumn</span><span class="p">(</span><span class="s">&#34;ModifiedOn&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>在这里，我们拿出三点不同来讲，如下：</p>
<p><strong>1、 我们的<code>Article</code>是如何关联到<code>Tag</code>？</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetArticle</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">article</span> <span class="nx">Article</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">article</span><span class="p">)</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">article</span><span class="p">).</span><span class="nf">Related</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">article</span><span class="p">.</span><span class="nx">Tag</span><span class="p">)</span>

    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>能够达到关联，首先是<code>gorm</code>本身做了大量的约定俗成</p>
<ul>
<li><code>Article</code>有一个结构体成员是<code>TagID</code>，就是外键。<code>gorm</code>会通过类名+ID 的方式去找到这两个类之间的关联关系</li>
<li><code>Article</code>有一个结构体成员是<code>Tag</code>，就是我们嵌套在<code>Article</code>里的<code>Tag</code>结构体，我们可以通过<code>Related</code>进行关联查询</li>
</ul>
<p><strong>2、 <code>Preload</code>是什么东西，为什么查询可以得出每一项的关联<code>Tag</code>？</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetArticles</span><span class="p">(</span><span class="nx">pageNum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">pageSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">maps</span> <span class="kd">interface</span> <span class="p">{})</span> <span class="p">(</span><span class="nx">articles</span> <span class="p">[]</span><span class="nx">Article</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Preload</span><span class="p">(</span><span class="s">&#34;Tag&#34;</span><span class="p">).</span><span class="nf">Where</span><span class="p">(</span><span class="nx">maps</span><span class="p">).</span><span class="nf">Offset</span><span class="p">(</span><span class="nx">pageNum</span><span class="p">).</span><span class="nf">Limit</span><span class="p">(</span><span class="nx">pageSize</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">articles</span><span class="p">)</span>

    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p><code>Preload</code>就是一个预加载器，它会执行两条 SQL，分别是<code>SELECT * FROM blog_articles;</code>和<code>SELECT * FROM blog_tag WHERE id IN (1,2,3,4);</code>，那么在查询出结构后，<code>gorm</code>内部处理对应的映射逻辑，将其填充到<code>Article</code>的<code>Tag</code>中，会特别方便，并且避免了循环查询</p>
<p>那么有没有别的办法呢，大致是两种</p>
<ul>
<li><code>gorm</code>的<code>Join</code></li>
<li>循环<code>Related</code></li>
</ul>
<p>综合之下，还是<code>Preload</code>更好，如果你有更优的方案，欢迎说一下 :)</p>
<p><strong>3、 <code>v.(I)</code> 是什么？</strong></p>
<p><code>v</code>表示一个接口值，<code>I</code>表示接口类型。这个实际就是 Golang 中的<strong>类型断言</strong>，用于判断一个接口值的实际类型是否为某个类型，或一个非接口值的类型是否实现了某个接口类型</p>
<hr>
<p>打开<code>routers</code>目录下 v1 版本的<code>article.go</code>文件，修改文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">v1</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;net/http&#34;</span>
    <span class="s">&#34;log&#34;</span>

    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
    <span class="s">&#34;github.com/astaxie/beego/validation&#34;</span>
    <span class="s">&#34;github.com/unknwon/com&#34;</span>

    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/models&#34;</span>
    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/e&#34;</span>
    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/util&#34;</span>
<span class="p">)</span>

<span class="c1">//获取单个文章
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetArticle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">id</span> <span class="o">:=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;id&#34;</span><span class="p">)).</span><span class="nf">MustInt</span><span class="p">()</span>

    <span class="nx">valid</span> <span class="o">:=</span> <span class="nx">validation</span><span class="p">.</span><span class="nx">Validation</span><span class="p">{}</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;id&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;ID必须大于0&#34;</span><span class="p">)</span>

    <span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="kd">interface</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="p">!</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">HasErrors</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">models</span><span class="p">.</span><span class="nf">ExistArticleByID</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">data</span> <span class="p">=</span> <span class="nx">models</span><span class="p">.</span><span class="nf">GetArticle</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
            <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_NOT_EXIST_ARTICLE</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">valid</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;err.key: %s, err.message: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">//获取多个文章
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetArticles</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nx">maps</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nx">valid</span> <span class="o">:=</span> <span class="nx">validation</span><span class="p">.</span><span class="nx">Validation</span><span class="p">{}</span>

    <span class="kd">var</span> <span class="nx">state</span> <span class="kt">int</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;state&#34;</span><span class="p">);</span> <span class="nx">arg</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">state</span> <span class="p">=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">arg</span><span class="p">).</span><span class="nf">MustInt</span><span class="p">()</span>
        <span class="nx">maps</span><span class="p">[</span><span class="s">&#34;state&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">state</span>

        <span class="nx">valid</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;state&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;状态只允许0或1&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">tagId</span> <span class="kt">int</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;tag_id&#34;</span><span class="p">);</span> <span class="nx">arg</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">tagId</span> <span class="p">=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">arg</span><span class="p">).</span><span class="nf">MustInt</span><span class="p">()</span>
        <span class="nx">maps</span><span class="p">[</span><span class="s">&#34;tag_id&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tagId</span>

        <span class="nx">valid</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nx">tagId</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;tag_id&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;标签ID必须大于0&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
    <span class="k">if</span> <span class="p">!</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">HasErrors</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>

        <span class="nx">data</span><span class="p">[</span><span class="s">&#34;lists&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">models</span><span class="p">.</span><span class="nf">GetArticles</span><span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nf">GetPage</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">PageSize</span><span class="p">,</span> <span class="nx">maps</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="s">&#34;total&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">models</span><span class="p">.</span><span class="nf">GetArticleTotal</span><span class="p">(</span><span class="nx">maps</span><span class="p">)</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">valid</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;err.key: %s, err.message: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">//新增文章
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddArticle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">tagId</span> <span class="o">:=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;tag_id&#34;</span><span class="p">)).</span><span class="nf">MustInt</span><span class="p">()</span>
    <span class="nx">title</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;title&#34;</span><span class="p">)</span>
    <span class="nx">desc</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;desc&#34;</span><span class="p">)</span>
    <span class="nx">content</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;content&#34;</span><span class="p">)</span>
    <span class="nx">createdBy</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;created_by&#34;</span><span class="p">)</span>
    <span class="nx">state</span> <span class="o">:=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">DefaultQuery</span><span class="p">(</span><span class="s">&#34;state&#34;</span><span class="p">,</span> <span class="s">&#34;0&#34;</span><span class="p">)).</span><span class="nf">MustInt</span><span class="p">()</span>

    <span class="nx">valid</span> <span class="o">:=</span> <span class="nx">validation</span><span class="p">.</span><span class="nx">Validation</span><span class="p">{}</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nx">tagId</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;tag_id&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;标签ID必须大于0&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Required</span><span class="p">(</span><span class="nx">title</span><span class="p">,</span> <span class="s">&#34;title&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;标题不能为空&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Required</span><span class="p">(</span><span class="nx">desc</span><span class="p">,</span> <span class="s">&#34;desc&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;简述不能为空&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Required</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="s">&#34;content&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;内容不能为空&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Required</span><span class="p">(</span><span class="nx">createdBy</span><span class="p">,</span> <span class="s">&#34;created_by&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;创建人不能为空&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;state&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;状态只允许0或1&#34;</span><span class="p">)</span>

    <span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
    <span class="k">if</span> <span class="p">!</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">HasErrors</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">models</span><span class="p">.</span><span class="nf">ExistTagByID</span><span class="p">(</span><span class="nx">tagId</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span> <span class="p">{})</span>
            <span class="nx">data</span><span class="p">[</span><span class="s">&#34;tag_id&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tagId</span>
            <span class="nx">data</span><span class="p">[</span><span class="s">&#34;title&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">title</span>
            <span class="nx">data</span><span class="p">[</span><span class="s">&#34;desc&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">desc</span>
            <span class="nx">data</span><span class="p">[</span><span class="s">&#34;content&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">content</span>
            <span class="nx">data</span><span class="p">[</span><span class="s">&#34;created_by&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">createdBy</span>
            <span class="nx">data</span><span class="p">[</span><span class="s">&#34;state&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">state</span>

            <span class="nx">models</span><span class="p">.</span><span class="nf">AddArticle</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
            <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_NOT_EXIST_TAG</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">valid</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;err.key: %s, err.message: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}),</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">//修改文章
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">EditArticle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">valid</span> <span class="o">:=</span> <span class="nx">validation</span><span class="p">.</span><span class="nx">Validation</span><span class="p">{}</span>

    <span class="nx">id</span> <span class="o">:=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;id&#34;</span><span class="p">)).</span><span class="nf">MustInt</span><span class="p">()</span>
    <span class="nx">tagId</span> <span class="o">:=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;tag_id&#34;</span><span class="p">)).</span><span class="nf">MustInt</span><span class="p">()</span>
    <span class="nx">title</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;title&#34;</span><span class="p">)</span>
    <span class="nx">desc</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;desc&#34;</span><span class="p">)</span>
    <span class="nx">content</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;content&#34;</span><span class="p">)</span>
    <span class="nx">modifiedBy</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;modified_by&#34;</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nx">state</span> <span class="kt">int</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;state&#34;</span><span class="p">);</span> <span class="nx">arg</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">state</span> <span class="p">=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">arg</span><span class="p">).</span><span class="nf">MustInt</span><span class="p">()</span>
        <span class="nx">valid</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;state&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;状态只允许0或1&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">valid</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;id&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;ID必须大于0&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">MaxSize</span><span class="p">(</span><span class="nx">title</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s">&#34;title&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;标题最长为100字符&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">MaxSize</span><span class="p">(</span><span class="nx">desc</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="s">&#34;desc&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;简述最长为255字符&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">MaxSize</span><span class="p">(</span><span class="nx">content</span><span class="p">,</span> <span class="mi">65535</span><span class="p">,</span> <span class="s">&#34;content&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;内容最长为65535字符&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Required</span><span class="p">(</span><span class="nx">modifiedBy</span><span class="p">,</span> <span class="s">&#34;modified_by&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;修改人不能为空&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">MaxSize</span><span class="p">(</span><span class="nx">modifiedBy</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s">&#34;modified_by&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;修改人最长为100字符&#34;</span><span class="p">)</span>

    <span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
    <span class="k">if</span> <span class="p">!</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">HasErrors</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">models</span><span class="p">.</span><span class="nf">ExistArticleByID</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">models</span><span class="p">.</span><span class="nf">ExistTagByID</span><span class="p">(</span><span class="nx">tagId</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span> <span class="p">{})</span>
                <span class="k">if</span> <span class="nx">tagId</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="nx">data</span><span class="p">[</span><span class="s">&#34;tag_id&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tagId</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="nx">title</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
                    <span class="nx">data</span><span class="p">[</span><span class="s">&#34;title&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">title</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="nx">desc</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
                    <span class="nx">data</span><span class="p">[</span><span class="s">&#34;desc&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">desc</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="nx">content</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
                    <span class="nx">data</span><span class="p">[</span><span class="s">&#34;content&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">content</span>
                <span class="p">}</span>

                <span class="nx">data</span><span class="p">[</span><span class="s">&#34;modified_by&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">modifiedBy</span>

                <span class="nx">models</span><span class="p">.</span><span class="nf">EditArticle</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
                <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_NOT_EXIST_TAG</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_NOT_EXIST_ARTICLE</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">valid</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;err.key: %s, err.message: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">//删除文章
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DeleteArticle</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">id</span> <span class="o">:=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;id&#34;</span><span class="p">)).</span><span class="nf">MustInt</span><span class="p">()</span>

    <span class="nx">valid</span> <span class="o">:=</span> <span class="nx">validation</span><span class="p">.</span><span class="nx">Validation</span><span class="p">{}</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;id&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;ID必须大于0&#34;</span><span class="p">)</span>

    <span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
    <span class="k">if</span> <span class="p">!</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">HasErrors</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">models</span><span class="p">.</span><span class="nf">ExistArticleByID</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">models</span><span class="p">.</span><span class="nf">DeleteArticle</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
            <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_NOT_EXIST_ARTICLE</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">valid</span><span class="p">.</span><span class="nx">Errors</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;err.key: %s, err.message: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>当前目录结构：</p>
<pre><code>go-gin-example/
├── conf
│   └── app.ini
├── main.go
├── middleware
├── models
│   ├── article.go
│   ├── models.go
│   └── tag.go
├── pkg
│   ├── e
│   │   ├── code.go
│   │   └── msg.go
│   ├── setting
│   │   └── setting.go
│   └── util
│       └── pagination.go
├── routers
│   ├── api
│   │   └── v1
│   │       ├── article.go
│   │       └── tag.go
│   └── router.go
├── runtime
</code></pre><h2 id="验证功能">验证功能</h2>
<p>我们重启服务，执行<code>go run main.go</code>，检查控制台输出结果</p>
<pre><code>$ go run main.go
[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /api/v1/tags              --&gt; gin-blog/routers/api/v1.GetTags (3 handlers)
[GIN-debug] POST   /api/v1/tags              --&gt; gin-blog/routers/api/v1.AddTag (3 handlers)
[GIN-debug] PUT    /api/v1/tags/:id          --&gt; gin-blog/routers/api/v1.EditTag (3 handlers)
[GIN-debug] DELETE /api/v1/tags/:id          --&gt; gin-blog/routers/api/v1.DeleteTag (3 handlers)
[GIN-debug] GET    /api/v1/articles          --&gt; gin-blog/routers/api/v1.GetArticles (3 handlers)
[GIN-debug] GET    /api/v1/articles/:id      --&gt; gin-blog/routers/api/v1.GetArticle (3 handlers)
[GIN-debug] POST   /api/v1/articles          --&gt; gin-blog/routers/api/v1.AddArticle (3 handlers)
[GIN-debug] PUT    /api/v1/articles/:id      --&gt; gin-blog/routers/api/v1.EditArticle (3 handlers)
[GIN-debug] DELETE /api/v1/articles/:id      --&gt; gin-blog/routers/api/v1.DeleteArticle (3 handlers)
</code></pre><p>使用<code>Postman</code>检验接口是否正常，在这里大家可以选用合适的参数传递方式，此处为了方便展示我选用了 GET/Param 传参的方式，而后期会改为 POST。</p>
<ul>
<li>POST：http://127.0.0.1:8000/api/v1/articles?tag_id=1&amp;title=test1&amp;desc=test-desc&amp;content=test-content&amp;created_by=test-created&amp;state=1</li>
<li>GET：http://127.0.0.1:8000/api/v1/articles</li>
<li>GET：http://127.0.0.1:8000/api/v1/articles/1</li>
<li>PUT：http://127.0.0.1:8000/api/v1/articles/1?tag_id=1&amp;title=test-edit1&amp;desc=test-desc-edit&amp;content=test-content-edit&amp;modified_by=test-created-edit&amp;state=0</li>
<li>DELETE：http://127.0.0.1:8000/api/v1/articles/1</li>
</ul>
<p>至此，我们的 API&rsquo;s 编写就到这里，下一节我们将介绍另外的一些技巧！</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「连载三」Gin搭建Blog API&#39;s （二）</title>
			<link>https://eddycjy.com/posts/go/gin/2018-02-12-api-02/</link>
			<pubDate>Mon, 12 Feb 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-02-12-api-02/</guid>
			<description>涉及知识点  Gin：Golang 的一个微框架，性能极佳。 beego-validation：本节采用的 beego 的表单验证库，中文文档。 gorm，对开发人员友好的 ORM 框架，英文文档 com，一个小而美的工具包。  本文目标  完成博客的标签类接口定义和编写  定义接口 本节正是编写标签的逻辑，我们想一想，一般接口为增删改查是基础的，那么我们定义一下接口吧！
 获取标签列表：GET(&amp;quot;/tags&amp;rdquo;) 新建标签：POST(&amp;quot;/tags&amp;rdquo;) 更新指定标签：PUT(&amp;quot;/tags/:id&amp;rdquo;) 删除指定标签：DELETE(&amp;quot;/tags/:id&amp;rdquo;)   编写路由空壳 开始编写路由文件逻辑，在routers下新建api目录，我们当前是第一个 API 大版本，因此在api下新建v1目录，再新建tag.go文件，写入内容：
package v1 import ( &amp;#34;github.com/gin-gonic/gin&amp;#34; ) //获取多个文章标签 func GetTags(c *gin.Context) { } //新增文章标签 func AddTag(c *gin.Context) { } //修改文章标签 func EditTag(c *gin.Context) { } //删除文章标签 func DeleteTag(c *gin.Context) { } 注册路由 我们打开routers下的router.go文件，修改文件内容为：
package routers import ( &amp;#34;github.com/gin-gonic/gin&amp;#34; &amp;#34;gin-blog/routers/api/v1&amp;#34; &amp;#34;gin-blog/pkg/setting&amp;#34; ) func InitRouter() *gin.</description>
			<content type="html"><![CDATA[<h2 id="涉及知识点">涉及知识点</h2>
<ul>
<li><a href="https://github.com/gin-gonic/gin">Gin</a>：Golang 的一个微框架，性能极佳。</li>
<li><a href="https://github.com/astaxie/beego/tree/master/validation">beego-validation</a>：本节采用的 beego 的表单验证库，<a href="https://beego.me/docs/mvc/controller/validation.md">中文文档</a>。</li>
<li><a href="https://github.com/jinzhu/gorm">gorm</a>，对开发人员友好的 ORM 框架，<a href="http://gorm.io/docs/">英文文档</a></li>
<li><a href="https://github.com/Unknwon/com">com</a>，一个小而美的工具包。</li>
</ul>
<h2 id="本文目标">本文目标</h2>
<ul>
<li>完成博客的标签类接口定义和编写</li>
</ul>
<h2 id="定义接口">定义接口</h2>
<p>本节正是编写标签的逻辑，我们想一想，一般接口为增删改查是基础的，那么我们定义一下接口吧！</p>
<ul>
<li>获取标签列表：GET(&quot;/tags&rdquo;)</li>
<li>新建标签：POST(&quot;/tags&rdquo;)</li>
<li>更新指定标签：PUT(&quot;/tags/:id&rdquo;)</li>
<li>删除指定标签：DELETE(&quot;/tags/:id&rdquo;)</li>
</ul>
<hr>
<h2 id="编写路由空壳">编写路由空壳</h2>
<p>开始编写路由文件逻辑，在<code>routers</code>下新建<code>api</code>目录，我们当前是第一个 API 大版本，因此在<code>api</code>下新建<code>v1</code>目录，再新建<code>tag.go</code>文件，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">v1</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
<span class="p">)</span>

<span class="c1">//获取多个文章标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetTags</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">//新增文章标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">//修改文章标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">EditTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">//删除文章标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DeleteTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div><h2 id="注册路由">注册路由</h2>
<p>我们打开<code>routers</code>下的<code>router.go</code>文件，修改文件内容为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routers</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>

    <span class="s">&#34;gin-blog/routers/api/v1&#34;</span>
    <span class="s">&#34;gin-blog/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

    <span class="nx">r</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nf">Logger</span><span class="p">())</span>

    <span class="nx">r</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nf">Recovery</span><span class="p">())</span>

    <span class="nx">gin</span><span class="p">.</span><span class="nf">SetMode</span><span class="p">(</span><span class="nx">setting</span><span class="p">.</span><span class="nx">RunMode</span><span class="p">)</span>

    <span class="nx">apiv1</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/api/v1&#34;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//获取标签列表
</span><span class="c1"></span>        <span class="nx">apiv1</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/tags&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">GetTags</span><span class="p">)</span>
        <span class="c1">//新建标签
</span><span class="c1"></span>        <span class="nx">apiv1</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/tags&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">AddTag</span><span class="p">)</span>
        <span class="c1">//更新指定标签
</span><span class="c1"></span>        <span class="nx">apiv1</span><span class="p">.</span><span class="nf">PUT</span><span class="p">(</span><span class="s">&#34;/tags/:id&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">EditTag</span><span class="p">)</span>
        <span class="c1">//删除指定标签
</span><span class="c1"></span>        <span class="nx">apiv1</span><span class="p">.</span><span class="nf">DELETE</span><span class="p">(</span><span class="s">&#34;/tags/:id&#34;</span><span class="p">,</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">DeleteTag</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></div><p>当前目录结构：</p>
<pre><code>gin-blog/
├── conf
│   └── app.ini
├── main.go
├── middleware
├── models
│   └── models.go
├── pkg
│   ├── e
│   │   ├── code.go
│   │   └── msg.go
│   ├── setting
│   │   └── setting.go
│   └── util
│       └── pagination.go
├── routers
│   ├── api
│   │   └── v1
│   │       └── tag.go
│   └── router.go
├── runtime
</code></pre><h2 id="检验路由是否注册成功">检验路由是否注册成功</h2>
<p>回到命令行，执行<code>go run main.go</code>，检查路由规则是否注册成功。</p>
<pre><code>$ go run main.go
[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.
 - using env:   export GIN_MODE=release
 - using code:  gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /api/v1/tags              --&gt; gin-blog/routers/api/v1.GetTags (3 handlers)
[GIN-debug] POST   /api/v1/tags              --&gt; gin-blog/routers/api/v1.AddTag (3 handlers)
[GIN-debug] PUT    /api/v1/tags/:id          --&gt; gin-blog/routers/api/v1.EditTag (3 handlers)
[GIN-debug] DELETE /api/v1/tags/:id          --&gt; gin-blog/routers/api/v1.DeleteTag (3 handlers)
</code></pre><p>运行成功，那么我们愉快的<strong>开始编写我们的接口</strong>吧！</p>
<h2 id="下载依赖包">下载依赖包</h2>
<hr>
<p>首先我们要拉取<code>validation</code>的依赖包，在后面的接口里会使用到表单验证</p>
<pre><code>$ go get -u github.com/astaxie/beego/validation
</code></pre><h2 id="编写标签列表的-models-逻辑">编写标签列表的 models 逻辑</h2>
<p>创建<code>models</code>目录下的<code>tag.go</code>，写入文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">models</span>

<span class="kd">type</span> <span class="nx">Tag</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Model</span>

    <span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
    <span class="nx">CreatedBy</span> <span class="kt">string</span> <span class="s">`json:&#34;created_by&#34;`</span>
    <span class="nx">ModifiedBy</span> <span class="kt">string</span> <span class="s">`json:&#34;modified_by&#34;`</span>
    <span class="nx">State</span> <span class="kt">int</span> <span class="s">`json:&#34;state&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetTags</span><span class="p">(</span><span class="nx">pageNum</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">pageSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">maps</span> <span class="kd">interface</span> <span class="p">{})</span> <span class="p">(</span><span class="nx">tags</span> <span class="p">[]</span><span class="nx">Tag</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="nx">maps</span><span class="p">).</span><span class="nf">Offset</span><span class="p">(</span><span class="nx">pageNum</span><span class="p">).</span><span class="nf">Limit</span><span class="p">(</span><span class="nx">pageSize</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tags</span><span class="p">)</span>

    <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetTagTotal</span><span class="p">(</span><span class="nx">maps</span> <span class="kd">interface</span> <span class="p">{})</span> <span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">){</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Tag</span><span class="p">{}).</span><span class="nf">Where</span><span class="p">(</span><span class="nx">maps</span><span class="p">).</span><span class="nf">Count</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">count</span><span class="p">)</span>

    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div><ol>
<li>
<p>我们创建了一个<code>Tag struct{}</code>，用于<code>Gorm</code>的使用。并给予了附属属性<code>json</code>，这样子在<code>c.JSON</code>的时候就会自动转换格式，非常的便利</p>
</li>
<li>
<p>可能会有的初学者看到<code>return</code>，而后面没有跟着变量，会不理解；其实你可以看到在函数末端，我们已经显示声明了返回值，这个变量在函数体内也可以直接使用，因为他在一开始就被声明了</p>
</li>
<li>
<p>有人会疑惑<code>db</code>是哪里来的；因为在同个<code>models</code>包下，因此<code>db *gorm.DB</code>是可以直接使用的</p>
</li>
</ol>
<h2 id="编写标签列表的路由逻辑">编写标签列表的路由逻辑</h2>
<p>打开<code>routers</code>目录下 v1 版本的<code>tag.go</code>，第一我们先编写<strong>获取标签列表的接口</strong></p>
<p>修改文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">v1</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;net/http&#34;</span>

    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
    <span class="c1">//&#34;github.com/astaxie/beego/validation&#34;
</span><span class="c1"></span>    <span class="s">&#34;github.com/Unknwon/com&#34;</span>

    <span class="s">&#34;gin-blog/pkg/e&#34;</span>
    <span class="s">&#34;gin-blog/models&#34;</span>
    <span class="s">&#34;gin-blog/pkg/util&#34;</span>
    <span class="s">&#34;gin-blog/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="c1">//获取多个文章标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetTags</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span>

    <span class="nx">maps</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>

    <span class="k">if</span> <span class="nx">name</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">maps</span><span class="p">[</span><span class="s">&#34;name&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">name</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">state</span> <span class="kt">int</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;state&#34;</span><span class="p">);</span> <span class="nx">arg</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">state</span> <span class="p">=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">arg</span><span class="p">).</span><span class="nf">MustInt</span><span class="p">()</span>
        <span class="nx">maps</span><span class="p">[</span><span class="s">&#34;state&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">state</span>
    <span class="p">}</span>

    <span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>

    <span class="nx">data</span><span class="p">[</span><span class="s">&#34;lists&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">models</span><span class="p">.</span><span class="nf">GetTags</span><span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nf">GetPage</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">PageSize</span><span class="p">,</span> <span class="nx">maps</span><span class="p">)</span>
    <span class="nx">data</span><span class="p">[</span><span class="s">&#34;total&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">models</span><span class="p">.</span><span class="nf">GetTagTotal</span><span class="p">(</span><span class="nx">maps</span><span class="p">)</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">//新增文章标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">//修改文章标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">EditTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">//删除文章标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DeleteTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div><ol>
<li><code>c.Query</code>可用于获取<code>?name=test&amp;state=1</code>这类 URL 参数，而<code>c.DefaultQuery</code>则支持设置一个默认值</li>
<li><code>code</code>变量使用了<code>e</code>模块的错误编码，这正是先前规划好的错误码，方便排错和识别记录</li>
<li><code>util.GetPage</code>保证了各接口的<code>page</code>处理是一致的</li>
<li><code>c *gin.Context</code>是<code>Gin</code>很重要的组成部分，可以理解为上下文，它允许我们在中间件之间传递变量、管理流、验证请求的 JSON 和呈现 JSON 响应</li>
</ol>
<p>在本机执行<code>curl 127.0.0.1:8000/api/v1/tags</code>，正确的返回值为<code>{&quot;code&quot;:200,&quot;data&quot;:{&quot;lists&quot;:[],&quot;total&quot;:0},&quot;msg&quot;:&quot;ok&quot;}</code>，若存在问题请结合 gin 结果进行拍错。</p>
<p>在获取标签列表接口中，我们可以根据<code>name</code>、<code>state</code>、<code>page</code>来筛选查询条件，分页的步长可通过<code>app.ini</code>进行配置，以<code>lists</code>、<code>total</code>的组合返回达到分页效果。</p>
<h2 id="编写新增标签的-models-逻辑">编写新增标签的 models 逻辑</h2>
<p>接下来我们编写<strong>新增标签</strong>的接口</p>
<p>打开<code>models</code>目录下的<code>tag.go</code>，修改文件（增加 2 个方法）：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>
<span class="kd">func</span> <span class="nf">ExistTagByName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">tag</span> <span class="nx">Tag</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="s">&#34;id&#34;</span><span class="p">).</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;name = ?&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">).</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tag</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">ID</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">AddTag</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">state</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">createdBy</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Tag</span> <span class="p">{</span>
        <span class="nx">Name</span> <span class="p">:</span> <span class="nx">name</span><span class="p">,</span>
        <span class="nx">State</span> <span class="p">:</span> <span class="nx">state</span><span class="p">,</span>
        <span class="nx">CreatedBy</span> <span class="p">:</span> <span class="nx">createdBy</span><span class="p">,</span>
    <span class="p">})</span>

    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
<span class="o">...</span>
</code></pre></div><h2 id="编写新增标签的路由逻辑">编写新增标签的路由逻辑</h2>
<p>打开<code>routers</code>目录下的<code>tag.go</code>，修改文件（变动 AddTag 方法）：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">v1</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;net/http&#34;</span>

    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
    <span class="s">&#34;github.com/astaxie/beego/validation&#34;</span>
    <span class="s">&#34;github.com/Unknwon/com&#34;</span>

    <span class="s">&#34;gin-blog/pkg/e&#34;</span>
    <span class="s">&#34;gin-blog/models&#34;</span>
    <span class="s">&#34;gin-blog/pkg/util&#34;</span>
    <span class="s">&#34;gin-blog/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="o">...</span>

<span class="c1">//新增文章标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span>
    <span class="nx">state</span> <span class="o">:=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">DefaultQuery</span><span class="p">(</span><span class="s">&#34;state&#34;</span><span class="p">,</span> <span class="s">&#34;0&#34;</span><span class="p">)).</span><span class="nf">MustInt</span><span class="p">()</span>
    <span class="nx">createdBy</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;created_by&#34;</span><span class="p">)</span>

    <span class="nx">valid</span> <span class="o">:=</span> <span class="nx">validation</span><span class="p">.</span><span class="nx">Validation</span><span class="p">{}</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Required</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;名称不能为空&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">MaxSize</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;名称最长为100字符&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Required</span><span class="p">(</span><span class="nx">createdBy</span><span class="p">,</span> <span class="s">&#34;created_by&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;创建人不能为空&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">MaxSize</span><span class="p">(</span><span class="nx">createdBy</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s">&#34;created_by&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;创建人最长为100字符&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;state&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;状态只允许0或1&#34;</span><span class="p">)</span>

    <span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
    <span class="k">if</span> <span class="p">!</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">HasErrors</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">!</span> <span class="nx">models</span><span class="p">.</span><span class="nf">ExistTagByName</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
            <span class="nx">models</span><span class="p">.</span><span class="nf">AddTag</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">createdBy</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_EXIST_TAG</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
    <span class="p">})</span>
<span class="p">}</span>
<span class="o">...</span>
</code></pre></div><p>用<code>Postman</code>用 POST 访问<code>http://127.0.0.1:8000/api/v1/tags?name=1&amp;state=1&amp;created_by=test</code>，查看<code>code</code>是否返回<code>200</code>及<code>blog_tag</code>表中是否有值，有值则正确。</p>
<h2 id="编写-models-callbacks">编写 models callbacks</h2>
<p>但是这个时候大家会发现，我明明新增了标签，但<code>created_on</code>居然没有值，那做修改标签的时候<code>modified_on</code>会不会也存在这个问题？</p>
<p>为了解决这个问题，我们需要打开<code>models</code>目录下的<code>tag.go</code>文件，修改文件内容（修改包引用和增加 2 个方法）：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">models</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;time&#34;</span>

    <span class="s">&#34;github.com/jinzhu/gorm&#34;</span>
<span class="p">)</span>

<span class="o">...</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">tag</span> <span class="o">*</span><span class="nx">Tag</span><span class="p">)</span> <span class="nf">BeforeCreate</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">scope</span><span class="p">.</span><span class="nf">SetColumn</span><span class="p">(</span><span class="s">&#34;CreatedOn&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">tag</span> <span class="o">*</span><span class="nx">Tag</span><span class="p">)</span> <span class="nf">BeforeUpdate</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">scope</span><span class="p">.</span><span class="nf">SetColumn</span><span class="p">(</span><span class="s">&#34;ModifiedOn&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>重启服务，再在用<code>Postman</code>用 POST 访问<code>http://127.0.0.1:8000/api/v1/tags?name=2&amp;state=1&amp;created_by=test</code>，发现<code>created_on</code>已经有值了！</p>
<p><strong>在这几段代码中，涉及到知识点：</strong></p>
<p>这属于<code>gorm</code>的<code>Callbacks</code>，可以将回调方法定义为模型结构的指针，在创建、更新、查询、删除时将被调用，如果任何回调返回错误，gorm 将停止未来操作并回滚所有更改。</p>
<p><code>gorm</code>所支持的回调方法：</p>
<ul>
<li>创建：BeforeSave、BeforeCreate、AfterCreate、AfterSave</li>
<li>更新：BeforeSave、BeforeUpdate、AfterUpdate、AfterSave</li>
<li>删除：BeforeDelete、AfterDelete</li>
<li>查询：AfterFind</li>
</ul>
<hr>
<h2 id="编写其余接口的路由逻辑">编写其余接口的路由逻辑</h2>
<p>接下来，我们一口气把剩余的两个接口（EditTag、DeleteTag）完成吧</p>
<p>打开<code>routers</code>目录下 v1 版本的<code>tag.go</code>文件，修改内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>

<span class="c1">//修改文章标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">EditTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">id</span> <span class="o">:=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;id&#34;</span><span class="p">)).</span><span class="nf">MustInt</span><span class="p">()</span>
    <span class="nx">name</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;name&#34;</span><span class="p">)</span>
    <span class="nx">modifiedBy</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;modified_by&#34;</span><span class="p">)</span>

    <span class="nx">valid</span> <span class="o">:=</span> <span class="nx">validation</span><span class="p">.</span><span class="nx">Validation</span><span class="p">{}</span>

    <span class="kd">var</span> <span class="nx">state</span> <span class="kt">int</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nx">arg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;state&#34;</span><span class="p">);</span> <span class="nx">arg</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">state</span> <span class="p">=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">arg</span><span class="p">).</span><span class="nf">MustInt</span><span class="p">()</span>
        <span class="nx">valid</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;state&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;状态只允许0或1&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">valid</span><span class="p">.</span><span class="nf">Required</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="s">&#34;id&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;ID不能为空&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Required</span><span class="p">(</span><span class="nx">modifiedBy</span><span class="p">,</span> <span class="s">&#34;modified_by&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;修改人不能为空&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">MaxSize</span><span class="p">(</span><span class="nx">modifiedBy</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s">&#34;modified_by&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;修改人最长为100字符&#34;</span><span class="p">)</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">MaxSize</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;名称最长为100字符&#34;</span><span class="p">)</span>

    <span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
    <span class="k">if</span> <span class="p">!</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">HasErrors</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
        <span class="k">if</span> <span class="nx">models</span><span class="p">.</span><span class="nf">ExistTagByID</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">data</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
            <span class="nx">data</span><span class="p">[</span><span class="s">&#34;modified_by&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">modifiedBy</span>
            <span class="k">if</span> <span class="nx">name</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
                <span class="nx">data</span><span class="p">[</span><span class="s">&#34;name&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">name</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">state</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
                <span class="nx">data</span><span class="p">[</span><span class="s">&#34;state&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">state</span>
            <span class="p">}</span>

            <span class="nx">models</span><span class="p">.</span><span class="nf">EditTag</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_NOT_EXIST_TAG</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">//删除文章标签
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DeleteTag</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">id</span> <span class="o">:=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;id&#34;</span><span class="p">)).</span><span class="nf">MustInt</span><span class="p">()</span>

    <span class="nx">valid</span> <span class="o">:=</span> <span class="nx">validation</span><span class="p">.</span><span class="nx">Validation</span><span class="p">{}</span>
    <span class="nx">valid</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;id&#34;</span><span class="p">).</span><span class="nf">Message</span><span class="p">(</span><span class="s">&#34;ID必须大于0&#34;</span><span class="p">)</span>

    <span class="nx">code</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">INVALID_PARAMS</span>
    <span class="k">if</span> <span class="p">!</span> <span class="nx">valid</span><span class="p">.</span><span class="nf">HasErrors</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">SUCCESS</span>
        <span class="k">if</span> <span class="nx">models</span><span class="p">.</span><span class="nf">ExistTagByID</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">models</span><span class="p">.</span><span class="nf">DeleteTag</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">code</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">ERROR_NOT_EXIST_TAG</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
        <span class="s">&#34;code&#34;</span> <span class="p">:</span> <span class="nx">code</span><span class="p">,</span>
        <span class="s">&#34;msg&#34;</span> <span class="p">:</span> <span class="nx">e</span><span class="p">.</span><span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span><span class="p">),</span>
        <span class="s">&#34;data&#34;</span> <span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div><h2 id="编写其余接口的-models-逻辑">编写其余接口的 models 逻辑</h2>
<p>打开<code>models</code>下的<code>tag.go</code>，修改文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">...</span>

<span class="kd">func</span> <span class="nf">ExistTagByID</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">tag</span> <span class="nx">Tag</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="s">&#34;id&#34;</span><span class="p">).</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tag</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">ID</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">DeleteTag</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">Delete</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Tag</span><span class="p">{})</span>

    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">EditTag</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span> <span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Tag</span><span class="p">{}).</span><span class="nf">Where</span><span class="p">(</span><span class="s">&#34;id = ?&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">).</span><span class="nf">Updates</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
<span class="o">...</span>
</code></pre></div><h2 id="验证功能">验证功能</h2>
<p>重启服务，用 Postman</p>
<ul>
<li>PUT 访问 http://127.0.0.1:8000/api/v1/tags/1?name=edit1&amp;state=0&amp;modified_by=edit1 ，查看 code 是否返回 200</li>
<li>DELETE 访问 http://127.0.0.1:8000/api/v1/tags/1 ，查看 code 是否返回 200</li>
</ul>
<p>至此，Tag 的 API&rsquo;s 完成，下一节我们将开始 Article 的 API&rsquo;s 编写！</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「连载二」Gin搭建Blog API&#39;s （一）</title>
			<link>https://eddycjy.com/posts/go/gin/2018-02-11-api-01/</link>
			<pubDate>Sun, 11 Feb 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-02-11-api-01/</guid>
			<description>思考 首先，在一个初始项目开始前，大家都要思考一下
  程序的文本配置写在代码中，好吗？
  API 的错误码硬编码在程序中，合适吗？
  db 句柄谁都去Open，没有统一管理，好吗？
  获取分页等公共参数，谁都自己写一套逻辑，好吗？
  显然在较正规的项目中，这些问题的答案都是不可以，为了解决这些问题，我们挑选一款读写配置文件的库，目前比较火的有 viper，有兴趣你未来可以简单了解一下，没兴趣的话等以后接触到再说。
但是本系列选用 go-ini/ini ，它的 中文文档。大家是必须需要要简单阅读它的文档，再接着完成后面的内容。
本文目标  编写一个简单的 API 错误码包。 完成一个 Demo 示例。 讲解 Demo 所涉及的知识点。  介绍和初始化项目 初始化项目目录 在前一章节中，我们初始化了一个 go-gin-example 项目，接下来我们需要继续新增如下目录结构：
go-gin-example/ ├── conf ├── middleware ├── models ├── pkg ├── routers └── runtime  conf：用于存储配置文件 middleware：应用中间件 models：应用数据库模型 pkg：第三方包 routers 路由逻辑处理 runtime：应用运行时数据  添加 Go Modules Replace 打开 go.mod 文件，新增 replace 配置项，如下：</description>
			<content type="html"><![CDATA[<h2 id="思考">思考</h2>
<p>首先，在一个初始项目开始前，大家都要思考一下</p>
<ul>
<li>
<p>程序的文本配置写在代码中，好吗？</p>
</li>
<li>
<p>API 的错误码硬编码在程序中，合适吗？</p>
</li>
<li>
<p>db 句柄谁都去<code>Open</code>，没有统一管理，好吗？</p>
</li>
<li>
<p>获取分页等公共参数，谁都自己写一套逻辑，好吗？</p>
</li>
</ul>
<p>显然在较正规的项目中，这些问题的答案都是<strong>不可以</strong>，为了解决这些问题，我们挑选一款读写配置文件的库，目前比较火的有 <a href="https://github.com/spf13/viper">viper</a>，有兴趣你未来可以简单了解一下，没兴趣的话等以后接触到再说。</p>
<p>但是本系列选用 <a href="https://github.com/go-ini/ini">go-ini/ini</a> ，它的 <a href="https://ini.unknwon.io/">中文文档</a>。大家是必须需要要简单阅读它的文档，再接着完成后面的内容。</p>
<h2 id="本文目标">本文目标</h2>
<ul>
<li>编写一个简单的 API 错误码包。</li>
<li>完成一个 Demo 示例。</li>
<li>讲解 Demo 所涉及的知识点。</li>
</ul>
<h2 id="介绍和初始化项目">介绍和初始化项目</h2>
<h3 id="初始化项目目录">初始化项目目录</h3>
<p>在前一章节中，我们初始化了一个 <code>go-gin-example</code> 项目，接下来我们需要继续新增如下目录结构：</p>
<pre><code>go-gin-example/
├── conf
├── middleware
├── models
├── pkg
├── routers
└── runtime
</code></pre><ul>
<li>conf：用于存储配置文件</li>
<li>middleware：应用中间件</li>
<li>models：应用数据库模型</li>
<li>pkg：第三方包</li>
<li>routers 路由逻辑处理</li>
<li>runtime：应用运行时数据</li>
</ul>
<h3 id="添加-go-modules-replace">添加 Go Modules Replace</h3>
<p>打开 <code>go.mod</code> 文件，新增 <code>replace</code> 配置项，如下：</p>
<pre><code>module github.com/EDDYCJY/go-gin-example

go 1.13

require (...)

replace (
		github.com/EDDYCJY/go-gin-example/pkg/setting =&gt; ~/go-application/go-gin-example/pkg/setting
		github.com/EDDYCJY/go-gin-example/conf    	  =&gt; ~/go-application/go-gin-example/pkg/conf
		github.com/EDDYCJY/go-gin-example/middleware  =&gt; ~/go-application/go-gin-example/middleware
		github.com/EDDYCJY/go-gin-example/models 	  =&gt; ~/go-application/go-gin-example/models
		github.com/EDDYCJY/go-gin-example/routers 	  =&gt; ~/go-application/go-gin-example/routers
)
</code></pre><p>可能你会不理解为什么要特意跑来加 <code>replace</code> 配置项，首先你要看到我们使用的是完整的外部模块引用路径（<code>github.com/EDDYCJY/go-gin-example/xxx</code>），而这个模块还没推送到远程，是没有办法下载下来的，因此需要用 <code>replace</code> 将其指定读取本地的模块路径，这样子就可以解决本地模块读取的问题。</p>
<p><strong>注：后续每新增一个本地应用目录，你都需要主动去 go.mod 文件里新增一条 replace（我不会提醒你），如果你漏了，那么编译时会出现报错，找不到那个模块。</strong></p>
<h3 id="初始项目数据库">初始项目数据库</h3>
<p>新建 <code>blog</code> 数据库，编码为<code>utf8_general_ci</code>，在 <code>blog</code> 数据库下，新建以下表</p>
<p><strong>1、 标签表</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">blog_tag</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;标签名称&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">created_on</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">DEFAULT</span> <span class="s1">&#39;0&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;创建时间&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">created_by</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;创建人&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">modified_on</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">DEFAULT</span> <span class="s1">&#39;0&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;修改时间&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">modified_by</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;修改人&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">deleted_on</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">DEFAULT</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="k">state</span><span class="o">`</span> <span class="n">tinyint</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">DEFAULT</span> <span class="s1">&#39;1&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;状态 0为禁用、1为启用&#39;</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span> <span class="k">COMMENT</span><span class="o">=</span><span class="s1">&#39;文章标签管理&#39;</span><span class="p">;</span>
</code></pre></div><p><strong>2、 文章表</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">blog_article</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="o">`</span><span class="n">tag_id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">DEFAULT</span> <span class="s1">&#39;0&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;标签ID&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">title</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;文章标题&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="k">desc</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;简述&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">content</span><span class="o">`</span> <span class="nb">text</span><span class="p">,</span>
  <span class="o">`</span><span class="n">created_on</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">created_by</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;创建人&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">modified_on</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">DEFAULT</span> <span class="s1">&#39;0&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;修改时间&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">modified_by</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;修改人&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">deleted_on</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">DEFAULT</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="k">state</span><span class="o">`</span> <span class="n">tinyint</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">DEFAULT</span> <span class="s1">&#39;1&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;状态 0为禁用1为启用&#39;</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span> <span class="k">COMMENT</span><span class="o">=</span><span class="s1">&#39;文章管理&#39;</span><span class="p">;</span>
</code></pre></div><p><strong>3、 认证表</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">blog_auth</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="n">unsigned</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="o">`</span><span class="n">username</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;账号&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">password</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="k">COMMENT</span> <span class="s1">&#39;密码&#39;</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">blog</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">blog_auth</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">,</span> <span class="o">`</span><span class="n">username</span><span class="o">`</span><span class="p">,</span> <span class="o">`</span><span class="n">password</span><span class="o">`</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="s1">&#39;test123456&#39;</span><span class="p">);</span>

</code></pre></div><h2 id="编写项目配置包">编写项目配置包</h2>
<p>在 <code>go-gin-example</code> 应用目录下，拉取 <code>go-ini/ini</code> 的依赖包，如下：</p>
<pre><code>$ go get -u github.com/go-ini/ini
go: finding github.com/go-ini/ini v1.48.0
go: downloading github.com/go-ini/ini v1.48.0
go: extracting github.com/go-ini/ini v1.48.0
</code></pre><p>接下来我们需要编写基础的应用配置文件，在 <code>go-gin-example</code> 的<code>conf</code>目录下新建<code>app.ini</code>文件，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="c1">#debug or release</span>
<span class="na">RUN_MODE</span> <span class="o">=</span> <span class="s">debug</span>

<span class="k">[app]</span>
<span class="na">PAGE_SIZE</span> <span class="o">=</span> <span class="s">10</span>
<span class="na">JWT_SECRET</span> <span class="o">=</span> <span class="s">23347$040412</span>

<span class="k">[server]</span>
<span class="na">HTTP_PORT</span> <span class="o">=</span> <span class="s">8000</span>
<span class="na">READ_TIMEOUT</span> <span class="o">=</span> <span class="s">60</span>
<span class="na">WRITE_TIMEOUT</span> <span class="o">=</span> <span class="s">60</span>

<span class="k">[database]</span>
<span class="na">TYPE</span> <span class="o">=</span> <span class="s">mysql</span>
<span class="na">USER</span> <span class="o">=</span> <span class="s">数据库账号</span>
<span class="na">PASSWORD</span> <span class="o">=</span> <span class="s">数据库密码</span>
<span class="c1">#127.0.0.1:3306</span>
<span class="na">HOST</span> <span class="o">=</span> <span class="s">数据库IP:数据库端口号</span>
<span class="na">NAME</span> <span class="o">=</span> <span class="s">blog</span>
<span class="na">TABLE_PREFIX</span> <span class="o">=</span> <span class="s">blog_</span>
</code></pre></div><p>建立调用配置的<code>setting</code>模块，在<code>go-gin-example</code>的<code>pkg</code>目录下新建<code>setting</code>目录（注意新增 replace 配置），新建 <code>setting.go</code> 文件，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">setting</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/go-ini/ini&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">Cfg</span> <span class="o">*</span><span class="nx">ini</span><span class="p">.</span><span class="nx">File</span>

	<span class="nx">RunMode</span> <span class="kt">string</span>

	<span class="nx">HTTPPort</span> <span class="kt">int</span>
	<span class="nx">ReadTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
	<span class="nx">WriteTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="nx">PageSize</span> <span class="kt">int</span>
	<span class="nx">JwtSecret</span> <span class="kt">string</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="nx">Cfg</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">ini</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="s">&#34;conf/app.ini&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Fail to parse &#39;conf/app.ini&#39;: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">LoadBase</span><span class="p">()</span>
	<span class="nf">LoadServer</span><span class="p">()</span>
	<span class="nf">LoadApp</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">LoadBase</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">RunMode</span> <span class="p">=</span> <span class="nx">Cfg</span><span class="p">.</span><span class="nf">Section</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">).</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;RUN_MODE&#34;</span><span class="p">).</span><span class="nf">MustString</span><span class="p">(</span><span class="s">&#34;debug&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">LoadServer</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sec</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Cfg</span><span class="p">.</span><span class="nf">GetSection</span><span class="p">(</span><span class="s">&#34;server&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Fail to get section &#39;server&#39;: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">HTTPPort</span> <span class="p">=</span> <span class="nx">sec</span><span class="p">.</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;HTTP_PORT&#34;</span><span class="p">).</span><span class="nf">MustInt</span><span class="p">(</span><span class="mi">8000</span><span class="p">)</span>
	<span class="nx">ReadTimeout</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">sec</span><span class="p">.</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;READ_TIMEOUT&#34;</span><span class="p">).</span><span class="nf">MustInt</span><span class="p">(</span><span class="mi">60</span><span class="p">))</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>
	<span class="nx">WriteTimeout</span> <span class="p">=</span>  <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">sec</span><span class="p">.</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;WRITE_TIMEOUT&#34;</span><span class="p">).</span><span class="nf">MustInt</span><span class="p">(</span><span class="mi">60</span><span class="p">))</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">LoadApp</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sec</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Cfg</span><span class="p">.</span><span class="nf">GetSection</span><span class="p">(</span><span class="s">&#34;app&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Fail to get section &#39;app&#39;: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">JwtSecret</span> <span class="p">=</span> <span class="nx">sec</span><span class="p">.</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;JWT_SECRET&#34;</span><span class="p">).</span><span class="nf">MustString</span><span class="p">(</span><span class="s">&#34;!@)*#)!@U#@*!@!)&#34;</span><span class="p">)</span>
	<span class="nx">PageSize</span> <span class="p">=</span> <span class="nx">sec</span><span class="p">.</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;PAGE_SIZE&#34;</span><span class="p">).</span><span class="nf">MustInt</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>当前的目录结构：</p>
<pre><code>go-gin-example
├── conf
│   └── app.ini
├── go.mod
├── go.sum
├── middleware
├── models
├── pkg
│   └── setting.go
├── routers
└── runtime
</code></pre><h2 id="编写-api-错误码包">编写 API 错误码包</h2>
<p>建立错误码的<code>e</code>模块，在<code>go-gin-example</code>的<code>pkg</code>目录下新建<code>e</code>目录（注意新增 replace 配置），新建<code>code.go</code>和<code>msg.go</code>文件，写入内容：</p>
<p><strong>1、 code.go：</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">e</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">SUCCESS</span> <span class="p">=</span> <span class="mi">200</span>
	<span class="nx">ERROR</span> <span class="p">=</span> <span class="mi">500</span>
	<span class="nx">INVALID_PARAMS</span> <span class="p">=</span> <span class="mi">400</span>

	<span class="nx">ERROR_EXIST_TAG</span> <span class="p">=</span> <span class="mi">10001</span>
	<span class="nx">ERROR_NOT_EXIST_TAG</span> <span class="p">=</span> <span class="mi">10002</span>
	<span class="nx">ERROR_NOT_EXIST_ARTICLE</span> <span class="p">=</span> <span class="mi">10003</span>

	<span class="nx">ERROR_AUTH_CHECK_TOKEN_FAIL</span> <span class="p">=</span> <span class="mi">20001</span>
	<span class="nx">ERROR_AUTH_CHECK_TOKEN_TIMEOUT</span> <span class="p">=</span> <span class="mi">20002</span>
	<span class="nx">ERROR_AUTH_TOKEN</span> <span class="p">=</span> <span class="mi">20003</span>
	<span class="nx">ERROR_AUTH</span> <span class="p">=</span> <span class="mi">20004</span>
<span class="p">)</span>
</code></pre></div><p><strong>2、 msg.go：</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">e</span>

<span class="kd">var</span> <span class="nx">MsgFlags</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">SUCCESS</span> <span class="p">:</span> <span class="s">&#34;ok&#34;</span><span class="p">,</span>
	<span class="nx">ERROR</span> <span class="p">:</span> <span class="s">&#34;fail&#34;</span><span class="p">,</span>
	<span class="nx">INVALID_PARAMS</span> <span class="p">:</span> <span class="s">&#34;请求参数错误&#34;</span><span class="p">,</span>
	<span class="nx">ERROR_EXIST_TAG</span> <span class="p">:</span> <span class="s">&#34;已存在该标签名称&#34;</span><span class="p">,</span>
	<span class="nx">ERROR_NOT_EXIST_TAG</span> <span class="p">:</span> <span class="s">&#34;该标签不存在&#34;</span><span class="p">,</span>
	<span class="nx">ERROR_NOT_EXIST_ARTICLE</span> <span class="p">:</span> <span class="s">&#34;该文章不存在&#34;</span><span class="p">,</span>
	<span class="nx">ERROR_AUTH_CHECK_TOKEN_FAIL</span> <span class="p">:</span> <span class="s">&#34;Token鉴权失败&#34;</span><span class="p">,</span>
	<span class="nx">ERROR_AUTH_CHECK_TOKEN_TIMEOUT</span> <span class="p">:</span> <span class="s">&#34;Token已超时&#34;</span><span class="p">,</span>
	<span class="nx">ERROR_AUTH_TOKEN</span> <span class="p">:</span> <span class="s">&#34;Token生成失败&#34;</span><span class="p">,</span>
	<span class="nx">ERROR_AUTH</span> <span class="p">:</span> <span class="s">&#34;Token错误&#34;</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetMsg</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">msg</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">MsgFlags</span><span class="p">[</span><span class="nx">code</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">msg</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">MsgFlags</span><span class="p">[</span><span class="nx">ERROR</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><h2 id="编写工具包">编写工具包</h2>
<p>在<code>go-gin-example</code>的<code>pkg</code>目录下新建<code>util</code>目录（注意新增 replace 配置），并拉取<code>com</code>的依赖包，如下：</p>
<pre><code>$ go get -u github.com/unknwon/com
</code></pre><h3 id="编写分页页码的获取方法">编写分页页码的获取方法</h3>
<p>在<code>util</code>目录下新建<code>pagination.go</code>，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">util</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/unknwon/com&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">GetPage</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">page</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">com</span><span class="p">.</span><span class="nf">StrTo</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">&#34;page&#34;</span><span class="p">)).</span><span class="nf">Int</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">page</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">result</span> <span class="p">=</span> <span class="p">(</span><span class="nx">page</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">PageSize</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><h2 id="编写-models-init">编写 models init</h2>
<p>拉取<code>gorm</code>的依赖包，如下：</p>
<pre><code>$ go get -u github.com/jinzhu/gorm
</code></pre><p>拉取<code>mysql</code>驱动的依赖包，如下：</p>
<pre><code>$ go get -u github.com/go-sql-driver/mysql
</code></pre><p>完成后，在<code>go-gin-example</code>的<code>models</code>目录下新建<code>models.go</code>，用于<code>models</code>的初始化使用</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">models</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;fmt&#34;</span>

	<span class="s">&#34;github.com/jinzhu/gorm&#34;</span>
	<span class="nx">_</span> <span class="s">&#34;github.com/jinzhu/gorm/dialects/mysql&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">db</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">DB</span>

<span class="kd">type</span> <span class="nx">Model</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span> <span class="kt">int</span> <span class="s">`gorm:&#34;primary_key&#34; json:&#34;id&#34;`</span>
	<span class="nx">CreatedOn</span> <span class="kt">int</span> <span class="s">`json:&#34;created_on&#34;`</span>
	<span class="nx">ModifiedOn</span> <span class="kt">int</span> <span class="s">`json:&#34;modified_on&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">err</span> <span class="kt">error</span>
		<span class="nx">dbType</span><span class="p">,</span> <span class="nx">dbName</span><span class="p">,</span> <span class="nx">user</span><span class="p">,</span> <span class="nx">password</span><span class="p">,</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">tablePrefix</span> <span class="kt">string</span>
	<span class="p">)</span>

	<span class="nx">sec</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">Cfg</span><span class="p">.</span><span class="nf">GetSection</span><span class="p">(</span><span class="s">&#34;database&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#34;Fail to get section &#39;database&#39;: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">dbType</span> <span class="p">=</span> <span class="nx">sec</span><span class="p">.</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;TYPE&#34;</span><span class="p">).</span><span class="nf">String</span><span class="p">()</span>
	<span class="nx">dbName</span> <span class="p">=</span> <span class="nx">sec</span><span class="p">.</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;NAME&#34;</span><span class="p">).</span><span class="nf">String</span><span class="p">()</span>
	<span class="nx">user</span> <span class="p">=</span> <span class="nx">sec</span><span class="p">.</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;USER&#34;</span><span class="p">).</span><span class="nf">String</span><span class="p">()</span>
	<span class="nx">password</span> <span class="p">=</span> <span class="nx">sec</span><span class="p">.</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;PASSWORD&#34;</span><span class="p">).</span><span class="nf">String</span><span class="p">()</span>
	<span class="nx">host</span> <span class="p">=</span> <span class="nx">sec</span><span class="p">.</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;HOST&#34;</span><span class="p">).</span><span class="nf">String</span><span class="p">()</span>
	<span class="nx">tablePrefix</span> <span class="p">=</span> <span class="nx">sec</span><span class="p">.</span><span class="nf">Key</span><span class="p">(</span><span class="s">&#34;TABLE_PREFIX&#34;</span><span class="p">).</span><span class="nf">String</span><span class="p">()</span>

	<span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">dbType</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s:%s@tcp(%s)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&#34;</span><span class="p">,</span>
		<span class="nx">user</span><span class="p">,</span>
		<span class="nx">password</span><span class="p">,</span>
		<span class="nx">host</span><span class="p">,</span>
		<span class="nx">dbName</span><span class="p">))</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">gorm</span><span class="p">.</span><span class="nx">DefaultTableNameHandler</span> <span class="p">=</span> <span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">DB</span><span class="p">,</span> <span class="nx">defaultTableName</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>  <span class="p">{</span>
	    <span class="k">return</span> <span class="nx">tablePrefix</span> <span class="o">+</span> <span class="nx">defaultTableName</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nx">db</span><span class="p">.</span><span class="nf">SingularTable</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">LogMode</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">DB</span><span class="p">().</span><span class="nf">SetMaxIdleConns</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">DB</span><span class="p">().</span><span class="nf">SetMaxOpenConns</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CloseDB</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h2 id="编写项目启动路由文件">编写项目启动、路由文件</h2>
<p>最基础的准备工作完成啦，让我们开始编写 Demo 吧！</p>
<h3 id="编写-demo">编写 Demo</h3>
<p>在<code>go-gin-example</code>下建立<code>main.go</code>作为启动文件（也就是<code>main</code>包），我们先写个<strong>Demo</strong>，帮助大家理解，写入文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;net/http&#34;</span>

    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>

    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">router</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
    <span class="nx">router</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/test&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
			<span class="s">&#34;message&#34;</span><span class="p">:</span> <span class="s">&#34;test&#34;</span><span class="p">,</span>
		<span class="p">})</span>
	<span class="p">})</span>

	<span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
		<span class="nx">Addr</span><span class="p">:</span>           <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;:%d&#34;</span><span class="p">,</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">HTTPPort</span><span class="p">),</span>
		<span class="nx">Handler</span><span class="p">:</span>        <span class="nx">router</span><span class="p">,</span>
		<span class="nx">ReadTimeout</span><span class="p">:</span>    <span class="nx">setting</span><span class="p">.</span><span class="nx">ReadTimeout</span><span class="p">,</span>
		<span class="nx">WriteTimeout</span><span class="p">:</span>   <span class="nx">setting</span><span class="p">.</span><span class="nx">WriteTimeout</span><span class="p">,</span>
		<span class="nx">MaxHeaderBytes</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">s</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>执行<code>go run main.go</code>，查看命令行是否显示</p>
<pre><code>[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /test                     --&gt; main.main.func1 (3 handlers)
</code></pre><p>在本机执行<code>curl 127.0.0.1:8000/test</code>，检查是否返回<code>{&quot;message&quot;:&quot;test&quot;}</code>。</p>
<h3 id="知识点">知识点</h3>
<p><strong>那么，我们来延伸一下 Demo 所涉及的知识点！</strong></p>
<h5 id="标准库">标准库</h5>
<ul>
<li><a href="https://golang.org/pkg/fmt/">fmt</a>：实现了类似 C 语言 printf 和 scanf 的格式化 I/O。格式化动作（&lsquo;verb&rsquo;）源自 C 语言但更简单</li>
<li><a href="https://golang.org/pkg/net/http/">net/http</a>：提供了 HTTP 客户端和服务端的实现</li>
</ul>
<h5 id="gin"><strong>Gin</strong></h5>
<ul>
<li><a href="https://gowalker.org/github.com/gin-gonic/gin#Default">gin.Default()</a>：返回 Gin 的<code>type Engine struct{...}</code>，里面包含<code>RouterGroup</code>，相当于创建一个路由<code>Handlers</code>，可以后期绑定各类的路由规则和函数、中间件等</li>
<li><a href="https://gowalker.org/github.com/gin-gonic/gin#IRoutes">router.GET(&hellip;){&hellip;}</a>：创建不同的 HTTP 方法绑定到<code>Handlers</code>中，也支持 POST、PUT、DELETE、PATCH、OPTIONS、HEAD 等常用的 Restful 方法</li>
<li><a href="https://gowalker.org/github.com/gin-gonic/gin#H">gin.H{&hellip;}</a>：就是一个<code>map[string]interface{}</code></li>
<li><a href="https://gowalker.org/github.com/gin-gonic/gin#Context">gin.Context</a>：<code>Context</code>是<code>gin</code>中的上下文，它允许我们在中间件之间传递变量、管理流、验证 JSON 请求、响应 JSON 请求等，在<code>gin</code>中包含大量<code>Context</code>的方法，例如我们常用的<code>DefaultQuery</code>、<code>Query</code>、<code>DefaultPostForm</code>、<code>PostForm</code>等等</li>
</ul>
<h5 id="httpserver-和-listenandserve">&amp;http.Server 和 ListenAndServe？</h5>
<p>1、http.Server：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Server</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Addr</span>    <span class="kt">string</span>
    <span class="nx">Handler</span> <span class="nx">Handler</span>
    <span class="nx">TLSConfig</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>
    <span class="nx">ReadTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="nx">ReadHeaderTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="nx">WriteTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="nx">IdleTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
    <span class="nx">MaxHeaderBytes</span> <span class="kt">int</span>
    <span class="nx">ConnState</span> <span class="kd">func</span><span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">ConnState</span><span class="p">)</span>
    <span class="nx">ErrorLog</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>Addr：监听的 TCP 地址，格式为<code>:8000</code></li>
<li>Handler：http 句柄，实质为<code>ServeHTTP</code>，用于处理程序响应 HTTP 请求</li>
<li>TLSConfig：安全传输层协议（TLS）的配置</li>
<li>ReadTimeout：允许读取的最大时间</li>
<li>ReadHeaderTimeout：允许读取请求头的最大时间</li>
<li>WriteTimeout：允许写入的最大时间</li>
<li>IdleTimeout：等待的最大时间</li>
<li>MaxHeaderBytes：请求头的最大字节数</li>
<li>ConnState：指定一个可选的回调函数，当客户端连接发生变化时调用</li>
<li>ErrorLog：指定一个可选的日志记录器，用于接收程序的意外行为和底层系统错误；如果未设置或为<code>nil</code>则默认以日志包的标准日志记录器完成（也就是在控制台输出）</li>
</ul>
<p>2、 ListenAndServe：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">ListenAndServe</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">addr</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">Addr</span>
    <span class="k">if</span> <span class="nx">addr</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">addr</span> <span class="p">=</span> <span class="s">&#34;:http&#34;</span>
    <span class="p">}</span>
    <span class="nx">ln</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">tcpKeepAliveListener</span><span class="p">{</span><span class="nx">ln</span><span class="p">.(</span><span class="o">*</span><span class="nx">net</span><span class="p">.</span><span class="nx">TCPListener</span><span class="p">)})</span>
<span class="p">}</span>
</code></pre></div><p>开始监听服务，监听 TCP 网络地址，Addr 和调用应用程序处理连接上的请求。</p>
<p>我们在源码中看到<code>Addr</code>是调用我们在<code>&amp;http.Server</code>中设置的参数，因此我们在设置时要用<code>&amp;</code>，我们要改变参数的值，因为我们<code>ListenAndServe</code>和其他一些方法需要用到<code>&amp;http.Server</code>中的参数，他们是相互影响的。</p>
<p>3、 <code>http.ListenAndServe</code>和 <a href="https://segmentfault.com/a/1190000013297625#articleHeader5">连载一</a> 的<code>r.Run()</code>有区别吗？</p>
<p>我们看看<code>r.Run</code>的实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">engine</span> <span class="o">*</span><span class="nx">Engine</span><span class="p">)</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">addr</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">debugPrintError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">}()</span>

    <span class="nx">address</span> <span class="o">:=</span> <span class="nf">resolveAddress</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
    <span class="nf">debugPrint</span><span class="p">(</span><span class="s">&#34;Listening and serving HTTP on %s\n&#34;</span><span class="p">,</span> <span class="nx">address</span><span class="p">)</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="nx">address</span><span class="p">,</span> <span class="nx">engine</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>通过分析源码，得知<strong>本质上没有区别</strong>，同时也得知了启动<code>gin</code>时的监听 debug 信息在这里输出。</p>
<p>4、 为什么 Demo 里会有<code>WARNING</code>？</p>
<p>首先我们可以看下<code>Default()</code>的实现</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Default returns an Engine instance with the Logger and Recovery middleware already attached.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Default</span><span class="p">()</span> <span class="o">*</span><span class="nx">Engine</span> <span class="p">{</span>
	<span class="nf">debugPrintWARNINGDefault</span><span class="p">()</span>
	<span class="nx">engine</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">()</span>
	<span class="nx">engine</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nf">Logger</span><span class="p">(),</span> <span class="nf">Recovery</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">engine</span>
<span class="p">}</span>
</code></pre></div><p>大家可以看到默认情况下，已经附加了日志、恢复中间件的引擎实例。并且在开头调用了<code>debugPrintWARNINGDefault()</code>，而它的实现就是输出该行日志</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">debugPrintWARNINGDefault</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">debugPrint</span><span class="p">(</span><span class="s">`[WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.
</span><span class="s">`</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>而另外一个<code>Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.</code>，是运行模式原因，并不难理解，已在配置文件的管控下 :-)，运维人员随时就可以修改它的配置。</p>
<p>5、 Demo 的<code>router.GET</code>等路由规则可以不写在<code>main</code>包中吗？</p>
<p>我们发现<code>router.GET</code>等路由规则，在 Demo 中被编写在了<code>main</code>包中，感觉很奇怪，我们去抽离这部分逻辑！</p>
<p>在<code>go-gin-example</code>下<code>routers</code>目录新建<code>router.go</code>文件，写入内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">routers</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>

    <span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">InitRouter</span><span class="p">()</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Engine</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

    <span class="nx">r</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nf">Logger</span><span class="p">())</span>

    <span class="nx">r</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">gin</span><span class="p">.</span><span class="nf">Recovery</span><span class="p">())</span>

    <span class="nx">gin</span><span class="p">.</span><span class="nf">SetMode</span><span class="p">(</span><span class="nx">setting</span><span class="p">.</span><span class="nx">RunMode</span><span class="p">)</span>

    <span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/test&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
            <span class="s">&#34;message&#34;</span><span class="p">:</span> <span class="s">&#34;test&#34;</span><span class="p">,</span>
        <span class="p">})</span>
    <span class="p">})</span>

    <span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></div><p>修改<code>main.go</code>的文件内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/routers&#34;</span>
	<span class="s">&#34;github.com/EDDYCJY/go-gin-example/pkg/setting&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">router</span> <span class="o">:=</span> <span class="nx">routers</span><span class="p">.</span><span class="nf">InitRouter</span><span class="p">()</span>

	<span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
		<span class="nx">Addr</span><span class="p">:</span>           <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;:%d&#34;</span><span class="p">,</span> <span class="nx">setting</span><span class="p">.</span><span class="nx">HTTPPort</span><span class="p">),</span>
		<span class="nx">Handler</span><span class="p">:</span>        <span class="nx">router</span><span class="p">,</span>
		<span class="nx">ReadTimeout</span><span class="p">:</span>    <span class="nx">setting</span><span class="p">.</span><span class="nx">ReadTimeout</span><span class="p">,</span>
		<span class="nx">WriteTimeout</span><span class="p">:</span>   <span class="nx">setting</span><span class="p">.</span><span class="nx">WriteTimeout</span><span class="p">,</span>
		<span class="nx">MaxHeaderBytes</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">s</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>当前目录结构：</p>
<pre><code>go-gin-example/
├── conf
│   └── app.ini
├── main.go
├── middleware
├── models
│   └── models.go
├── pkg
│   ├── e
│   │   ├── code.go
│   │   └── msg.go
│   ├── setting
│   │   └── setting.go
│   └── util
│       └── pagination.go
├── routers
│   └── router.go
├── runtime
</code></pre><p>重启服务，执行 <code>curl 127.0.0.1:8000/test</code>查看是否正确返回。</p>
<p>下一节，我们将以我们的 Demo 为起点进行修改，开始编码！</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
		<item>
			<title>「连载一」Go 介绍与环境安装</title>
			<link>https://eddycjy.com/posts/go/gin/2018-02-10-install/</link>
			<pubDate>Sat, 10 Feb 2018 12:00:00 +0000</pubDate>
			
			<guid>https://eddycjy.com/posts/go/gin/2018-02-10-install/</guid>
			<description>本文目标  学会安装 Go。 知道什么是 Go。 知道什么是 Go modules。 了解 Go modules 的小历史。 学会简单的使用 Go modules。 了解 Gin，并简单跑起一个 Demo。  准备环节 安装 Go Centos 首先，根据对应的操作系统选择安装包 下载，在这里我使用的是 Centos 64 位系统，如下：
$ wget https://studygolang.com/dl/golang/go1.13.1.linux-amd64.tar.gz $ tar -zxvf go1.13.1.linux-amd64.tar.gz $ mv go/ /usr/local/ 配置 /etc/profile
vi /etc/profile 添加环境变量 GOROOT 和将 GOBIN 添加到 PATH 中
export GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 配置完毕后，执行命令令其生效
source /etc/profile 在控制台输入go version，若输出版本号则安装成功，如下：
$ go version go version go1.13.1 linux/amd64 MacOS 在 MacOS 上安装 Go 最方便的办法就是使用 brew，安装如下：</description>
			<content type="html"><![CDATA[<h2 id="本文目标">本文目标</h2>
<ul>
<li>学会安装 Go。</li>
<li>知道什么是 Go。</li>
<li>知道什么是 Go modules。</li>
<li>了解 Go modules 的小历史。</li>
<li>学会简单的使用 Go modules。</li>
<li>了解 Gin，并简单跑起一个 Demo。</li>
</ul>
<h2 id="准备环节">准备环节</h2>
<h3 id="安装-go">安装 Go</h3>
<h4 id="centos">Centos</h4>
<p>首先，根据对应的操作系统选择安装包 <a href="https://studygolang.com/dl">下载</a>，在这里我使用的是 Centos 64 位系统，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ wget https://studygolang.com/dl/golang/go1.13.1.linux-amd64.tar.gz

$ tar -zxvf go1.13.1.linux-amd64.tar.gz

$ mv go/ /usr/local/
</code></pre></div><p>配置 /etc/profile</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">vi /etc/profile
</code></pre></div><p>添加环境变量 GOROOT 和将 GOBIN 添加到 PATH 中</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">export</span> <span class="nv">GOROOT</span><span class="o">=</span>/usr/local/go
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$GOROOT</span>/bin
</code></pre></div><p>配置完毕后，执行命令令其生效</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">source</span> /etc/profile
</code></pre></div><p>在控制台输入<code>go version</code>，若输出版本号则<strong>安装成功</strong>，如下：</p>
<pre><code>$ go version
go version go1.13.1 linux/amd64
</code></pre><h4 id="macos">MacOS</h4>
<p>在 MacOS 上安装 Go 最方便的办法就是使用 brew，安装如下：</p>
<pre><code>$ brew install go
</code></pre><p>升级命令如下：</p>
<pre><code>$ brew upgrade go
</code></pre><p>注：升级命令你不需要执行，但我想未来你有一天会用到的。</p>
<p>同样在控制台输入<code>go version</code>，若输出版本号则<strong>安装成功</strong>。</p>
<h3 id="了解-go">了解 Go</h3>
<h4 id="是什么">是什么</h4>
<blockquote>
<p>Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.</p>
</blockquote>
<p>上述为官方说明，如果简单来讲，大致为如下几点：</p>
<ul>
<li>Go 是编程语言。</li>
<li>谷歌爸爸撑腰。</li>
<li>语言级高并发。</li>
<li>上手快，入门简单。</li>
<li>简洁，很有特色。</li>
<li>国内使用人群逐年增多。</li>
</ul>
<h4 id="谁在用">谁在用</h4>
<p><img src="https://image.eddycjy.com/6d278b22a4c0bf29c6b89ece99cd6c88.jpg" alt="image"></p>
<h4 id="有什么">有什么</h4>
<p>那么大家会有些疑问，纠结 <code>Go</code> 本身有什么东西，我们刚刚设置的环境变量又有什么用呢，甚至作为一名老粉，你会纠结 GOPATH 去哪里了，我们一起接着往下看。</p>
<h5 id="目录结构">目录结构</h5>
<p>首先，我们在解压的时候会得到一个名为 <code>go</code> 的文件夹，其中包括了所有 <code>Go</code> 语言相关的一些文件，如下：</p>
<pre><code>$ tree -L 1 go
go
├── api
├── bin
├── doc
├── lib
├── misc
├── pkg
├── src
├── test
└── ...
</code></pre><p>在这之中包含了很多文件夹和文件，我们来简单说明其中主要文件夹的作用：</p>
<ul>
<li>api：用于存放依照 <code>Go</code> 版本顺序的 API 增量列表文件。这里所说的 API 包含公开的变量、常量、函数等。这些 API 增量列表文件用于 <code>Go</code> 语言 API 检查</li>
<li>bin：用于存放主要的标准命令文件（可执行文件），包含<code>go</code>、<code>godoc</code>、<code>gofmt</code></li>
<li>blog：用于存放官方博客中的所有文章</li>
<li>doc：用于存放标准库的 HTML 格式的程序文档。我们可以通过<code>godoc</code>命令启动一个 Web 程序展示这些文档</li>
<li>lib：用于存放一些特殊的库文件</li>
<li>misc：用于存放一些辅助类的说明和工具</li>
<li>pkg：用于存放安装<code>Go</code>标准库后的所有归档文件（以<code>.a</code>结尾的文件）。注意，你会发现其中有名称为<code>linux_amd64</code>的文件夹，我们称为平台相关目录。这类文件夹的名称由对应的操作系统和计算架构的名称组合而成。通过<code>go install</code>命令，<code>Go</code>程序会被编译成平台相关的归档文件存放到其中</li>
<li>src：用于存放 <code>Go</code>自身、<code>Go</code> 标准工具以及标准库的所有源码文件</li>
<li>test：存放用来测试和验证<code>Go</code>本身的所有相关文件</li>
</ul>
<h5 id="环境变量">环境变量</h5>
<p>你可能会疑惑刚刚设置的环境变量是什么，如下：</p>
<ul>
<li>GOROOT：<code>Go</code>的根目录。</li>
<li>PATH 下增加 <code>$GOROOT/bin</code>：<code>Go</code>的 <code>bin</code>下会存放可执行文件，我们把他加入 <code>$PATH</code> 后，未来拉下来并编译后的二进制文件就可以直接在命令行使用。</li>
</ul>
<p>那在什么东西都不下载的情况下，<code>$GOBIN</code> 下面有什么呢，如下：</p>
<pre><code>bin/ $ls
go  gofmt
</code></pre><ul>
<li>go：<code>Go</code> 二进制本身。</li>
<li>gofmt：代码格式化工具。</li>
</ul>
<p>因此我们刚刚把 <code>$GOBIN</code> 加入到 <code>$PATH</code> 后，你执行 <code>go version</code> 命令后就可以查看到对应的输出结果。</p>
<p>注：MacOS 用 brew 安装的话就不需要。</p>
<h4 id="放在哪">放在哪</h4>
<p>你现在知道 Go 是什么了，也知道 Go 的源码摆在哪了，你肯定会想，那我应用代码放哪呢，答案是在 <strong>Go1.11+ 和开启 Go Modules 的情况下摆哪都行</strong>。</p>
<h3 id="了解-go-modules">了解 Go Modules</h3>
<h4 id="了解历史">了解历史</h4>
<p>在过去，Go 的依赖包管理在工具上混乱且不统一，有 dep，有 glide，有 govendor&hellip;甚至还有因为外网的问题，频频导致拉不下来包，很多人苦不堪言，盼着官方给出一个大一统做出表率。</p>
<p>而在 Go modules 正式出来之前还有一个叫 dep 的项目，我们在上面有提到，它是 Go 的一个官方实验性项目，目的也是为了解决 Go 在依赖管理方面的问题，当时社区里面几乎所有的人都认为 dep 肯定就是未来 Go 官方的依赖管理解决方案了。</p>
<p>但是万万没想到，半路杀出个程咬金，Russ Cox 义无反顾地推出了 Go modules，这瞬间导致一石激起千层浪，让社区炸了锅。大家一致认为 Go team 实在是太霸道、太独裁了，连个招呼都不打一声。我记得当时有很多人在网上跟 Russ Cox 口水战，各种依赖管理解决方案的专家都冒出来发表意见，讨论范围甚至一度超出了 Go 语言的圈子触及到了其他语言的领域。</p>
<p>当然，最后，推成功了，Go modules 已经进入官方工具链中，与 Go 深深结合，以前常说的 GOPATH 终将会失去它原有的作用，而且它还提供了 GOPROXY 间接解决了国内访问外网的问题。</p>
<h4 id="了解-russ-cox">了解 Russ Cox</h4>
<p>在上文中提到的 Russ Cox 是谁呢，他是 Go 这个项目目前代码提交量最多的人，甚至是第二名的两倍还要多（从 2019 年 09 月 30 日前来看）。</p>
<p>Russ Cox 还是 Go 现在的掌舵人（大家应该知道之前 Go 的掌舵人是 Rob Pike，但是听说由于他本人不喜欢特朗普执政所以离开了美国，然后他岁数也挺大的了，所以也正在逐渐交权，不过现在还是在参与 Go 的发展）。</p>
<p>Russ Cox 的个人能力相当强，看问题的角度也很独特，这也就是为什么他刚一提出 Go modules 的概念就能引起那么大范围的响应。虽然是被强推的，但事实也证明当下的 Go modules 表现得确实很优秀，所以这表明一定程度上的 “独裁” 还是可以接受的，至少可以保证一个项目能更加专一地朝着一个方向发展。</p>
<h4 id="初始化行为">初始化行为</h4>
<p>在前面我们已经了解到 Go 依赖包管理的历史情况，接下来我们将正式的进入使用，首先你需要有一个你喜欢的目录，例如：<code>$ mkdir ~/go-application &amp;&amp; cd ~/go-application</code>，然后执行如下命令：</p>
<pre><code>$ mkdir go-gin-example &amp;&amp; cd go-gin-example

$ go env -w GO111MODULE=on

$ go env -w GOPROXY=https://goproxy.cn,direct

$ go mod init github.com/EDDYCJY/go-gin-example
go: creating new go.mod: module github.com/EDDYCJY/go-gin-example

$ ls
go.mod
</code></pre><ul>
<li><code>mkdir xxx &amp;&amp; cd xxx</code>：创建并切换到项目目录里去。</li>
<li><code>go env -w GO111MODULE=on</code>：打开 Go modules 开关（目前在 Go1.13 中默认值为 <code>auto</code>）。</li>
<li><code>go env -w GOPROXY=...</code>：设置 GOPROXY 代理，这里主要涉及到两个值，第一个是 <code>https://goproxy.cn</code>，它是由七牛云背书的一个强大稳定的 Go 模块代理，可以有效地解决你的外网问题；第二个是 <code>direct</code>，它是一个特殊的 fallback 选项，它的作用是用于指示 Go 在拉取模块时遇到错误会回源到模块版本的源地址去抓取（比如 GitHub 等）。</li>
<li><code>go mod init [MODULE_PATH]</code>：初始化 Go modules，它将会生成 go.mod 文件，需要注意的是 <code>MODULE_PATH</code> 填写的是模块引入路径，你可以根据自己的情况修改路径。</li>
</ul>
<p>在执行了上述步骤后，初始化工作已完成，我们打开 <code>go.mod</code> 文件看看，如下：</p>
<pre><code>module github.com/EDDYCJY/go-gin-example

go 1.13
</code></pre><p>默认的 <code>go.mod</code> 文件里主要是两块内容，一个是当前的模块路径和预期的 Go 语言版本。</p>
<h4 id="基础使用">基础使用</h4>
<ul>
<li>用 <code>go get</code> 拉取新的依赖
<ul>
<li>拉取最新的版本(优先择取 tag)：<code>go get golang.org/x/text@latest</code></li>
<li>拉取 <code>master</code> 分支的最新 commit：<code>go get golang.org/x/text@master</code></li>
<li>拉取 tag 为 v0.3.2 的 commit：<code>go get golang.org/x/text@v0.3.2</code></li>
<li>拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2：<code>go get golang.org/x/text@342b2e</code></li>
<li>用 <code>go get -u</code> 更新现有的依赖</li>
<li>用 <code>go mod download</code> 下载 go.mod 文件中指明的所有依赖</li>
<li>用 <code>go mod tidy</code> 整理现有的依赖</li>
<li>用 <code>go mod graph</code> 查看现有的依赖结构</li>
<li>用 <code>go mod init</code> 生成 go.mod 文件 (Go 1.13 中唯一一个可以生成 go.mod 文件的子命令)</li>
</ul>
</li>
<li>用 <code>go mod edit</code> 编辑 go.mod 文件</li>
<li>用 <code>go mod vendor</code> 导出现有的所有依赖 (事实上 Go modules 正在淡化 Vendor 的概念)</li>
<li>用 <code>go mod verify</code> 校验一个模块是否被篡改过</li>
</ul>
<p>这一小节主要是针对 Go modules 的基础使用讲解，还没具体的使用，是希望你能够留个印象，因为在后面章节会不断夹杂 Go modules 的知识点。</p>
<p>注：建议阅读官方文档 <a href="https://github.com/golang/go/wiki/Modules">wiki/Modules</a>。</p>
<h2 id="开始-gin-之旅">开始 Gin 之旅</h2>
<h3 id="是什么-1">是什么</h3>
<blockquote>
<p>Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance &ndash; up to 40 times faster. If you need smashing performance, get yourself some Gin.</p>
</blockquote>
<p>Gin 是用 Go 开发的一个微框架，类似 Martinier 的 API，重点是小巧、易用、性能好很多，也因为 <a href="https://github.com/julienschmidt/httprouter">httprouter</a> 的性能提高了 40 倍。</p>
<h3 id="安装">安装</h3>
<p>我们回到刚刚创建的 <code>go-gin-example</code> 目录下，在命令行下执行如下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ go get -u github.com/gin-gonic/gin
go: downloading golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223
go: extracting golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223
go: finding github.com/gin-contrib/sse v0.1.0
go: finding github.com/ugorji/go v1.1.7
go: finding gopkg.in/yaml.v2 v2.2.3
go: finding golang.org/x/sys latest
go: finding github.com/mattn/go-isatty v0.0.9
go: finding github.com/modern-go/concurrent latest
...
</code></pre></div><h4 id="gosum">go.sum</h4>
<p>这时候你再检查一下该目录下，会发现多个了个 <code>go.sum</code> 文件，如下：</p>
<pre><code>github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW...
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW...
github.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3 h1:t8FVkw33L+wilf2QiWkw0UV77qRpcH/JHPKGpKa2E8g=
github.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3/go.mod h1:VJ0WA2...
github.com/gin-contrib/sse v0.1.0 h1:Y/yl/+YNO...
...
</code></pre><p><code>go.sum</code> 文件详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p>
<h4 id="gomod">go.mod</h4>
<p>既然我们下载了依赖包，<code>go.mod</code> 文件会不会有所改变呢，我们再去看看，如下：</p>
<pre><code>module github.com/EDDYCJY/go-gin-example

go 1.13

require (
        github.com/gin-contrib/sse v0.1.0 // indirect
        github.com/gin-gonic/gin v1.4.0 // indirect
        github.com/golang/protobuf v1.3.2 // indirect
        github.com/json-iterator/go v1.1.7 // indirect
        github.com/mattn/go-isatty v0.0.9 // indirect
        github.com/ugorji/go v1.1.7 // indirect
        golang.org/x/sys v0.0.0-20190927073244-c990c680b611 // indirect
        gopkg.in/yaml.v2 v2.2.3 // indirect
)
</code></pre><p>确确实实发生了改变，那多出来的东西又是什么呢，<code>go.mod</code> 文件又保存了什么信息呢，实际上 <code>go.mod</code> 文件是启用了 Go modules 的项目所必须的最重要的文件，因为它描述了当前项目（也就是当前模块）的元信息，每一行都以一个动词开头，目前有以下 5 个动词:</p>
<ul>
<li>module：用于定义当前项目的模块路径。</li>
<li>go：用于设置预期的 Go 版本。</li>
<li>require：用于设置一个特定的模块版本。</li>
<li>exclude：用于从使用中排除一个特定的模块版本。</li>
<li>replace：用于将一个模块版本替换为另外一个模块版本。</li>
</ul>
<p>你可能还会疑惑 <code>indirect</code> 是什么东西，<code>indirect</code> 的意思是传递依赖，也就是非直接依赖。</p>
<h3 id="测试">测试</h3>
<p>编写一个<code>test.go</code>文件</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">r</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
  <span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/ping&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
      <span class="s">&#34;message&#34;</span><span class="p">:</span> <span class="s">&#34;pong&#34;</span><span class="p">,</span>
    <span class="p">})</span>
  <span class="p">})</span>
  <span class="nx">r</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span> <span class="c1">// listen and serve on 0.0.0.0:8080
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>执行<code>test.go</code></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ go run test.go
...
<span class="o">[</span>GIN-debug<span class="o">]</span> GET    /ping                     --&gt; main.main.func1 <span class="o">(</span><span class="m">3</span> handlers<span class="o">)</span>
<span class="o">[</span>GIN-debug<span class="o">]</span> Environment variable PORT is undefined. Using port :8080 by default
<span class="o">[</span>GIN-debug<span class="o">]</span> Listening and serving HTTP on :8080
</code></pre></div><p>访问 <code>$HOST:8080/ping</code>，若返回<code>{&quot;message&quot;:&quot;pong&quot;}</code>则正确</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">curl 127.0.0.1:8080/ping
</code></pre></div><p>至此，我们的环境安装和初步运行都基本完成了。</p>
<h2 id="再想一想">再想一想</h2>
<p>刚刚在执行了命令 <code>$ go get -u github.com/gin-gonic/gin</code> 后，我们查看了 <code>go.mod</code> 文件，如下：</p>
<pre><code>...
require (
        github.com/gin-contrib/sse v0.1.0 // indirect
        github.com/gin-gonic/gin v1.4.0 // indirect
        ...
)
</code></pre><p>你会发现 <code>go.mod</code> 里的 <code>github.com/gin-gonic/gin</code> 是 <code>indirect</code> 模式，这显然不对啊，因为我们的应用程序已经实际的编写了 gin server 代码了，我就想把它调对，怎么办呢，在应用根目录下执行如下命令：</p>
<pre><code>$ go mod tidy
</code></pre><p>该命令主要的作用是整理现有的依赖，非常的常用，执行后 <code>go.mod</code> 文件内容为：</p>
<pre><code>...
require (
        github.com/gin-contrib/sse v0.1.0 // indirect
        github.com/gin-gonic/gin v1.4.0
        ...
)
</code></pre><p>可以看到 <code>github.com/gin-gonic/gin</code> 已经变成了直接依赖，调整完毕。</p>
<h2 id="参考">参考</h2>
<h3 id="本系列示例代码">本系列示例代码</h3>
<ul>
<li><a href="https://github.com/EDDYCJY/go-gin-example">go-gin-example</a></li>
</ul>
<h3 id="相关文档">相关文档</h3>
<ul>
<li><a href="https://github.com/gin-gonic/gin">Gin</a></li>
<li><a href="https://gin-gonic.github.io/gin/">Gin Web Framework</a></li>
<li><a href="https://book.eddycjy.com/golang/talk/goproxy-cn.html">干货满满的 Go Modules 和 goproxy.cn</a></li>
</ul>
<h2 id="关于">关于</h2>
<h3 id="修改记录">修改记录</h3>
<ul>
<li>第一版：2018 年 02 月 16 日发布文章</li>
<li>第二版：2019 年 10 月 01 日修改文章</li>
</ul>
<h2 id="heading">？</h2>
<p>如果有任何疑问或错误，欢迎在 <a href="https://github.com/EDDYCJY/blog">issues</a> 进行提问或给予修正意见，如果喜欢或对你有所帮助，欢迎 Star，对作者是一种鼓励和推进。</p>
<h3 id="我的公众号">我的公众号</h3>
<p><img src="https://image.eddycjy.com/8d0b0c3a11e74efd5fdfd7910257e70b.jpg" alt="image"></p>
]]></content>
		</item>
		
	</channel>
</rss>
