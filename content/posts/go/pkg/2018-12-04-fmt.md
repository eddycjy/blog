---

title:      "fmt æ ‡å‡†åº“ --- Print* æ˜¯æ€ä¹ˆæ ·è¾“å‡ºçš„ï¼Ÿ"
date:       2018-12-04 12:00:00
author:     "ç…é±¼"
toc: true
tags:
    - go
    - æºç åˆ†æ
---

## å‰è¨€

```
package main

import (
	"fmt"
)

func main() {
	fmt.Println("Hello World!")
}
```

æ ‡å‡†å¼€åœºè§å¤šäº†ï¼Œé‚£å†…éƒ¨æ ‡å‡†åº“åˆæ˜¯æ€ä¹ˆè¾“å‡ºè¿™æ®µè‹±æ–‡çš„å‘¢ï¼Ÿä»Šå¤©ä¸€èµ·æ¥å›´è§‚ä¸‹æºç å§ ğŸ¤­

## åŸå‹


```
func Print(a ...interface{}) (n int, err error) {
	return Fprint(os.Stdout, a...)
}

func Println(a ...interface{}) (n int, err error) {
	return Fprintln(os.Stdout, a...)
}

func Printf(format string, a ...interface{}) (n int, err error) {
	return Fprintf(os.Stdout, format, a...)
}
```

- Printï¼šä½¿ç”¨é»˜è®¤æ ¼å¼è¯´æ˜ç¬¦æ‰“å°æ ¼å¼å¹¶å†™å…¥æ ‡å‡†è¾“å‡ºã€‚å½“ä¸¤è€…éƒ½ä¸æ˜¯å­—ç¬¦ä¸²æ—¶ï¼Œåœ¨æ“ä½œæ•°ä¹‹é—´æ·»åŠ ç©ºæ ¼
- Printlnï¼šåŒä¸Šï¼Œä¸åŒçš„åœ°æ–¹æ˜¯å§‹ç»ˆåœ¨æ“ä½œæ•°ä¹‹é—´æ·»åŠ ç©ºæ ¼ï¼Œå¹¶é™„åŠ æ¢è¡Œç¬¦
- Printfï¼šæ ¹æ®æ ¼å¼è¯´æ˜ç¬¦è¿›è¡Œæ ¼å¼åŒ–å¹¶å†™å…¥æ ‡å‡†è¾“å‡º

ä»¥ä¸Šä¸‰ç±»å°±æ˜¯æœ€å¸¸è§çš„æ ¼å¼åŒ– I/O çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å°†åŸºäºæ­¤å»è¿›è¡Œæ‹†è§£æè¿°

## æ‰§è¡Œæµç¨‹

### æ¡ˆä¾‹ä¸€ï¼šPrint

åœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ `Print` æ–¹æ³•åšä¸€ä¸ªåˆ†æï¼Œä¾¿äºåé¢çš„åŠ æ·±ç†è§£ ğŸ˜„

```
func Print(a ...interface{}) (n int, err error) {
	return Fprint(os.Stdout, a...)
}
```

`Print` ä½¿ç”¨é»˜è®¤æ ¼å¼è¯´æ˜ç¬¦æ‰“å°æ ¼å¼å¹¶å†™å…¥æ ‡å‡†è¾“å‡ºã€‚å¦å¤–å½“ä¸¤è€…éƒ½ä¸ºéç©ºå­—ç¬¦ä¸²æ—¶å°†æ’å…¥ä¸€ä¸ªç©ºæ ¼

#### åŸå‹

```
func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrint(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
```

è¯¥å‡½æ•°ä¸€å…±æœ‰ä¸¤ä¸ªå½¢å‚ï¼š

- wï¼šè¾“å‡ºæµï¼Œåªè¦å®ç° io.Writer å°±å¯ä»¥ï¼ˆæŠ½è±¡ï¼‰ä¸ºæµçš„å†™å…¥
- aï¼šä»»æ„ç±»å‹çš„å¤šä¸ªå€¼

#### åˆ†æä¸»å¹²æµç¨‹

1ã€ p := newPrinter(): ç”³è¯·ä¸€ä¸ªä¸´æ—¶å¯¹è±¡æ± ï¼ˆsync.Poolï¼‰

```
var ppFree = sync.Pool{
	New: func() interface{} { return new(pp) },
}

func newPrinter() *pp {
	p := ppFree.Get().(*pp)
	p.panicking = false
	p.erroring = false
	p.fmt.init(&p.buf)
	return p
}
```

- ppFree.Get()ï¼šåŸºäº sync.Pool å®ç° *pp çš„ä¸´æ—¶å¯¹è±¡æ± ï¼Œæ¯æ¬¡è·å–ä¸€å®šä¼šè¿”å›ä¸€ä¸ªæ–°çš„ pp å¯¹è±¡ç”¨äºæ¥ä¸‹æ¥çš„å¤„ç†
- *pp.panickingï¼šç”¨äºè§£å†³æ— é™é€’å½’çš„ panicã€recover é—®é¢˜ï¼Œä¼šæ ¹æ®è¯¥å‚æ•°åœ¨ catchPanic åŠæ—¶ææ–­
- *pp.erroringï¼šç”¨äºè¡¨ç¤ºæ­£åœ¨å¤„ç†é”™è¯¯æ— æ•ˆçš„ verb æ ‡è¯†ç¬¦ï¼Œä¸»è¦ä½œç”¨æ˜¯é˜²æ­¢è°ƒç”¨ handleMethods æ–¹æ³•
- *pp.fmt.init(&p.buf)ï¼šåˆå§‹åŒ– fmt é…ç½®ï¼Œä¼šè®¾ç½® buf å¹¶ä¸”æ¸…ç©º fmtFlags æ ‡å¿—ä½

2ã€ p.doPrint(a): æ‰§è¡Œçº¦å®šçš„æ ¼å¼åŒ–åŠ¨ä½œï¼ˆå‚æ•°é—´å¢åŠ ä¸€ä¸ªç©ºæ ¼ã€æœ€åä¸€ä¸ªå‚æ•°å¢åŠ æ¢è¡Œç¬¦ï¼‰

```
func (p *pp) doPrint(a []interface{}) {
	prevString := false
	for argNum, arg := range a {
	    true && false
		isString := arg != nil && reflect.TypeOf(arg).Kind() == reflect.String
		// Add a space between two non-string arguments.
		if argNum > 0 && !isString && !prevString {
			p.buf.WriteByte(' ')
		}
		p.printArg(arg, 'v')
		prevString = isString
	}
}
```

å¯ä»¥çœ‹åˆ°åº•å±‚é€šè¿‡åˆ¤æ–­è¯¥å…¥å‚ï¼Œ**åŒæ—¶**æ»¡è¶³ä»¥ä¸‹æ¡ä»¶å°±ä¼šæ·»åŠ åˆ†éš”ç¬¦ï¼ˆç©ºæ ¼ï¼‰ï¼š

- å½“å‰å…¥å‚ä¸ºå¤šä¸ªå‚æ•°ï¼ˆä¾‹å¦‚ï¼šSliceï¼‰
- å½“å‰å…¥å‚ä¸ä¸º nil ä¸”ä¸ä¸ºå­—ç¬¦ä¸²ï¼ˆé€šè¿‡åå°„ç¡®å®šï¼‰
- å½“å‰å…¥å‚ä¸ä¸ºé¦–é¡¹æˆ–ä¸Šä¸€ä¸ªå…¥å‚ä¸ä¸ºå­—ç¬¦ä¸²

è€Œåœ¨ `Print` æ–¹æ³•ä¸­ï¼Œä¸éœ€è¦æŒ‡å®šæ ¼å¼ç¬¦ã€‚å®é™…ä¸Šåœ¨è¯¥æ–¹æ³•å†…ç›´æ¥æŒ‡å®šä¸º `v`ã€‚ä¹Ÿå°±æ˜¯é»˜è®¤æ ¼å¼çš„å€¼

```
p.printArg(arg, 'v')
```

3. w.Write(p.buf): å†™å…¥æ ‡å‡†è¾“å‡ºï¼ˆio.Writerï¼‰

4. *pp.free(): é‡Šæ”¾å·²ç¼“å­˜çš„å†…å®¹ã€‚åœ¨ä½¿ç”¨å®Œä¸´æ—¶å¯¹è±¡åï¼Œä¼šå°† bufã€argã€value æ¸…ç©ºå†é‡æ–°å­˜æ”¾åˆ° ppFree ä¸­ã€‚ä»¥ä¾¿äºåé¢å†å–å‡ºé‡ç”¨ï¼ˆåˆ©ç”¨ sync.Pool çš„ä¸´æ—¶å¯¹è±¡ç‰¹æ€§ï¼‰

### æ¡ˆä¾‹äºŒï¼šPrintf

#### æ ‡è¯†ç¬¦

##### Verbs

```
%v	the value in a default format
	when printing structs, the plus flag (%+v) adds field names
%#v	a Go-syntax representation of the value
%T	a Go-syntax representation of the type of the value
%%	a literal percent sign; consumes no value
%t	the word true or false
```

##### Flags

```
+	always print a sign for numeric values;
	guarantee ASCII-only output for %q (%+q)
-	pad with spaces on the right rather than the left (left-justify the field)
#	alternate format: add leading 0 for octal (%#o), 0x for hex (%#x);
	0X for hex (%#X); suppress 0x for %p (%#p);
	for %q, print a raw (backquoted) string if strconv.CanBackquote
	returns true;
	always print a decimal point for %e, %E, %f, %F, %g and %G;
	do not remove trailing zeros for %g and %G;
	write e.g. U+0078 'x' if the character is printable for %U (%#U).
' '	(space) leave a space for elided sign in numbers (% d);
	put spaces between bytes printing strings or slices in hex (% x, % X)
0	pad with leading zeros rather than spaces;
	for numbers, this moves the padding after the sign
```

è¯¦ç»†å»ºè®®å‚è§ [Godoc](https://golang.org/pkg/fmt/#hdr-Printing)

#### åŸå‹

```
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrintf(format, a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
```

ä¸ Print ç›¸æ¯”ï¼Œæœ€å¤§çš„ä¸åŒå°±æ˜¯ doPrintf æ–¹æ³•äº†ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬æ¥è¯¦ç»†çœ‹çœ‹å…¶ä»£ç ï¼Œå¦‚ä¸‹ï¼š

```
func (p *pp) doPrintf(format string, a []interface{}) {
	end := len(format)
	argNum := 0         // we process one argument per non-trivial format
	afterIndex := false // previous item in format was an index like [3].
	p.reordered = false
formatLoop:
	for i := 0; i < end; {
		p.goodArgNum = true
		lasti := i
		for i < end && format[i] != '%' {
			i++
		}
		if i > lasti {
			p.buf.WriteString(format[lasti:i])
		}
		if i >= end {
			// done processing format string
			break
		}

		// Process one verb
		i++

		// Do we have flags?
		p.fmt.clearflags()
	simpleFormat:
		for ; i < end; i++ {
			c := format[i]
			switch c {
			case '#':   //'#'ã€'0'ã€'+'ã€'-'ã€' '
				...
			default:
				if 'a' <= c && c <= 'z' && argNum < len(a) {
					...
					p.printArg(a[argNum], rune(c))
					argNum++
					i++
					continue formatLoop
				}
				
				break simpleFormat
			}
		}

		// Do we have an explicit argument index?
		argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))

		// Do we have width?
		if i < end && format[i] == '*' {
			...
		}

		// Do we have precision?
		if i+1 < end && format[i] == '.' {
			...
		}

		if !afterIndex {
			argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))
		}

		if i >= end {
			p.buf.WriteString(noVerbString)
			break
		}

		...

		switch {
		case verb == '%': // Percent does not absorb operands and ignores f.wid and f.prec.
			p.buf.WriteByte('%')
		case !p.goodArgNum:
			p.badArgNum(verb)
		case argNum >= len(a): // No argument left over to print for the current verb.
			p.missingArg(verb)
		case verb == 'v':
			...
			fallthrough
		default:
			p.printArg(a[argNum], verb)
			argNum++
		}
	}

	if !p.reordered && argNum < len(a) {
		...
	}
}
```

#### åˆ†æä¸»å¹²æµç¨‹

1. å†™å…¥ % ä¹‹å‰çš„å­—ç¬¦å†…å®¹
2. å¦‚æœæ‰€æœ‰æ ‡å¿—ä½å¤„ç†å®Œæ¯•ï¼ˆåˆ°è¾¾å­—ç¬¦å°¾éƒ¨ï¼‰ï¼Œåˆ™è·³å‡ºå¤„ç†é€»è¾‘
3. ï¼ˆå¾€åç§»ï¼‰è·³è¿‡ % ï¼Œå¼€å§‹å¤„ç†å…¶ä»– verb æ ‡å¿—ä½
4. æ¸…ç©ºï¼ˆé‡æ–°åˆå§‹åŒ–ï¼‰ fmt é…ç½®
5. å¤„ç†ä¸€äº›åŸºç¡€çš„ verb æ ‡è¯†ç¬¦ï¼ˆsimpleFormatï¼‰ã€‚å¦‚ï¼š'#'ã€'0'ã€'+'ã€'-'ã€' ' ä»¥åŠ**ç®€å•çš„ verbs æ ‡è¯†ç¬¦ï¼ˆä¸åŒ…å«ç²¾åº¦ã€å®½åº¦å’Œå‚æ•°ç´¢å¼•ï¼‰ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè‹¥å½“å‰å­—ç¬¦ä¸ºç®€å• verb æ ‡è¯†ç¬¦ã€‚åˆ™ç›´æ¥è¿›è¡Œå¤„ç†ã€‚å®Œæˆåä¼šç›´æ¥åç§»åˆ°ä¸‹ä¸€ä¸ªå­—ç¬¦**ã€‚å…¶ä½™æ ‡å¿—ä½åˆ™å˜æ›´ fmt é…ç½®é¡¹ï¼Œä¾¿äºåç»­å¤„ç†
6. å¤„ç†å‚æ•°ç´¢å¼•ï¼ˆargument indexï¼‰
7. å¤„ç†å‚æ•°å®½åº¦ï¼ˆwidthï¼‰
8. å¤„ç†å‚æ•°ç²¾åº¦ï¼ˆprecisionï¼‰
9. % ä¹‹åè‹¥ä¸å­˜åœ¨ verbs æ ‡è¯†ç¬¦åˆ™è¿”å› `noVerbString`ã€‚å€¼ä¸º %!(NOVERB)
10. å¤„ç†ç‰¹æ®Š verbs æ ‡è¯†ç¬¦ï¼ˆå¦‚ï¼š'%%'ã€'%#v'ã€'%+v'ï¼‰ã€é”™è¯¯æƒ…å†µï¼ˆå¦‚ï¼šå‚æ•°ç´¢å¼•æŒ‡å®šé”™è¯¯ã€å‚æ•°é›†ä¸ªæ•°ä¸ verbs æ ‡è¯†ç¬¦æ•°é‡ä¸åŒ¹é…ï¼‰æˆ–è¿›è¡Œæ ¼å¼åŒ–å‚æ•°é›†
11. å¸¸è§„æµç¨‹å¤„ç†å®Œæ¯•

åœ¨ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œè‹¥æä¾›çš„å‚æ•°é›†æ¯” verb æ ‡è¯†ç¬¦å¤šã€‚fmt å°†ä¼šè´ªå©ªæ£€æŸ¥ä¸‹å»ï¼Œå°†å¤šå‡ºçš„å‚æ•°é›†ä»¥ç‰¹å®šçš„æ ¼å¼è¾“å‡ºï¼Œå¦‚ä¸‹ï¼š

```
fmt.Printf("%d", 1, 2, 3)
// 1%!(EXTRA int=2, int=3)
```

- çº¦å®šå‰ç¼€é¢å¤–æ ‡å¿—ï¼š%!(EXTRA
- å½“å‰å‚æ•°çš„ç±»å‹
- çº¦å®šæ ¼å¼ç¬¦ï¼š=
- å½“å‰å‚æ•°çš„å€¼ï¼ˆé»˜è®¤ä»¥ %v æ ¼å¼åŒ–ï¼‰
- çº¦å®šæ ¼å¼ç¬¦ï¼š)

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå½“æŒ‡å®šäº†å‚æ•°ç´¢å¼•æˆ–å®é™…å¤„ç†çš„å‚æ•°å°äºå…¥å‚çš„å‚æ•°é›†æ—¶ï¼Œå°±ä¸ä¼šè¿›è¡Œè´ªå©ªåŒ¹é…æ¥å±•ç¤º

### æ¡ˆä¾‹ä¸‰ï¼šPrintln

#### åŸå‹

```
func Fprintln(w io.Writer, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrintln(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
```

åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œæœ€å¤§çš„åŒºåˆ«å°±æ˜¯ doPrintlnï¼Œæˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹ï¼Œå¦‚ä¸‹ï¼š

```
func (p *pp) doPrintln(a []interface{}) {
	for argNum, arg := range a {
		if argNum > 0 {
			p.buf.WriteByte(' ')
		}
		p.printArg(arg, 'v')
	}
	p.buf.WriteByte('\n')
}
```

#### åˆ†æä¸»å¹²æµç¨‹

- å¾ªç¯å…¥å‚çš„å‚æ•°é›†ï¼Œå¹¶ä»¥ç©ºæ ¼åˆ†éš”
- æ ¼å¼åŒ–å½“å‰å‚æ•°ï¼Œé»˜è®¤ä»¥ `%v` å¯¹å‚æ•°è¿›è¡Œæ ¼å¼åŒ–
- åœ¨ç»“å°¾æ·»åŠ  `\n` å­—ç¬¦


## å¦‚ä½•æ ¼å¼åŒ–å‚æ•°

åœ¨ä¸Šä¾‹çš„æ‰§è¡Œæµç¨‹åˆ†æä¸­ï¼Œå¯ä»¥çœ‹åˆ°æ ¼å¼åŒ–å‚æ•°è¿™ä¸€æ­¥æ˜¯åœ¨ `p.printArg(arg, verb)` æ‰§è¡Œçš„ï¼Œæˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹å®ƒéƒ½åšäº†äº›ä»€ä¹ˆï¼Ÿ

```
func (p *pp) printArg(arg interface{}, verb rune) {
	p.arg = arg
	p.value = reflect.Value{}

	if arg == nil {
		switch verb {
		case 'T', 'v':
			p.fmt.padString(nilAngleString)
		default:
			p.badVerb(verb)
		}
		return
	}

	switch verb {
	case 'T':
		p.fmt.fmt_s(reflect.TypeOf(arg).String())
		return
	case 'p':
		p.fmtPointer(reflect.ValueOf(arg), 'p')
		return
	}

	// Some types can be done without reflection.
	switch f := arg.(type) {
	case bool:
		p.fmtBool(f, verb)
	case float32:
		p.fmtFloat(float64(f), 32, verb)
	...
	case reflect.Value:
		if f.IsValid() && f.CanInterface() {
			p.arg = f.Interface()
			if p.handleMethods(verb) {
				return
			}
		}
		p.printValue(f, verb, 0)
	default:
		if !p.handleMethods(verb) {
			p.printValue(reflect.ValueOf(f), verb, 0)
		}
	}
}
```

åœ¨å°èŠ‚ä»£ç ä¸­å¯ä»¥çœ‹è§ï¼Œfmt æœ¬èº«å¯¹ä¸åŒçš„ç±»å‹åšäº†ä¸åŒçš„å¤„ç†ã€‚è¿™æ ·å­å°±é¿å…äº†é€šè¿‡åå°„ç¡®å®šã€‚ç›¸å¯¹çš„æé«˜äº†æ€§èƒ½

å…¶ä¸­æœ‰ä¸¤ä¸ªç‰¹æ®Šçš„æ–¹æ³•ï¼Œåˆ†åˆ«æ˜¯ `handleMethods` å’Œ `badVerb`ï¼Œæ¥ä¸‹æ¥åˆ†åˆ«æ¥çœ‹çœ‹ä»–ä»¬çš„ä½œç”¨æ˜¯ä»€ä¹ˆ

1ã€badVerb

å®ƒä¸»è¦ç”¨äºæ ¼å¼åŒ–å¹¶å¤„ç†é”™è¯¯çš„è¡Œä¸ºã€‚æˆ‘ä»¬å¯ä»¥ä¸€èµ·æ¥çœ‹çœ‹ï¼Œä»£ç å¦‚ä¸‹ï¼š

```
func (p *pp) badVerb(verb rune) {
	p.erroring = true
	p.buf.WriteString(percentBangString)
	p.buf.WriteRune(verb)
	p.buf.WriteByte('(')
	switch {
	case p.arg != nil:
		p.buf.WriteString(reflect.TypeOf(p.arg).String())
		p.buf.WriteByte('=')
		p.printArg(p.arg, 'v')
	...
	default:
		p.buf.WriteString(nilAngleString)
	}
	p.buf.WriteByte(')')
	p.erroring = false
}
```

åœ¨å¤„ç†é”™è¯¯æ ¼å¼åŒ–æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹æ¯”ä»¥ä¸‹ä¾‹å­ï¼š

```
fmt.Printf("%s", []int64{1, 2, 3})
// [%!s(int64=1) %!s(int64=2) %!s(int64=3)]%
```

åœ¨ badVerb ä¸­å¯ä»¥çœ‹åˆ°é”™è¯¯å­—ç¬¦ä¸²çš„å¤„ç†ä¸»è¦åˆ†ä¸ºä»¥ä¸‹éƒ¨åˆ†ï¼š

- çº¦å®šå‰ç¼€é”™è¯¯æ ‡å¿—ï¼š%!
- å½“å‰çš„æ ¼å¼åŒ–æ“ä½œç¬¦
- çº¦å®šæ ¼å¼ç¬¦ï¼š(
- å½“å‰å‚æ•°çš„ç±»å‹
- çº¦å®šæ ¼å¼ç¬¦ï¼š=
- å½“å‰å‚æ•°çš„å€¼ï¼ˆé»˜è®¤ä»¥ %v æ ¼å¼åŒ–ï¼‰
- çº¦å®šæ ¼å¼ç¬¦ï¼š)

2ã€handleMethods

```
func (p *pp) handleMethods(verb rune) (handled bool) {
	if p.erroring {
		return
	}
	// Is it a Formatter?
	if formatter, ok := p.arg.(Formatter); ok {
		handled = true
		defer p.catchPanic(p.arg, verb)
		formatter.Format(p, verb)
		return
	}

	// If we're doing Go syntax and the argument knows how to supply it, take care of it now.
	...
	
	return false
}
```

è¿™ä¸ªæ–¹æ³•æ¯”è¾ƒç‰¹æ®Šï¼Œä¸€èˆ¬åœ¨è‡ªå®šä¹‰ç»“æ„ä½“å’ŒæœªçŸ¥æƒ…å†µä¸‹è¿›è¡Œè°ƒç”¨ã€‚ä¸»è¦æµç¨‹æ˜¯ï¼š

- è‹¥å½“å‰å‚æ•°ä¸ºé”™è¯¯ verb æ ‡è¯†ç¬¦ï¼Œåˆ™ç›´æ¥è¿”å›
- åˆ¤æ–­æ˜¯å¦å®ç°äº† Formatter 
- å®ç°ï¼Œåˆ™åˆ©ç”¨è‡ªå®šä¹‰ Formatter æ ¼å¼åŒ–å‚æ•°
- æœªå®ç°ï¼Œåˆ™æœ€å¤§ç¨‹åº¦çš„åˆ©ç”¨ Go syntax é»˜è®¤è§„åˆ™å»æ ¼å¼åŒ–å‚æ•°

## æ‹“å±•

åœ¨ fmt æ ‡å‡†åº“ä¸­å¯ä»¥é€šè¿‡è‡ªå®šä¹‰ç»“æ„ä½“æ¥å®ç°æ–¹æ³•çš„è‡ªå®šä¹‰ï¼Œå¤§è‡´å¦‚ä¸‹å‡ ç§

### fmt.State

```
type State interface {
	Write(b []byte) (n int, err error)

	Width() (wid int, ok bool)

	Precision() (prec int, ok bool)

	Flag(c int) bool
}
```

State ç”¨äºè·å–æ ‡å¿—ä½çš„çŠ¶æ€å€¼ï¼Œæ¶‰åŠå¦‚ä¸‹ï¼š

- Writeï¼šå°†æ ¼å¼åŒ–å®Œæ¯•çš„å­—ç¬¦å†™å…¥ç¼“å†²åŒºä¸­ï¼Œç­‰å¾…ä¸‹ä¸€æ­¥å¤„ç†
- Widthï¼šè¿”å›å®½åº¦ä¿¡æ¯å’Œæ˜¯å¦è¢«è®¾ç½®
- Precisionï¼šè¿”å›ç²¾åº¦ä¿¡æ¯å’Œæ˜¯å¦è¢«è®¾ç½®
- Flagï¼šè¿”å›ç‰¹æ®Šæ ‡å¿—ç¬¦ï¼ˆ'#'ã€'0'ã€'+'ã€'-'ã€' 'ï¼‰æ˜¯å¦è¢«è®¾ç½®

### fmt.Formatter

```
type Formatter interface {
	Format(f State, c rune)
}
```

Formatter ç”¨äºå®ç°**è‡ªå®šä¹‰æ ¼å¼åŒ–æ–¹æ³•**ã€‚å¯é€šè¿‡åœ¨è‡ªå®šä¹‰ç»“æ„ä½“ä¸­å®ç° Format æ–¹æ³•æ¥å®ç°è¿™ä¸ªç›®çš„

å¦å¤–ï¼Œå¯ä»¥é€šè¿‡ f è·å–åˆ°å½“å‰æ ‡è¯†ç¬¦çš„å®½åº¦ã€ç²¾åº¦ç­‰çŠ¶æ€å€¼ã€‚c ä¸º verb æ ‡è¯†ç¬¦ï¼Œå¯ä»¥å¾—åˆ°å…¶åŠ¨ä½œæ˜¯ä»€ä¹ˆ

### fmt.Stringer

```
type Stringer interface {
	String() string
}
```

å½“è¯¥å¯¹è±¡ä¸º Stringã€Arrayã€Slice ç­‰ç±»å‹æ—¶ï¼Œå°†ä¼šè°ƒç”¨ `String()` æ–¹æ³•å¯¹ç±»å­—ç¬¦ä¸²è¿›è¡Œæ ¼å¼åŒ–

### fmt.GoStringer

```
type GoStringer interface {
	GoString() string
}
```

å½“æ ¼å¼åŒ–ç‰¹å®š verb æ ‡è¯†ç¬¦ï¼ˆ%vï¼‰æ—¶ï¼Œå°†è°ƒç”¨ `GoString()` æ–¹æ³•å¯¹å…¶è¿›è¡Œæ ¼å¼åŒ–


## æ€»ç»“

é€šè¿‡æœ¬æ–‡å¯¹ fmt æ ‡å‡†åº“çš„åˆ†æï¼Œå¯ä»¥å‘ç°å®ƒæœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- åœ¨æ‹“å±•æ€§æ–¹é¢ï¼Œå¯ä»¥è‡ªå®šä¹‰æ ¼å¼åŒ–æ–¹æ³•ç­‰
- åœ¨å®Œæ•´åº¦æ–¹é¢ï¼Œå°½å¯èƒ½çš„è´ªå©ªåŒ¹é…ï¼Œè¾“å‡ºå‚æ•°é›†
- åœ¨æ€§èƒ½æ–¹é¢ï¼Œæ¯ç§ä¸åŒçš„å‚æ•°ç±»å‹ï¼Œéƒ½å®ç°äº†ä¸åŒçš„æ ¼å¼åŒ–å¤„ç†æ“ä½œ
- åœ¨æ€§èƒ½æ–¹é¢ï¼Œå°½å¯èƒ½çš„æœ€çŸ­åŒ¹é…ï¼Œæ ¼å¼åŒ–å‚æ•°é›†

æ€»çš„æ¥è¯´ï¼Œfmt æ ‡å‡†åº“æœ‰è®¸å¤šå€¼å¾—æ¨æ•²çš„ç»†èŠ‚ï¼Œå¸Œæœ›ä½ èƒ½å¤Ÿåœ¨æœ¬æ–‡å­¦åˆ° ğŸ˜„
